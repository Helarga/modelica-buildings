<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Model diagnosis</title>

</head>
<body>
<h2>Flattened model: Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding</h2>
<pre>
fclass Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding
 parameter Modelica.SIunits.MassFlowRate m1_flow_nominal = 7.024856596558317 .* bui.delTBuiCoo / delTDisCoo "Nominal mass flow rate of primary (district) district cooling side";
 structural parameter Modelica.SIunits.MassFlowRate m2_flow_nominal = 7.024856596558317 "Nominal mass flow rate of secondary (building) district cooling side" /* 7.024856596558317 */;
 parameter Modelica.SIunits.TemperatureDifference delTDisCoo = 10 "Nominal district supply and return water temperature difference" annotation(absoluteValue = false) /* 10 */;
 parameter Modelica.SIunits.MassFlowRate coo.m1_flow_nominal(final min = 0,start = 0.5) = m1_flow_nominal "Nominal mass flow rate of primary (district) district cooling side";
 structural parameter Modelica.SIunits.MassFlowRate coo.m2_flow_nominal = 7.024856596558317 "Nominal mass flow rate of secondary (building) district cooling side" /* 7.024856596558317 */;
 parameter Modelica.SIunits.Pressure coo.dpValve_nominal(final min = 0,final displayUnit = "Pa") = 7000 "Nominal pressure drop of fully open control valve" /* 7000 */;
 structural parameter Modelica.SIunits.Pressure coo.dp1_nominal = 500 "Nominal pressure difference on primary side" /* 500 */;
 structural parameter Modelica.SIunits.Pressure coo.dp2_nominal = 500 "Nominal pressure difference on secondary side" /* 500 */;
 parameter Boolean coo.use_Q_flow_nominal = false "Set to true to specify Q_flow_nominal and temperatures, or to false to specify effectiveness" /* false */;
 structural parameter Modelica.SIunits.HeatFlowRate coo.Q_flow_nominal = 146960.0 "Nominal heat transfer" /* 146960.0 */;
 parameter Modelica.SIunits.ThermodynamicTemperature coo.T_a1_nominal(min = 273,max = 100 + 273.15,start = 5 + 273.15,final displayUnit = "K") = 273.15 + 8 "Nominal temperature at port a1" /* 281.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature coo.T_a2_nominal(min = 273,max = 100 + 273.15,start = 7 + 273.15,final displayUnit = "K") = 273.15 + 19 "Nominal temperature at port a2" /* 292.15 */;
 parameter Modelica.SIunits.Efficiency coo.eta(final min = 0,final max = 1) = 0.75 "Constant effectiveness" /* 0.75 */;
 parameter Modelica.Blocks.Types.SimpleController coo.controllerType = Modelica.Blocks.Types.SimpleController.PI "Type of controller" /* Modelica.Blocks.Types.SimpleController.PI */;
 parameter Real coo.k(final min = 0,final unit = "1") = 1 "Gain of controller" /* 1 */;
 parameter Modelica.SIunits.Time coo.Ti(min = 1.0E-60) = 10 "Time constant of integrator block" /* 10 */;
 structural parameter Modelica.SIunits.Time coo.Td = 0.1 "Time constant of derivative block" /* 0.1 */;
 structural parameter Real coo.yMax = 1 "Upper limit of output" /* 1 */;
 structural parameter Real coo.yMin = 0 "Lower limit of output" /* 0 */;
 parameter Real coo.wp(final min = 0) = 1 "Set-point weight for Proportional block (0..1)" /* 1 */;
 parameter Real coo.wd(final min = 0) = 0 "Set-point weight for Derivative block (0..1)" /* 0 */;
 parameter Real coo.Ni(min = 100 * 1.0E-15) = 0.9 "Ni*Ti is time constant of anti-windup compensation" /* 0.9 */;
 parameter Real coo.Nd(min = 100 * 1.0E-15) = 10 "The higher Nd, the more ideal the derivative block" /* 10 */;
 eval parameter Modelica.Blocks.Types.InitPID coo.initType = Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)" /* Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState */;
 structural parameter Real coo.xi_start = 0 "Initial or guess value value for integrator output (= integrator state)" /* 0 */;
 parameter Real coo.xd_start = 0 "Initial or guess value for state of derivative block" /* 0 */;
 structural parameter Real coo.yCon_start = 0 "Initial value of output from the controller" /* 0 */;
 parameter Boolean coo.reverseAction = true "Set to true for throttling the water flow rate through a cooling coil controller" /* true */;
 Modelica.Blocks.Interfaces.RealInput coo.TSet(final quantity = "ThermodynamicTemperature",final unit = "K") "Setpoint temperature";
 Modelica.Blocks.Interfaces.RealOutput coo.Q_flow(final quantity = "Power",final unit = "W",final displayUnit = "kW") "Measured power demand at the ETS";
 Modelica.Blocks.Interfaces.RealOutput coo.Q(final quantity = "Energy",final unit = "J",final displayUnit = "kWh") "Measured energy consumption at the ETS";
 eval parameter Buildings.Fluid.Types.HeatExchangerConfiguration coo.hex.configuration = Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow "Heat exchanger configuration" /* Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow */;
 eval parameter Boolean coo.hex.use_Q_flow_nominal = true "Set to true to specify Q_flow_nominal and temperatures, or to false to specify effectiveness" /* true */;
 structural parameter Modelica.SIunits.HeatFlowRate coo.hex.Q_flow_nominal = 146960.0 "Nominal heat transfer" /* 146960.0 */;
 parameter Modelica.SIunits.ThermodynamicTemperature coo.hex.T_a1_nominal(fixed = true) = coo.T_a1_nominal "Nominal temperature at port a1";
 parameter Modelica.SIunits.ThermodynamicTemperature coo.hex.T_a2_nominal(fixed = true) = coo.T_a2_nominal "Nominal temperature at port a2";
 initial parameter Real coo.hex.eps_nominal(fixed = not true) "Nominal heat transfer effectiveness";
 Modelica.SIunits.ThermalConductance coo.hex.UA = 1 / (1 / coo.hex.hA1 + 1 / coo.hex.hA2) "UA value";
 Real coo.hex.eps(min = 0,max = 1) "Heat exchanger effectiveness";
 initial parameter Modelica.SIunits.ThermalConductance coo.hex.UA_nominal(fixed = false) "Nominal UA value";
 initial parameter Real coo.hex.NTU_nominal(min = 0,fixed = false) "Nominal number of transfer units";
 Buildings.Media.Water.Temperature coo.hex.T_in1(start = 293.15) = coo.hex.fra_a1 * Buildings.Media.Water.temperature(coo.hex.state_a1_inflow) + coo.hex.fra_b1 * Buildings.Media.Water.temperature(coo.hex.state_b1_inflow) "Inlet temperature medium 1";
 Buildings.Media.Water.Temperature coo.hex.T_in2(start = 293.15) = coo.hex.fra_a2 * Buildings.Media.Water.temperature(coo.hex.state_a2_inflow) + coo.hex.fra_b2 * Buildings.Media.Water.temperature(coo.hex.state_b2_inflow) "Inlet temperature medium 2";
 Modelica.SIunits.ThermalConductance coo.hex.C1_flow = abs(coo.hex.m1_flow) * (coo.hex.fra_a1 * Buildings.Media.Water.specificHeatCapacityCp(coo.hex.state_a1_inflow) + coo.hex.fra_b1 * Buildings.Media.Water.specificHeatCapacityCp(coo.hex.state_b1_inflow)) "Heat capacity flow rate medium 1";
 Modelica.SIunits.ThermalConductance coo.hex.C2_flow = abs(coo.hex.m2_flow) * (coo.hex.fra_a2 * Buildings.Media.Water.specificHeatCapacityCp(coo.hex.state_a2_inflow) + coo.hex.fra_b2 * Buildings.Media.Water.specificHeatCapacityCp(coo.hex.state_b2_inflow)) "Heat capacity flow rate medium 2";
 Modelica.SIunits.ThermalConductance coo.hex.CMin_flow(min = 0) = min(coo.hex.C1_flow, coo.hex.C2_flow) "Minimum heat capacity flow rate";
 Modelica.SIunits.HeatFlowRate coo.hex.QMax_flow = coo.hex.CMin_flow * (coo.hex.T_in2 - coo.hex.T_in1) "Maximum heat flow rate into medium 1";
 constant Boolean coo.hex.prescribedHeatFlowRate1 = true "Set to true if the heat flow rate into fluid 1 is not a function of the component temperature";
 constant Boolean coo.hex.prescribedHeatFlowRate2 = true "Set to true if the heat flow rate into fluid 2 is not a function of the component temperature";
 constant Boolean coo.hex.homotopyInitialization = true "= true, use homotopy method";
 Modelica.SIunits.HeatFlowRate coo.hex.Q1_flow = coo.hex.eps * coo.hex.QMax_flow "Heat transferred into the medium 1";
 Buildings.Media.Water.MassFlowRate coo.hex.mWat1_flow = 0 "Moisture mass flow rate added to the medium 1";
 Modelica.SIunits.HeatFlowRate coo.hex.Q2_flow = - coo.hex.Q1_flow "Heat transferred into the medium 2";
 Buildings.Media.Water.MassFlowRate coo.hex.mWat2_flow = 0 "Moisture mass flow rate added to the medium 2";
 constant Boolean coo.hex.sensibleOnly1 = true "Set to true if sensible exchange only for medium 1";
 constant Boolean coo.hex.sensibleOnly2 = true "Set to true if sensible exchange only for medium 2";
 parameter Modelica.SIunits.MassFlowRate coo.hex.m1_flow_nominal(min = 0) = coo.m1_flow_nominal "Nominal mass flow rate";
 structural parameter Modelica.SIunits.MassFlowRate coo.hex.m2_flow_nominal = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 parameter Buildings.Media.Water.MassFlowRate coo.hex.m1_flow_small(min = 0) = 1.0E-4 * abs(coo.hex.m1_flow_nominal) "Small mass flow rate for regularization of zero flow";
 structural parameter Buildings.Media.Water.MassFlowRate coo.hex.m2_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 structural parameter Boolean coo.hex.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Buildings.Media.Water.MassFlowRate coo.hex.m1_flow = coo.hex.port_a1.m_flow "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure coo.hex.dp1(displayUnit = "Pa") = coo.hex.port_a1.p - coo.hex.port_b1.p "Pressure difference between port_a1 and port_b1";
 Buildings.Media.Water.MassFlowRate coo.hex.m2_flow = coo.hex.port_a2.m_flow "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure coo.hex.dp2(displayUnit = "Pa") = coo.hex.port_a2.p - coo.hex.port_b2.p "Pressure difference between port_a2 and port_b2";
 eval parameter Boolean coo.hex.allowFlowReversal1 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1" /* true */;
 eval parameter Boolean coo.hex.allowFlowReversal2 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2" /* true */;
 Buildings.Media.Water.MassFlowRate coo.hex.port_a1.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.port_a1.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.port_a1.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.port_a1.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.port_a1.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.hex.port_b1.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.port_b1.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.port_b1.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.port_b1.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.port_b1.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.hex.port_a2.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.port_a2.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.port_a2.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.port_a2.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.port_a2.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.hex.port_b2.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.port_b2.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.port_b2.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.port_b2.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.port_b2.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean coo.hex.computeFlowResistance1 = true "=true, compute flow resistance. Set to false to assume no friction" /* true */;
 eval parameter Boolean coo.hex.from_dp1 = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure coo.hex.dp1_nominal = 500 "Pressure difference" /* 500 */;
 structural parameter Boolean coo.hex.linearizeFlowResistance1 = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real coo.hex.deltaM1 = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 eval parameter Boolean coo.hex.computeFlowResistance2 = true "=true, compute flow resistance. Set to false to assume no friction" /* true */;
 eval parameter Boolean coo.hex.from_dp2 = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure coo.hex.dp2_nominal = 500 "Pressure difference" /* 500 */;
 structural parameter Boolean coo.hex.linearizeFlowResistance2 = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real coo.hex.deltaM2 = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 Real coo.con.controlError = coo.con.u_s - coo.con.u_m "Control error (set point - measurement)";
 structural parameter Modelica.Blocks.Types.SimpleController coo.con.controllerType = Modelica.Blocks.Types.SimpleController.PID "Type of controller" /* Modelica.Blocks.Types.SimpleController.PID */;
 parameter Real coo.con.k(min = 0) = coo.k "Gain of controller";
 parameter Modelica.SIunits.Time coo.con.Ti(min = 1.0E-60) = coo.Ti "Time constant of Integrator block";
 structural parameter Modelica.SIunits.Time coo.con.Td = 0.1 "Time constant of Derivative block" /* 0.1 */;
 structural parameter Real coo.con.yMax = 1 "Upper limit of output" /* 1 */;
 structural parameter Real coo.con.yMin = 0 "Lower limit of output" /* 0 */;
 parameter Real coo.con.wp(min = 0) = coo.wp "Set-point weight for Proportional block (0..1)";
 parameter Real coo.con.wd(min = 0) = coo.wd "Set-point weight for Derivative block (0..1)";
 parameter Real coo.con.Ni(min = 100 * 1.0E-15) = coo.Ni "Ni*Ti is time constant of anti-windup compensation";
 parameter Real coo.con.Nd(min = 100 * 1.0E-15) = coo.Nd "The higher Nd, the more ideal the derivative block";
 eval parameter Modelica.Blocks.Types.InitPID coo.con.initType = Modelica.Blocks.Types.InitPID.InitialOutput "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)" /* Modelica.Blocks.Types.InitPID.InitialOutput */;
 structural parameter Real coo.con.xi_start = 0 "Initial or guess value value for integrator output (= integrator state)" /* 0 */;
 parameter Real coo.con.xd_start = coo.xd_start "Initial or guess value for state of derivative block";
 structural parameter Real coo.con.y_start = 0 "Initial value of output" /* 0 */;
 eval parameter Boolean coo.con.strict = true "= true, if strict limits with noEvent(..)" /* true */;
 parameter Boolean coo.con.reverseAction = coo.reverseAction "Set to true for throttling the water flow rate through a cooling coil controller";
 eval parameter Buildings.Types.Reset coo.con.reset = Buildings.Types.Reset.Disabled "Type of controller output reset" /* Buildings.Types.Reset.Disabled */;
 structural parameter Real coo.con.y_reset = 0 "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == Buildings.Types.Reset.Parameter" /* 0 */;
 parameter Real coo.con.addP.k1 = coo.con.revAct * coo.con.wp "Gain of upper input";
 parameter Real coo.con.addP.k2 = - coo.con.revAct "Gain of lower input";
 Modelica.Blocks.Interfaces.RealInput coo.con.addP.u1 "Connector of Real input signal 1";
 Modelica.Blocks.Interfaces.RealInput coo.con.addP.u2 "Connector of Real input signal 2";
 Modelica.Blocks.Interfaces.RealOutput coo.con.addP.y "Connector of Real output signal";
 parameter Real coo.con.addD.k1 = coo.con.revAct * coo.con.wd "Gain of upper input";
 parameter Real coo.con.addD.k2 = - coo.con.revAct "Gain of lower input";
 Modelica.Blocks.Interfaces.RealInput coo.con.addD.u1 "Connector of Real input signal 1";
 Modelica.Blocks.Interfaces.RealInput coo.con.addD.u2 "Connector of Real input signal 2";
 Modelica.Blocks.Interfaces.RealOutput coo.con.addD.y "Connector of Real output signal";
 parameter Real coo.con.P.k(start = 1,unit = "1") = 1 "Gain value multiplied with input signal" /* 1 */;
 Modelica.Blocks.Interfaces.RealInput coo.con.P.u "Input signal connector";
 Modelica.Blocks.Interfaces.RealOutput coo.con.P.y "Output signal connector";
 parameter Real coo.con.I.k(unit = "1") = 1.0 / coo.con.Ti "Integrator gain";
 eval parameter Modelica.Blocks.Types.Init coo.con.I.initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3,4: initial output)" /* Modelica.Blocks.Types.Init.NoInit */;
 parameter Real coo.con.I.y_start = 0.0 "Initial or guess value of output (= state)" /* 0.0 */;
 structural parameter Buildings.Types.Reset coo.con.I.reset = Buildings.Types.Reset.Disabled "Type of integrator reset" /* Buildings.Types.Reset.Disabled */;
 eval parameter Real coo.con.I.y_reset = 0 "Value to which integrator is reset, used if reset = Buildings.Types.Reset.Parameter" /* 0 */;
 Modelica.Blocks.Interfaces.RealInput coo.con.I.u "Connector of Real input signal";
 Modelica.Blocks.Interfaces.RealOutput coo.con.I.y(start = coo.con.I.y_start) "Connector of Real output signal";
 structural parameter Real coo.con.D.k = 0.1 "Gains" /* 0.1 */;
 parameter Modelica.SIunits.Time coo.con.D.T(min = 1.0E-60) = max([0.1 / coo.con.Nd, 1.0E-14]) "Time constants (T>0 required; T=0 is ideal derivative block)";
 eval parameter Modelica.Blocks.Types.Init coo.con.D.initType = Modelica.Blocks.Types.Init.SteadyState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)" /* Modelica.Blocks.Types.Init.SteadyState */;
 parameter Real coo.con.D.x_start = coo.con.xd_start "Initial or guess value of state";
 parameter Real coo.con.D.y_start = 0 "Initial value of output (= state)" /* 0 */;
 Real coo.con.D.x(start = coo.con.D.x_start) "State of block";
 Modelica.Blocks.Interfaces.RealInput coo.con.D.u "Connector of Real input signal";
 Modelica.Blocks.Interfaces.RealOutput coo.con.D.y "Connector of Real output signal";
 final parameter Real coo.con.addPID.k1 = 1 "Gain of upper input" /* 1 */;
 final parameter Real coo.con.addPID.k2 = 1 "Gain of middle input" /* 1 */;
 final parameter Real coo.con.addPID.k3 = 1 "Gain of lower input" /* 1 */;
 Modelica.Blocks.Interfaces.RealInput coo.con.addPID.u1 "Connector 1 of Real input signals";
 Modelica.Blocks.Interfaces.RealInput coo.con.addPID.u2 "Connector 2 of Real input signals";
 Modelica.Blocks.Interfaces.RealInput coo.con.addPID.u3 "Connector 3 of Real input signals";
 Modelica.Blocks.Interfaces.RealOutput coo.con.addPID.y "Connector of Real output signals";
 Modelica.Blocks.Interfaces.RealInput coo.con.u_s "Connector of setpoint input signal";
 Modelica.Blocks.Interfaces.RealInput coo.con.u_m "Connector of measurement input signal";
 Modelica.Blocks.Interfaces.RealOutput coo.con.y "Connector of actuator output signal";
 Modelica.Blocks.Interfaces.RealOutput coo.senTDisSup.T(final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC",min = 0,start = coo.senTDisSup.T_start) "Temperature of the passing fluid";
 parameter Modelica.SIunits.ThermodynamicTemperature coo.senTDisSup.T_start = 293.15 "Initial or guess value of output (= state)" /* 293.15 */;
 eval parameter Boolean coo.senTDisSup.transferHeat = false "if true, temperature T converges towards TAmb when no flow" /* false */;
 parameter Modelica.SIunits.ThermodynamicTemperature coo.senTDisSup.TAmb = 293.15 "Fixed ambient temperature for heat transfer" /* 293.15 */;
 parameter Modelica.SIunits.Time coo.senTDisSup.tauHeaTra(min = 1) = 1200 "Time constant for heat transfer, default 20 minutes" /* 1200 */;
 structural parameter Modelica.SIunits.Time coo.senTDisSup.tau = 1 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)" /* 1 */;
 eval parameter Modelica.Blocks.Types.Init coo.senTDisSup.initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)" /* Modelica.Blocks.Types.Init.InitialState */;
 parameter Modelica.SIunits.MassFlowRate coo.senTDisSup.m_flow_nominal(min = 0) = coo.m1_flow_nominal "Nominal mass flow rate, used for regularization near zero flow";
 parameter Modelica.SIunits.MassFlowRate coo.senTDisSup.m_flow_small(min = 0) = 1.0E-4 * coo.senTDisSup.m_flow_nominal "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
 eval parameter Boolean coo.senTDisSup.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.senTDisSup.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.senTDisSup.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.senTDisSup.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.senTDisSup.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.senTDisSup.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.senTDisSup.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.senTDisSup.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.senTDisSup.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.senTDisSup.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.senTDisSup.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput coo.senTDisRet.T(final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC",min = 0,start = coo.senTDisRet.T_start) "Temperature of the passing fluid";
 parameter Modelica.SIunits.ThermodynamicTemperature coo.senTDisRet.T_start = 293.15 "Initial or guess value of output (= state)" /* 293.15 */;
 eval parameter Boolean coo.senTDisRet.transferHeat = false "if true, temperature T converges towards TAmb when no flow" /* false */;
 parameter Modelica.SIunits.ThermodynamicTemperature coo.senTDisRet.TAmb = 293.15 "Fixed ambient temperature for heat transfer" /* 293.15 */;
 parameter Modelica.SIunits.Time coo.senTDisRet.tauHeaTra(min = 1) = 1200 "Time constant for heat transfer, default 20 minutes" /* 1200 */;
 structural parameter Modelica.SIunits.Time coo.senTDisRet.tau = 1 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)" /* 1 */;
 eval parameter Modelica.Blocks.Types.Init coo.senTDisRet.initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)" /* Modelica.Blocks.Types.Init.InitialState */;
 parameter Modelica.SIunits.MassFlowRate coo.senTDisRet.m_flow_nominal(min = 0) = coo.m1_flow_nominal "Nominal mass flow rate, used for regularization near zero flow";
 parameter Modelica.SIunits.MassFlowRate coo.senTDisRet.m_flow_small(min = 0) = 1.0E-4 * coo.senTDisRet.m_flow_nominal "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
 eval parameter Boolean coo.senTDisRet.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.senTDisRet.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.senTDisRet.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.senTDisRet.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.senTDisRet.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.senTDisRet.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.senTDisRet.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.senTDisRet.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.senTDisRet.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.senTDisRet.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.senTDisRet.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Real coo.int.k(unit = "1") = 1 "Integrator gain" /* 1 */;
 eval parameter Modelica.Blocks.Types.Init coo.int.initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (1: no init, 2: steady state, 3,4: initial output)" /* Modelica.Blocks.Types.Init.InitialState */;
 parameter Real coo.int.y_start = 0 "Initial or guess value of output (= state)" /* 0 */;
 Modelica.Blocks.Interfaces.RealInput coo.int.u "Connector of Real input signal";
 Modelica.Blocks.Interfaces.RealOutput coo.int.y(start = coo.int.y_start) "Connector of Real output signal";
 Modelica.Blocks.Interfaces.RealOutput coo.senMasFlo.m_flow(quantity = "MassFlowRate",final unit = "kg/s") "Mass flow rate from port_a to port_b";
 final parameter Modelica.SIunits.MassFlowRate coo.senMasFlo.m_flow_nominal = 0 "Nominal mass flow rate, used for regularization near zero flow" /* 0 */;
 final parameter Modelica.SIunits.MassFlowRate coo.senMasFlo.m_flow_small = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)" /* 0 */;
 eval parameter Boolean coo.senMasFlo.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.senMasFlo.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.senMasFlo.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.senMasFlo.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.senMasFlo.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.senMasFlo.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.senMasFlo.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.senMasFlo.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.senMasFlo.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.senMasFlo.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.senMasFlo.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput coo.TBuiSup.T(final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC",min = 0,start = coo.TBuiSup.T_start) "Temperature of the passing fluid";
 parameter Modelica.SIunits.ThermodynamicTemperature coo.TBuiSup.T_start = 293.15 "Initial or guess value of output (= state)" /* 293.15 */;
 eval parameter Boolean coo.TBuiSup.transferHeat = false "if true, temperature T converges towards TAmb when no flow" /* false */;
 parameter Modelica.SIunits.ThermodynamicTemperature coo.TBuiSup.TAmb = 293.15 "Fixed ambient temperature for heat transfer" /* 293.15 */;
 parameter Modelica.SIunits.Time coo.TBuiSup.tauHeaTra(min = 1) = 1200 "Time constant for heat transfer, default 20 minutes" /* 1200 */;
 structural parameter Modelica.SIunits.Time coo.TBuiSup.tau = 1 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)" /* 1 */;
 eval parameter Modelica.Blocks.Types.Init coo.TBuiSup.initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)" /* Modelica.Blocks.Types.Init.InitialState */;
 structural parameter Modelica.SIunits.MassFlowRate coo.TBuiSup.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate, used for regularization near zero flow" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.MassFlowRate coo.TBuiSup.m_flow_small = 7.024856596558318E-4 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)" /* 7.024856596558318E-4 */;
 eval parameter Boolean coo.TBuiSup.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.TBuiSup.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.TBuiSup.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.TBuiSup.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.TBuiSup.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.TBuiSup.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.TBuiSup.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.TBuiSup.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.TBuiSup.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.TBuiSup.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.TBuiSup.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Real coo.val.alp = 2 "Parameter for valve characteristics, alp>0" /* 2 */;
 parameter Real coo.val.delta0 = 0.01 "Range of significant deviation from power law" /* 0.01 */;
 structural parameter Modelica.SIunits.Pressure coo.val.dpFixed_nominal = 0 "Pressure drop of pipe and other resistances that are in series" /* 0 */;
 parameter Real coo.val.l(min = 1.0E-10,max = 1) = 0.05 "Valve leakage, l=Kv(y=0)/Kv(y=1)" /* 0.05 */;
 Real coo.val.phi = max(0, coo.val.l + Modelica.Fluid.Utilities.regPow(coo.val.y_actual, coo.val.alpInv, coo.val.delta0) * (1 - coo.val.l)) "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1)";
 parameter Real coo.val.kFixed(unit = "",min = 0) = if 0.0 > 1.0E-15 then coo.val.m_flow_nominal / sqrt(0.0) else 0 "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
 Real coo.val.kVal(unit = "",min = 1.0E-60) "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
 Real coo.val.k(unit = "",min = 1.0E-60) "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
 constant Boolean coo.val.homotopyInitialization = true "= true, use homotopy method";
 eval parameter Boolean coo.val.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 parameter Modelica.SIunits.Pressure coo.val.dp_nominal(displayUnit = "Pa") = coo.val.dpValve_nominal "Pressure drop at nominal mass flow rate";
 eval parameter Boolean coo.val.linearized = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 parameter Modelica.SIunits.MassFlowRate coo.val.m_flow_turbulent(min = 0) = coo.val.deltaM * abs(coo.val.m_flow_nominal) "Turbulent flow if |m_flow| >= m_flow_turbulent";
 parameter Modelica.SIunits.MassFlowRate coo.val.m_flow_nominal = coo.m1_flow_nominal "Nominal mass flow rate";
 parameter Modelica.SIunits.MassFlowRate coo.val.m_flow_small(min = 0) = 1.0E-4 * abs(coo.val.m_flow_nominal) "Small mass flow rate for regularization of zero flow";
 structural parameter Boolean coo.val.show_T = true "= true, if actual temperature at port is computed" /* true */;
 Modelica.SIunits.MassFlowRate coo.val.m_flow(nominal = if coo.val.m_flow_nominal_pos > 1.0E-15 then coo.val.m_flow_nominal_pos else 1,start = 0.0) = coo.val.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure coo.val.dp(nominal = 6000,start = 0.0,displayUnit = "Pa") = coo.val.port_a.p - coo.val.port_b.p "Pressure difference between port_a and port_b";
 Buildings.Media.Water.ThermodynamicState coo.val.sta_a(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(coo.val.port_a.p, noEvent(actualStream(coo.val.port_a.h_outflow)), noEvent(actualStream(coo.val.port_a.Xi_outflow[1:0]))) "Medium properties in port_a";
 Buildings.Media.Water.ThermodynamicState coo.val.sta_b(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(coo.val.port_b.p, noEvent(actualStream(coo.val.port_b.h_outflow)), noEvent(actualStream(coo.val.port_b.Xi_outflow[1:0]))) "Medium properties in port_b";
 eval parameter Boolean coo.val.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate coo.val.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.val.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.val.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.val.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.val.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.val.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.val.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.val.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.val.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.val.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 structural parameter Buildings.Fluid.Types.CvTypes coo.val.CvData = Buildings.Fluid.Types.CvTypes.OpPoint "Selection of flow coefficient" /* Buildings.Fluid.Types.CvTypes.OpPoint */;
 initial parameter Real coo.val.Kv(fixed = if Buildings.Fluid.Types.CvTypes.OpPoint == Buildings.Fluid.Types.CvTypes.Kv then true else false) "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)]";
 initial parameter Real coo.val.Cv(fixed = if Buildings.Fluid.Types.CvTypes.OpPoint == Buildings.Fluid.Types.CvTypes.Cv then true else false) "Cv (US) flow coefficient [USG/min/(psi)^(1/2)]";
 initial parameter Modelica.SIunits.Area coo.val.Av(fixed = if Buildings.Fluid.Types.CvTypes.OpPoint == Buildings.Fluid.Types.CvTypes.Av then true else false) "Av (metric) flow coefficient";
 parameter Real coo.val.deltaM = 0.02 "Fraction of nominal flow rate where linearization starts, if y=1" /* 0.02 */;
 parameter Modelica.SIunits.Pressure coo.val.dpValve_nominal(displayUnit = "Pa",min = 0,fixed = if Buildings.Fluid.Types.CvTypes.OpPoint == Buildings.Fluid.Types.CvTypes.OpPoint then true else false) = coo.dpValve_nominal "Nominal pressure drop of fully open valve, used if CvData=Buildings.Fluid.Types.CvTypes.OpPoint";
 parameter Modelica.SIunits.Density coo.val.rhoStd = Buildings.Media.Water.density_pTX(101325, 273.15 + 4, {1.0}) "Inlet density for which valve coefficients are defined" /* 995.586 */;
 structural parameter Boolean coo.val.use_inputFilter = false "= true, if opening is filtered with a 2nd order CriticalDamping filter" /* false */;
 parameter Modelica.SIunits.Time coo.val.riseTime(displayUnit = "s") = 60 "Rise time of the filter (time to reach 99.6 % of an opening step)" /* 60 */;
 parameter Integer coo.val.order(min = 1) = 2 "Order of filter" /* 2 */;
 parameter Modelica.Blocks.Types.Init coo.val.init = Modelica.Blocks.Types.Init.InitialOutput "Type of initialization (no init/steady state/initial state/initial output)" /* Modelica.Blocks.Types.Init.InitialOutput */;
 parameter Real coo.val.y_start = 0 "Initial value of output" /* 0 */;
 Modelica.Blocks.Interfaces.RealInput coo.val.y(min = 0,max = 1) "Actuator position (0: closed, 1: open)";
 Modelica.Blocks.Interfaces.RealOutput coo.val.y_actual "Actual valve position";
 parameter Real coo.cp.k(start = 1,unit = "1") = coo.cp_default "Gain value multiplied with input signal";
 Modelica.Blocks.Interfaces.RealInput coo.cp.u "Input signal connector";
 Modelica.Blocks.Interfaces.RealOutput coo.cp.y "Output signal connector";
 Modelica.Blocks.Interfaces.RealInput coo.pro.u1 "Connector of Real input signal 1";
 Modelica.Blocks.Interfaces.RealInput coo.pro.u2 "Connector of Real input signal 2";
 Modelica.Blocks.Interfaces.RealOutput coo.pro.y "Connector of Real output signal";
 parameter Real coo.dTDis.k1 = -1 "Gain of upper input" /* -1 */;
 parameter Real coo.dTDis.k2 = 1 "Gain of lower input" /* 1 */;
 Modelica.Blocks.Interfaces.RealInput coo.dTDis.u1 "Connector of Real input signal 1";
 Modelica.Blocks.Interfaces.RealInput coo.dTDis.u2 "Connector of Real input signal 2";
 Modelica.Blocks.Interfaces.RealOutput coo.dTDis.y "Connector of Real output signal";
 Modelica.Blocks.Interfaces.RealOutput coo.TBuiRet.T(final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC",min = 0,start = coo.TBuiRet.T_start) "Temperature of the passing fluid";
 parameter Modelica.SIunits.ThermodynamicTemperature coo.TBuiRet.T_start = 293.15 "Initial or guess value of output (= state)" /* 293.15 */;
 eval parameter Boolean coo.TBuiRet.transferHeat = false "if true, temperature T converges towards TAmb when no flow" /* false */;
 parameter Modelica.SIunits.ThermodynamicTemperature coo.TBuiRet.TAmb = 293.15 "Fixed ambient temperature for heat transfer" /* 293.15 */;
 parameter Modelica.SIunits.Time coo.TBuiRet.tauHeaTra(min = 1) = 1200 "Time constant for heat transfer, default 20 minutes" /* 1200 */;
 structural parameter Modelica.SIunits.Time coo.TBuiRet.tau = 1 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)" /* 1 */;
 eval parameter Modelica.Blocks.Types.Init coo.TBuiRet.initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)" /* Modelica.Blocks.Types.Init.InitialState */;
 structural parameter Modelica.SIunits.MassFlowRate coo.TBuiRet.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate, used for regularization near zero flow" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.MassFlowRate coo.TBuiRet.m_flow_small = 7.024856596558318E-4 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)" /* 7.024856596558318E-4 */;
 eval parameter Boolean coo.TBuiRet.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.TBuiRet.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.TBuiRet.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.TBuiRet.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.TBuiRet.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.TBuiRet.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.TBuiRet.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.TBuiRet.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.TBuiRet.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.TBuiRet.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.TBuiRet.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean coo.allowFlowReversal1 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1" /* true */;
 eval parameter Boolean coo.allowFlowReversal2 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2" /* true */;
 Buildings.Media.Water.MassFlowRate coo.port_a1.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.port_a1.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.port_a1.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.port_a1.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.port_a1.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.port_b1.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.port_b1.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.port_b1.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.port_b1.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.port_b1.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.port_a2.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.port_a2.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.port_a2.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.port_a2.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.port_a2.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.port_b2.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.port_b2.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.port_b2.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.port_b2.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.port_b2.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Boolean bui.show_T = false "propagated parameter show_T" /* false */;
 structural (loadResource) parameter String bui.filNam = "modelica://Buildings/Applications/DHC/Loads/Examples/Resources/SwissResidential_20190916.mos" "Library path of the file with thermal loads as time series" /* "modelica://Buildings/Applications/DHC/Loads/Examples/Resources/SwissResidential_20190916.mos" */;
 structural parameter Modelica.SIunits.ThermodynamicTemperature bui.T_aHeaWat_nominal = 313.15 "Heating water inlet temperature at nominal conditions" /* 313.15 */;
 structural parameter Modelica.SIunits.ThermodynamicTemperature bui.T_bHeaWat_nominal = 308.15 "Heating water outlet temperature at nominal conditions" /* 308.15 */;
 structural parameter Modelica.SIunits.ThermodynamicTemperature bui.T_aChiWat_nominal = 287.15 "Chilled water inlet temperature at nominal conditions " /* 287.15 */;
 structural parameter Modelica.SIunits.ThermodynamicTemperature bui.T_bChiWat_nominal = 292.15 "Chilled water outlet temperature at nominal conditions" /* 292.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.T_aLoaHea_nominal(min = 273.15,displayUnit = "degC") = 273.15 + 20 "Load side inlet temperature at nominal conditions in heating mode" /* 293.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.T_aLoaCoo_nominal(min = 273.15,displayUnit = "degC") = 273.15 + 24 "Load side inlet temperature at nominal conditions in cooling mode" /* 297.15 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.mLoaHea_flow_nominal = 16.528673093224516 "Load side mass flow rate at nominal conditions in heating mode" /* 16.528673093224516 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.mLoaCoo_flow_nominal = 14.485382537898948 "Load side mass flow rate at nominal conditions in cooling mode" /* 14.485382537898948 */;
 parameter Modelica.SIunits.TemperatureDifference bui.delTBuiCoo = 292.15 - 287.15 "Nominal building supply and return chilled water temperature difference" annotation(absoluteValue = false) /* 5.0 */;
 structural parameter Modelica.SIunits.HeatFlowRate bui.QCoo_flow_nominal = -146960.0 "Design cooling heat flow rate (<=0)" /* -146960.0 */;
 structural parameter Modelica.SIunits.HeatFlowRate bui.QHea_flow_nominal = 167690.0 "Design heating heat flow rate (>=0)" /* 167690.0 */;
 structural parameter Modelica.SIunits.SpecificHeatCapacity bui.cp_air = 1014.54 "Specific heat capacity of air at default state" /* 1014.54 */;
 structural parameter Boolean bui.loa.tableOnFile = true "= true, if table is defined on file or in function usertab" /* true */;
 parameter Real bui.loa.table[0,2] = fill(0.0, 0, 2) "Table matrix (time = first column; e.g., table=[0,2])" /* (zero-size array) */;
 parameter String bui.loa.tableName = "tab1" "Table name on file or in function usertab (see docu)" /* "tab1" */;
 parameter String bui.loa.fileName = loadResource("/mnt/home/helarga/modelica-buildings/Buildings/Applications/DHC/Loads/Examples/Resources/SwissResidential_20190916.mos") "File where matrix is stored";
 parameter Boolean bui.loa.verboseRead = true "= true, if info message that file is loading is to be printed" /* true */;
 parameter Integer bui.loa.columns[3] = {2, 3, 4} "Columns of table to be interpolated" /* { 2, 3, 4 } */;
 structural parameter Modelica.Blocks.Types.Smoothness bui.loa.smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation" /* Modelica.Blocks.Types.Smoothness.LinearSegments */;
 parameter Modelica.Blocks.Types.Extrapolation bui.loa.extrapolation = Modelica.Blocks.Types.Extrapolation.LastTwoPoints "Extrapolation of data outside the definition range" /* Modelica.Blocks.Types.Extrapolation.LastTwoPoints */;
 parameter Real bui.loa.offset[1] = {0} "Offsets of output signals" /* { 0 } */;
 parameter Modelica.SIunits.Time bui.loa.startTime = 0 "Output = offset for time < startTime" /* 0 */;
 eval parameter Modelica.SIunits.Time bui.loa.timeScale = 1 "Time scale of first table column" /* 1 */;
 initial parameter Modelica.SIunits.Time bui.loa.t_min(fixed = false) "Minimum abscissa value defined in table";
 initial parameter Modelica.SIunits.Time bui.loa.t_max(fixed = false) "Maximum abscissa value defined in table";
 initial parameter Real bui.loa.t_minScaled(fixed = false) "Minimum (scaled) abscissa value defined in table";
 initial parameter Real bui.loa.t_maxScaled(fixed = false) "Maximum (scaled) abscissa value defined in table";
 structural parameter Integer bui.loa.nout = 3 "Number of outputs" /* 3 */;
 Modelica.Blocks.Interfaces.RealOutput bui.loa.y[3](each unit = "W") "Connector of Real output signals";
 structural parameter Buildings.Fluid.Types.HeatExchangerConfiguration bui.terUniHea.hexConHea = Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow "Heating heat exchanger configuration" /* Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow */;
 final parameter Buildings.Fluid.Types.HeatExchangerConfiguration bui.terUniHea.hexConCoo = Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow "Cooling heat exchanger configuration" /* Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow */;
 parameter Boolean bui.terUniHea.have_speVar = true "Set to true for a variable speed fan (otherwise fan is always on)" /* true */;
 structural parameter Modelica.SIunits.Pressure bui.terUniHea.fan.dp_nominal = 200 "Nominal pressure raise, used for default pressure curve if not specified in record per" /* 200 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.fan.m_flow_start(min = 0) = 0 "Initial value of mass flow rate" /* 0 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.fan.constantMassFlowRate = 16.528673093224516 "Constant pump mass flow rate, used when inputType=Constant" /* 16.528673093224516 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.fan.massFlowRates[1] = 16.528673093224516 * {bui.terUniHea.fan.per.speeds[1] / bui.terUniHea.fan.per.speeds[1]} "Vector of mass flow rate set points, used when inputType=Stage";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.m_flow_in(final unit = "kg/s",nominal = 16.528673093224516) "Prescribed mass flow rate";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.m_flow_actual(final unit = "kg/s",nominal = 16.528673093224516) "Actual mass flow rate";
 parameter Buildings.Fluid.Movers.Data.Generic bui.terUniHea.fan.per(pressure(V_flow(size() = {2}),dp(size() = {2})) = Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters({0, 0}, {0, 0}),use_powerCharacteristic = false,hydraulicEfficiency(V_flow(size() = {1},each min = 0) = {0},eta(size() = {1},each max = 1) = {0.7}),motorEfficiency(V_flow(size() = {1},each min = 0) = {0},eta(size() = {1},each max = 1) = {0.7}),power(V_flow(size() = {1},each min = 0) = {0},P(size() = {1},each min = 0) = {0}),motorCooledByFluid = true,speed_nominal(final min = 0,final unit = "1") = 1,constantSpeed(final min = 0,final unit = "1") = bui.terUniHea.fan.per.constantSpeed_rpm / bui.terUniHea.fan.per.speed_rpm_nominal,speeds(size() = {1},each final min = 0,each final unit = "1") = bui.terUniHea.fan.per.speeds_rpm[1:1] / bui.terUniHea.fan.per.speed_rpm_nominal,speed_rpm_nominal = 1500,constantSpeed_rpm = bui.terUniHea.fan.per.speed_rpm_nominal,speeds_rpm(size() = {1}) = {bui.terUniHea.fan.per.speed_rpm_nominal},havePressureCurve = false);
 structural parameter Buildings.Fluid.Types.InputType bui.terUniHea.fan.inputType = Buildings.Fluid.Types.InputType.Continuous "Control input type" /* Buildings.Fluid.Types.InputType.Continuous */;
 parameter Real bui.terUniHea.fan.constInput(final unit = "kg/s") = bui.terUniHea.fan.constantMassFlowRate "Constant input set point";
 parameter Real bui.terUniHea.fan.stageInputs[1](each final unit = "kg/s") = bui.terUniHea.fan.massFlowRates[1:1] "Vector of input set points corresponding to stages";
 structural parameter Boolean bui.terUniHea.fan.computePowerUsingSimilarityLaws = false "= true, compute power exactly, using similarity laws. Otherwise approximate." /* false */;
 structural parameter Boolean bui.terUniHea.fan.addPowerToMedium = true "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations)" /* true */;
 parameter Boolean bui.terUniHea.fan.nominalValuesDefineDefaultPressureCurve = true "Set to true to avoid warning if m_flow_nominal and dp_nominal are used to construct the default pressure curve" /* true */;
 parameter Modelica.SIunits.Time bui.terUniHea.fan.tau = 1 "Time constant of fluid volume for nominal flow, used if energy or mass balance is dynamic" /* 1 */;
 structural parameter Boolean bui.terUniHea.fan.use_inputFilter = true "= true, if speed is filtered with a 2nd order CriticalDamping filter" /* true */;
 parameter Modelica.SIunits.Time bui.terUniHea.fan.riseTime = 30 "Rise time of the filter (time to reach 99.6 % of the speed)" /* 30 */;
 structural parameter Modelica.Blocks.Types.Init bui.terUniHea.fan.init = Modelica.Blocks.Types.Init.InitialOutput "Type of initialization (no init/steady state/initial state/initial output)" /* Modelica.Blocks.Types.Init.InitialOutput */;
 parameter Real bui.terUniHea.fan.y_start(min = 0,max = 1,unit = "1") = 0 "Initial value of speed" /* 0 */;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.y_actual(final unit = "1") "Actual normalised pump speed that is used for computations";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.P(quantity = "Power",final unit = "W") "Electrical power consumed";
 Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.fan.heatPort.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.fan.heatPort.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.SIunits.VolumeFlowRate bui.terUniHea.fan.VMachine_flow(start = 0.0) = bui.terUniHea.fan.eff.V_flow "Volume flow rate";
 Modelica.SIunits.Pressure bui.terUniHea.fan.dpMachine(displayUnit = "Pa") = - bui.terUniHea.fan.preSou.dp "Pressure difference";
 Real bui.terUniHea.fan.eta(unit = "1",final quantity = "Efficiency") = bui.terUniHea.fan.eff.eta "Global efficiency";
 Real bui.terUniHea.fan.etaHyd(unit = "1",final quantity = "Efficiency") = bui.terUniHea.fan.eff.etaHyd "Hydraulic efficiency";
 Real bui.terUniHea.fan.etaMot(unit = "1",final quantity = "Efficiency") = bui.terUniHea.fan.eff.etaMot "Motor efficiency";
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.p_start(start = 101325.0) = 101325.0 "Start value of pressure" /* 101325.0 */;
 parameter Buildings.Media.Air.Temperature bui.terUniHea.fan.T_start(start = 293.15) = 293.15 "Start value of temperature" /* 293.15 */;
 parameter Buildings.Media.Air.MassFraction bui.terUniHea.fan.X_start[2](quantity = {"water", "air"}) = {0.01, 0.99} "Start value of mass fractions m_i/m" /* { 0.01, 0.99 } */;
 parameter Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.C_start[0](quantity = fill("", 0)) = fill(0, 0) "Start value of trace substances" /* (zero-size array) */;
 parameter Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.C_nominal[0](quantity = fill("", 0)) = fill(0.01, 0) "Nominal value of trace substances. (Set to typical order of magnitude.)" /* (zero-size array) */;
 final parameter Real bui.terUniHea.fan.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.fan.m_flow_nominal = 16.528673093224516 "Nominal mass flow rate" /* 16.528673093224516 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.fan.m_flow_small = 0.0016528673093224517 "Small mass flow rate for regularization of zero flow" /* 0.0016528673093224517 */;
 structural parameter Boolean bui.terUniHea.fan.show_T = true "= true, if actual temperature at port is computed" /* true */;
 Modelica.SIunits.MassFlowRate bui.terUniHea.fan.m_flow(start = 0.0) = bui.terUniHea.fan.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniHea.fan.dp(start = 0.0,displayUnit = "Pa") = bui.terUniHea.fan.port_a.p - bui.terUniHea.fan.port_b.p "Pressure difference between port_a and port_b";
 Buildings.Media.Air.ThermodynamicState bui.terUniHea.fan.sta_a(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_phX(bui.terUniHea.fan.port_a.p, noEvent(actualStream(bui.terUniHea.fan.port_a.h_outflow)), noEvent(actualStream(bui.terUniHea.fan.port_a.Xi_outflow[1:1]))) "Medium properties in port_a";
 Buildings.Media.Air.ThermodynamicState bui.terUniHea.fan.sta_b(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_phX(bui.terUniHea.fan.port_b.p, noEvent(actualStream(bui.terUniHea.fan.port_b.h_outflow)), noEvent(actualStream(bui.terUniHea.fan.port_b.Xi_outflow[1:1]))) "Medium properties in port_b";
 eval parameter Boolean bui.terUniHea.fan.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.port_a.h_outflow(start = bui.terUniHea.fan.h_outflow_start,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.port_b.p(start = bui.terUniHea.fan.p_start) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.port_b.h_outflow(start = bui.terUniHea.fan.h_outflow_start,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 structural parameter Buildings.Controls.OBC.CDL.Types.SimpleController bui.terUniHea.con.controllerType = Buildings.Controls.OBC.CDL.Types.SimpleController.PI "Type of controller" /* Buildings.Controls.OBC.CDL.Types.SimpleController.PI */;
 parameter Real bui.terUniHea.con.k(min = 0) = 1 "Gain of controller" /* 1 */;
 parameter Modelica.SIunits.Time bui.terUniHea.con.Ti(min = 1.0E-60) = 10 "Time constant of integrator block" /* 10 */;
 parameter Modelica.SIunits.Time bui.terUniHea.con.Td(min = 0) = 0.1 "Time constant of derivative block" /* 0.1 */;
 parameter Real bui.terUniHea.con.yMax = 1 "Upper limit of output" /* 1 */;
 parameter Real bui.terUniHea.con.yMin = 0 "Lower limit of output" /* 0 */;
 parameter Real bui.terUniHea.con.wp(min = 0) = 1 "Set-point weight for Proportional block (0..1)" /* 1 */;
 parameter Real bui.terUniHea.con.wd(min = 0) = 0 "Set-point weight for Derivative block (0..1)" /* 0 */;
 parameter Real bui.terUniHea.con.Ni(min = 100 * 1.0E-15) = 0.9 "Ni*Ti is time constant of anti-windup compensation" /* 0.9 */;
 parameter Real bui.terUniHea.con.Nd(min = 100 * 1.0E-15) = 10 "The higher Nd, the more ideal the derivative block" /* 10 */;
 parameter Real bui.terUniHea.con.xi_start = 0 "Initial value of integrator state" /* 0 */;
 parameter Real bui.terUniHea.con.yd_start = 0 "Initial value of derivative output" /* 0 */;
 parameter Boolean bui.terUniHea.con.reverseAction = false "Set to true for throttling the water flow rate through a cooling coil controller" /* false */;
 eval parameter Buildings.Controls.OBC.CDL.Types.Reset bui.terUniHea.con.reset = Buildings.Controls.OBC.CDL.Types.Reset.Disabled "Type of controller output reset" /* Buildings.Controls.OBC.CDL.Types.Reset.Disabled */;
 parameter Real bui.terUniHea.con.y_reset = bui.terUniHea.con.xi_start "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == CDL.Types.Reset.Parameter";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.u_s "Connector of setpoint input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.u_m "Connector of measurement input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.y "Connector of actuator output signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.controlError.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.controlError.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.controlError.y "Connector of Real output signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.I.u "Connector of Real input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.I.y "Connector of Real output signal";
 parameter Real bui.terUniHea.con.I.k(unit = "1") = 1 / bui.terUniHea.con.Ti "Integrator gain";
 parameter Real bui.terUniHea.con.I.y_start = bui.terUniHea.con.xi_start "Initial or guess value of output (= state)";
 eval parameter Buildings.Controls.OBC.CDL.Types.Reset bui.terUniHea.con.I.reset = Buildings.Controls.OBC.CDL.Types.Reset.Disabled "Type of integrator reset" /* Buildings.Controls.OBC.CDL.Types.Reset.Disabled */;
 parameter Real bui.terUniHea.con.I.y_reset = bui.terUniHea.con.y_reset "Value to which integrator is reset, used if reset = Types.Reset.Parameter";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.errP.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.errP.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.errP.y "Connector of Real output signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.errI1.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.errI1.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.errI1.y "Connector of Real output signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.errI2.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.errI2.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.errI2.y "Connector of Real output signal";
 parameter Real bui.terUniHea.con.lim.uMax = bui.terUniHea.con.yMax "Upper limit of input signal";
 parameter Real bui.terUniHea.con.lim.uMin = bui.terUniHea.con.yMin "Lower limit of input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.lim.u "Connector of Real input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.lim.y "Connector of Real output signal";
 parameter Real bui.terUniHea.hex.r_nominal(min = 0,max = 1) = 2 / 3 "Ratio between air-side and water-side convective heat transfer (hA-value) at nominal condition" /* 0.6666666666666666 */;
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniHea.hex.hA.UA_nominal(min = 0) = bui.terUniHea.hex.UA_nominal "Thermal conductance at nominal flow";
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.hA.m_flow_nominal_w = bui.terUniHea.hex.m1_flow_nominal "Water mass flow rate";
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.hA.m_flow_nominal_a = 16.528673093224516 "Air mass flow rate" /* 16.528673093224516 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.hex.hA.m1_flow(final unit = "kg/s") "Mass flow rate medium 1";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.hex.hA.m2_flow(final unit = "kg/s") "Mass flow rate medium 2";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.hex.hA.T_1(final unit = "K") "Temperature medium 1";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.hex.hA.T_2(final unit = "K") "Temperature medium 2";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.hA.hA_1(final unit = "W/K") "Convective heat transfer medium 1";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.hA.hA_2(final unit = "W/K") "Convective heat transfer medium 2";
 parameter Real bui.terUniHea.hex.hA.r_nominal(min = 0) = bui.terUniHea.hex.r_nominal "Ratio between air-side and water-side convective heat transfer coefficient";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniHea.hex.hA.hA_nominal_w(min = 0) = bui.terUniHea.hex.hA.UA_nominal * (bui.terUniHea.hex.hA.r_nominal + 1) / bui.terUniHea.hex.hA.r_nominal "Water side convective heat transfer coefficient";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniHea.hex.hA.hA_nominal_a(min = 0) = bui.terUniHea.hex.hA.r_nominal * bui.terUniHea.hex.hA.hA_nominal_w "Air side convective heat transfer coefficient, including fin resistance";
 parameter Real bui.terUniHea.hex.hA.n_w(min = 0,max = 1) = 0.85 "Water-side exponent for convective heat transfer coefficient, h~m_flow^n" /* 0.85 */;
 parameter Real bui.terUniHea.hex.hA.n_a(min = 0,max = 1) = 0.8 "Air-side exponent for convective heat transfer coefficient, h~m_flow^n" /* 0.8 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.hex.hA.T0_w = Modelica.SIunits.Conversions.from_degC(20) "Water temperature" /* 293.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.hex.hA.T0_a = Modelica.SIunits.Conversions.from_degC(20) "Air temperature" /* 293.15 */;
 eval parameter Boolean bui.terUniHea.hex.hA.waterSideFlowDependent = true "Set to false to make water-side hA independent of mass flow rate" /* true */;
 eval parameter Boolean bui.terUniHea.hex.hA.airSideFlowDependent = true "Set to false to make air-side hA independent of mass flow rate" /* true */;
 eval parameter Boolean bui.terUniHea.hex.hA.waterSideTemperatureDependent = false "Set to false to make water-side hA independent of temperature" /* false */;
 eval parameter Boolean bui.terUniHea.hex.hA.airSideTemperatureDependent = false "Set to false to make air-side hA independent of temperature" /* false */;
 eval parameter Buildings.Fluid.Types.HeatExchangerConfiguration bui.terUniHea.hex.configuration = Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow "Heat exchanger configuration" /* Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow */;
 eval parameter Boolean bui.terUniHea.hex.use_Q_flow_nominal = true "Set to true to specify Q_flow_nominal and temperatures, or to false to specify effectiveness" /* true */;
 structural parameter Modelica.SIunits.HeatFlowRate bui.terUniHea.hex.Q_flow_nominal = 167690.0 "Nominal heat transfer" /* 167690.0 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.hex.T_a1_nominal(fixed = true) = 313.15 "Nominal temperature at port a1" /* 313.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.hex.T_a2_nominal(fixed = true) = bui.terUniHea.T_aLoaHea_nominal "Nominal temperature at port a2";
 initial parameter Real bui.terUniHea.hex.eps_nominal(fixed = not true) "Nominal heat transfer effectiveness";
 Modelica.SIunits.ThermalConductance bui.terUniHea.hex.UA = 1 / (1 / bui.terUniHea.hex.hA.hA_1 + 1 / bui.terUniHea.hex.hA.hA_2) "UA value";
 Real bui.terUniHea.hex.eps(min = 0,max = 1) "Heat exchanger effectiveness";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniHea.hex.UA_nominal(fixed = false) "Nominal UA value";
 initial parameter Real bui.terUniHea.hex.NTU_nominal(min = 0,fixed = false) "Nominal number of transfer units";
 Buildings.Media.Water.Temperature bui.terUniHea.hex.T_in1(start = 293.15) = Buildings.Media.Water.temperature(bui.terUniHea.hex.state_a1_inflow) "Inlet temperature medium 1";
 Buildings.Media.Air.Temperature bui.terUniHea.hex.T_in2(start = 293.15) = bui.terUniHea.hex.fra_a2 * Buildings.Media.Air.temperature(bui.terUniHea.hex.state_a2_inflow) + bui.terUniHea.hex.fra_b2 * Buildings.Media.Air.temperature(bui.terUniHea.hex.state_b2_inflow) "Inlet temperature medium 2";
 Modelica.SIunits.ThermalConductance bui.terUniHea.hex.C1_flow = abs(bui.terUniHea.hex.m1_flow) * Buildings.Media.Water.specificHeatCapacityCp(bui.terUniHea.hex.state_a1_inflow) "Heat capacity flow rate medium 1";
 Modelica.SIunits.ThermalConductance bui.terUniHea.hex.C2_flow = abs(bui.terUniHea.hex.m2_flow) * (bui.terUniHea.hex.fra_a2 * Buildings.Media.Air.specificHeatCapacityCp(bui.terUniHea.hex.state_a2_inflow) + bui.terUniHea.hex.fra_b2 * Buildings.Media.Air.specificHeatCapacityCp(bui.terUniHea.hex.state_b2_inflow)) "Heat capacity flow rate medium 2";
 Modelica.SIunits.ThermalConductance bui.terUniHea.hex.CMin_flow(min = 0) = min(bui.terUniHea.hex.C1_flow, bui.terUniHea.hex.C2_flow) "Minimum heat capacity flow rate";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.hex.QMax_flow = bui.terUniHea.hex.CMin_flow * (bui.terUniHea.hex.T_in2 - bui.terUniHea.hex.T_in1) "Maximum heat flow rate into medium 1";
 constant Boolean bui.terUniHea.hex.prescribedHeatFlowRate1 = true "Set to true if the heat flow rate into fluid 1 is not a function of the component temperature";
 constant Boolean bui.terUniHea.hex.prescribedHeatFlowRate2 = true "Set to true if the heat flow rate into fluid 2 is not a function of the component temperature";
 constant Boolean bui.terUniHea.hex.homotopyInitialization = true "= true, use homotopy method";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.hex.Q1_flow = bui.terUniHea.hex.eps * bui.terUniHea.hex.QMax_flow "Heat transferred into the medium 1";
 Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.mWat1_flow = 0 "Moisture mass flow rate added to the medium 1";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.hex.Q2_flow = - bui.terUniHea.hex.Q1_flow "Heat transferred into the medium 2";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.mWat2_flow = 0 "Moisture mass flow rate added to the medium 2";
 constant Boolean bui.terUniHea.hex.sensibleOnly1 = true "Set to true if sensible exchange only for medium 1";
 constant Boolean bui.terUniHea.hex.sensibleOnly2 = true "Set to true if sensible exchange only for medium 2";
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.m1_flow_nominal(min = 0) = 8.015774378585085 "Nominal mass flow rate" /* 8.015774378585085 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.m2_flow_nominal = 16.528673093224516 "Nominal mass flow rate" /* 16.528673093224516 */;
 parameter Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.m1_flow_small(min = 0) = 1.0E-4 * abs(bui.terUniHea.hex.m1_flow_nominal) "Small mass flow rate for regularization of zero flow";
 structural parameter Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.m2_flow_small = 0.0016528673093224517 "Small mass flow rate for regularization of zero flow" /* 0.0016528673093224517 */;
 structural parameter Boolean bui.terUniHea.hex.show_T = true "= true, if actual temperature at port is computed" /* true */;
 Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.m1_flow = bui.terUniHea.hex.port_a1.m_flow "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniHea.hex.dp1(displayUnit = "Pa") = bui.terUniHea.hex.port_a1.p - bui.terUniHea.hex.port_b1.p "Pressure difference between port_a1 and port_b1";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.m2_flow = bui.terUniHea.hex.port_a2.m_flow "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniHea.hex.dp2(displayUnit = "Pa") = bui.terUniHea.hex.port_a2.p - bui.terUniHea.hex.port_b2.p "Pressure difference between port_a2 and port_b2";
 Buildings.Media.Water.ThermodynamicState bui.terUniHea.hex.sta_a1(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(bui.terUniHea.hex.port_a1.p, noEvent(actualStream(bui.terUniHea.hex.port_a1.h_outflow)), noEvent(actualStream(bui.terUniHea.hex.port_a1.Xi_outflow[1:0]))) "Medium properties in port_a1";
 Buildings.Media.Water.ThermodynamicState bui.terUniHea.hex.sta_b1(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(bui.terUniHea.hex.port_b1.p, noEvent(actualStream(bui.terUniHea.hex.port_b1.h_outflow)), noEvent(actualStream(bui.terUniHea.hex.port_b1.Xi_outflow[1:0]))) "Medium properties in port_b1";
 Buildings.Media.Air.ThermodynamicState bui.terUniHea.hex.sta_a2(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_phX(bui.terUniHea.hex.port_a2.p, noEvent(actualStream(bui.terUniHea.hex.port_a2.h_outflow)), noEvent(actualStream(bui.terUniHea.hex.port_a2.Xi_outflow[1:1]))) "Medium properties in port_a2";
 Buildings.Media.Air.ThermodynamicState bui.terUniHea.hex.sta_b2(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_phX(bui.terUniHea.hex.port_b2.p, noEvent(actualStream(bui.terUniHea.hex.port_b2.h_outflow)), noEvent(actualStream(bui.terUniHea.hex.port_b2.Xi_outflow[1:1]))) "Medium properties in port_b2";
 eval parameter Boolean bui.terUniHea.hex.allowFlowReversal1 = false "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1" /* false */;
 eval parameter Boolean bui.terUniHea.hex.allowFlowReversal2 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2" /* true */;
 Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.port_a1.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.hex.port_a1.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.hex.port_a1.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.hex.port_a1.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.hex.port_a1.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.port_b1.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.hex.port_b1.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.hex.port_b1.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.hex.port_b1.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.hex.port_b1.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.port_a2.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.hex.port_a2.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.hex.port_a2.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.hex.port_a2.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.hex.port_a2.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.port_b2.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.hex.port_b2.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.hex.port_b2.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.hex.port_b2.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.hex.port_b2.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.terUniHea.hex.computeFlowResistance1 = false "=true, compute flow resistance. Set to false to assume no friction" /* false */;
 eval parameter Boolean bui.terUniHea.hex.from_dp1 = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniHea.hex.dp1_nominal = 0 "Pressure difference" /* 0 */;
 structural parameter Boolean bui.terUniHea.hex.linearizeFlowResistance1 = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real bui.terUniHea.hex.deltaM1 = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 eval parameter Boolean bui.terUniHea.hex.computeFlowResistance2 = true "=true, compute flow resistance. Set to false to assume no friction" /* true */;
 eval parameter Boolean bui.terUniHea.hex.from_dp2 = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniHea.hex.dp2_nominal = 200 "Pressure difference" /* 200 */;
 structural parameter Boolean bui.terUniHea.hex.linearizeFlowResistance2 = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real bui.terUniHea.hex.deltaM2 = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 parameter Real bui.terUniHea.gaiMasFlo.k = 8.015774378585085 "Gain value multiplied with input signal" /* 8.015774378585085 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.gaiMasFlo.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.gaiMasFlo.y "Output signal connector";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.Q_flowHea.y = bui.terUniHea.hex.Q2_flow "Value of Real output";
 structural parameter Real bui.terUniHea.gaiFloNom2.k = 16.528673093224516 "Gain value multiplied with input signal" /* 16.528673093224516 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.gaiFloNom2.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.gaiFloNom2.y "Output signal connector";
 eval parameter Boolean bui.terUniHea.sinAir.use_p_in = false "Get the pressure from the input connector" /* false */;
 parameter Buildings.Media.Air.AbsolutePressure bui.terUniHea.sinAir.p(start = 101325.0) = 101325.0 "Fixed value of pressure" /* 101325.0 */;
 eval parameter Boolean bui.terUniHea.sinAir.use_T_in = false "Get the temperature from the input connector" /* false */;
 parameter Buildings.Media.Air.Temperature bui.terUniHea.sinAir.T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 eval parameter Boolean bui.terUniHea.sinAir.use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean bui.terUniHea.sinAir.use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean bui.terUniHea.sinAir.use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Air.MassFraction bui.terUniHea.sinAir.X[2](final quantity = {"water", "air"}) = {0.01, 0.99} "Fixed value of composition" /* { 0.01, 0.99 } */;
 parameter Buildings.Media.Air.ExtraProperty bui.terUniHea.sinAir.C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer bui.terUniHea.sinAir.nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean bui.terUniHea.sinAir.verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Air.MassFlowRate bui.terUniHea.sinAir.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.sinAir.ports[1].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.sinAir.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.sinAir.ports[1].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.sinAir.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.terUniHea.retAir.use_p_in = false "Get the pressure from the input connector" /* false */;
 parameter Buildings.Media.Air.AbsolutePressure bui.terUniHea.retAir.p(displayUnit = "Pa",start = 101325.0) = 101325.0 "Fixed value of pressure" /* 101325.0 */;
 eval parameter Boolean bui.terUniHea.retAir.use_T_in = true "Get the temperature from the input connector" /* true */;
 parameter Buildings.Media.Air.Temperature bui.terUniHea.retAir.T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.retAir.T_in(final unit = "K",displayUnit = "degC") "Prescribed boundary temperature";
 eval parameter Boolean bui.terUniHea.retAir.use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean bui.terUniHea.retAir.use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean bui.terUniHea.retAir.use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Air.MassFraction bui.terUniHea.retAir.X[2](final quantity = {"water", "air"}) = {0.01, 0.99} "Fixed value of composition" /* { 0.01, 0.99 } */;
 parameter Buildings.Media.Air.ExtraProperty bui.terUniHea.retAir.C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer bui.terUniHea.retAir.nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean bui.terUniHea.retAir.verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Air.MassFlowRate bui.terUniHea.retAir.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.retAir.ports[1].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.retAir.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.retAir.ports[1].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.retAir.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.TLoaODE.TOutHea_nominal(displayUnit = "degC") = 273.15 - 5 "Outdoor air temperature at heating nominal conditions" /* 268.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.TLoaODE.TIndHea_nominal(displayUnit = "degC") = bui.terUniHea.T_aLoaHea_nominal "Indoor air temperature at heating nominal conditions";
 structural parameter Modelica.SIunits.HeatFlowRate bui.terUniHea.TLoaODE.QHea_flow_nominal = 167690.0 "Heating heat flow rate (for TInd=TIndHea_nominal, TOut=TOutHea_nominal,
    with no internal gains, no solar radiation)" /* 167690.0 */;
 eval parameter Boolean bui.terUniHea.TLoaODE.steadyStateInitial = false "true initializes T with dT(0)/dt=0, false initializes T with T(0)=TIndHea_nominal" /* false */;
 parameter Modelica.SIunits.Time bui.terUniHea.TLoaODE.tau(displayUnit = "h") = 1800 "Time constant of the indoor temperature" /* 1800 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.TLoaODE.TSet(final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC") "Temperature set point for heating or cooling";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.TLoaODE.QReq_flow(final quantity = "HeatFlowRate",final unit = "W") "Required heat flow rate to meet temperature set point (>=0 for heating)";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.TLoaODE.QAct_flow(final quantity = "HeatFlowRate",final unit = "W") "Actual heating or cooling heat flow rate (>=0 for heating)";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.TLoaODE.TAir(final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC") "Room air temperature";
 structural parameter Real bui.terUniHea.gaiHeaFlo.k = 5.963384817222255E-6 "Gain value multiplied with input signal" /* 5.963384817222255E-6 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.gaiHeaFlo.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.gaiHeaFlo.y "Output signal connector";
 structural parameter Real bui.terUniHea.gaiHeaFlo1.k = 5.963384817222255E-6 "Gain value multiplied with input signal" /* 5.963384817222255E-6 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.gaiHeaFlo1.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.gaiHeaFlo1.y "Output signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.swi.u1 "Real input signal";
 discrete Buildings.Controls.OBC.CDL.Interfaces.BooleanInput bui.terUniHea.swi.u2 "Boolean switch input signal, if true, y=u1, else y=u3";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.swi.u3 "Real input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.swi.y "Real output signal";
 parameter Real bui.terUniHea.one.k = 1 "Constant output value" /* 1 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.one.y "Connector of Real output signal";
 parameter Boolean bui.terUniHea.con1.k = bui.terUniHea.have_speVar "Constant output value";
 discrete Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput bui.terUniHea.con1.y "Connector of Boolean output signal";
 eval parameter Boolean bui.terUniHea.allowFlowReversal = false "Set to true to allow flow reversal on the source side" /* false */;
 eval parameter Boolean bui.terUniHea.allowFlowReversalLoa = true "Set to true to allow flow reversal on the load side" /* true */;
 parameter Real bui.terUniHea.facSca = 1 "Scaling factor to be applied to each extensive quantity" /* 1 */;
 eval parameter Boolean bui.terUniHea.have_watHea = true "Set to true if the system has a heating water based heat exchanger" /* true */;
 eval parameter Boolean bui.terUniHea.have_watCoo = false "Set to true if the system has a chilled water based heat exchanger" /* false */;
 eval parameter Boolean bui.terUniHea.have_chaOve = false "Set to true if the chilled water based heat exchanger operates in change-over" /* false */;
 eval parameter Boolean bui.terUniHea.have_eleHea = false "Set to true if the system has an electric heating equipment" /* false */;
 eval parameter Boolean bui.terUniHea.have_eleCoo = false "Set to true if the system has an electric cooling equipment" /* false */;
 eval parameter Boolean bui.terUniHea.have_heaPor = false "Set to true for heat ports on the load side" /* false */;
 eval parameter Boolean bui.terUniHea.have_fluPor = false "Set to true for fluid ports on the load side" /* false */;
 eval parameter Boolean bui.terUniHea.have_TSen = false "Set to true for measured temperature as an input" /* false */;
 eval parameter Boolean bui.terUniHea.have_QReq_flow = true "Set to true for required heat flow rate as an input" /* true */;
 eval parameter Boolean bui.terUniHea.have_weaBus = false "Set to true to enable the weather bus" /* false */;
 eval parameter Boolean bui.terUniHea.have_fan = true "Set to true if the system has a fan" /* true */;
 eval parameter Boolean bui.terUniHea.have_pum = false "Set to true if the system has a pump" /* false */;
 structural parameter Modelica.SIunits.HeatFlowRate bui.terUniHea.QHea_flow_nominal = 167690.0 "Heat flow rate for water based heating at nominal conditions (>=0)" /* 167690.0 */;
 parameter Modelica.SIunits.HeatFlowRate bui.terUniHea.QCoo_flow_nominal(max = 0) = 0 "Heat flow rate for water based cooling at nominal conditions (<=0)" /* 0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.mHeaWat_flow_nominal = 8.015774378585085 "Heating water mass flow rate at nominal conditions" /* 8.015774378585085 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.mChiWat_flow_nominal(min = 0) = 0 "Chilled water mass flow rate at nominal conditions" /* 0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.mLoaHea_flow_nominal = 16.528673093224516 "Load side mass flow rate at nominal conditions in heating mode" /* 16.528673093224516 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.mLoaCoo_flow_nominal(min = 0) = 0 "Load side mass flow rate at nominal conditions in cooling mode" /* 0 */;
 structural parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.T_aHeaWat_nominal = 313.15 "Heating water inlet temperature at nominal conditions" /* 313.15 */;
 structural parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.T_bHeaWat_nominal = 308.15 "Heating water outlet temperature at nominal conditions" /* 308.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.T_aChiWat_nominal(min = 273.15,displayUnit = "degC") = 273.15 + 7.2 "Chilled water inlet temperature at nominal conditions " /* 280.34999999999997 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.T_bChiWat_nominal(min = 273.15,displayUnit = "degC") = bui.terUniHea.T_aChiWat_nominal + 5.6 "Chilled water outlet temperature at nominal conditions";
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.T_aLoaHea_nominal(min = 273.15,displayUnit = "degC") = bui.T_aLoaHea_nominal "Load side inlet temperature at nominal conditions in heating mode";
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.T_aLoaCoo_nominal(min = 273.15,displayUnit = "degC") = 273.15 + 26.7 "Load side inlet temperature at nominal conditions in cooling mode" /* 299.84999999999997 */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Modelica.SIunits.Time bui.terUniHea.tau = 1 "Time constant at nominal flow (if energyDynamics <> SteadyState)" /* 1 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.TSetHea(quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC") "Heating set point";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.QReqHea_flow(final quantity = "HeatFlowRate",final unit = "W") "Required heat flow rate to meet heating set point (>=0)";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.QActHea_flow(final quantity = "HeatFlowRate",final unit = "W") "Heating heat flow rate transferred to the load (>=0)";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.PFan(final quantity = "Power",final unit = "W") "Power drawn by fans motors";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.mReqHeaWat_flow(final quantity = "MassFlowRate",final unit = "kg/s") "Required heating water flow rate to meet heating set point";
 Buildings.Media.Water.MassFlowRate bui.terUniHea.port_aHeaWat.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.port_aHeaWat.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.port_aHeaWat.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.port_aHeaWat.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.port_aHeaWat.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniHea.port_bHeaWat.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.port_bHeaWat.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.port_bHeaWat.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.port_bHeaWat.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.port_bHeaWat.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Real bui.terUniHea.scaQReqHea_flow.k = 1 / bui.terUniHea.facSca "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.scaQReqHea_flow.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.scaQReqHea_flow.y "Output signal connector";
 parameter Real bui.terUniHea.scaQActHea_flow.k = bui.terUniHea.facSca "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.scaQActHea_flow.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.scaQActHea_flow.y "Output signal connector";
 parameter Real bui.terUniHea.scaPFan.k = bui.terUniHea.facSca "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.scaPFan.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.scaPFan.y "Output signal connector";
 parameter Real bui.terUniHea.scaMasFloReqHeaWat.k = bui.terUniHea.facSca "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.scaMasFloReqHeaWat.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.scaMasFloReqHeaWat.y "Output signal connector";
 parameter Real bui.terUniHea.scaHeaWatFloInl.k = 1 / bui.terUniHea.facSca "Gain for mass flow rate";
 eval parameter Boolean bui.terUniHea.scaHeaWatFloInl.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniHea.scaHeaWatFloInl.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.scaHeaWatFloInl.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.scaHeaWatFloInl.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.scaHeaWatFloInl.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.scaHeaWatFloInl.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniHea.scaHeaWatFloInl.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.scaHeaWatFloInl.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.scaHeaWatFloInl.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.scaHeaWatFloInl.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.scaHeaWatFloInl.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Real bui.terUniHea.scaHeaWatFloOut.k = bui.terUniHea.facSca "Gain for mass flow rate";
 eval parameter Boolean bui.terUniHea.scaHeaWatFloOut.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniHea.scaHeaWatFloOut.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.scaHeaWatFloOut.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.scaHeaWatFloOut.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.scaHeaWatFloOut.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.scaHeaWatFloOut.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniHea.scaHeaWatFloOut.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.scaHeaWatFloOut.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.scaHeaWatFloOut.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.scaHeaWatFloOut.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.scaHeaWatFloOut.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Buildings.Fluid.Movers.Data.Generic bui.disFloHea.per(pressure(V_flow(size() = {3}),dp(size() = {3})) = Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters({0, 0.008051312873609197, 0.016102625747218394}, {150000.0, 100000, 50000.0}),use_powerCharacteristic = false,hydraulicEfficiency(V_flow(size() = {1},each min = 0) = {0},eta(size() = {1},each max = 1) = {0.7}),motorEfficiency(V_flow(size() = {1},each min = 0) = {0},eta(size() = {1},each max = 1) = {0.7}),power(V_flow(size() = {1},each min = 0) = {0},P(size() = {1},each min = 0) = {0}),motorCooledByFluid = false,speed_nominal(final min = 0,final unit = "1") = 1,constantSpeed(final min = 0,final unit = "1") = bui.disFloHea.per.constantSpeed_rpm / bui.disFloHea.per.speed_rpm_nominal,speeds(size() = {1},each final min = 0,each final unit = "1") = bui.disFloHea.per.speeds_rpm[1:1] / bui.disFloHea.per.speed_rpm_nominal,speed_rpm_nominal = 1500,constantSpeed_rpm = bui.disFloHea.per.speed_rpm_nominal,speeds_rpm(size() = {1}) = {bui.disFloHea.per.speed_rpm_nominal},havePressureCurve = true) "Record with performance data";
 eval parameter Integer bui.disFloHea.nPorts_a1 = 1 "Number of terminal units return ports" /* 1 */;
 eval parameter Integer bui.disFloHea.nPorts_b1 = 1 "Number of terminal units supply ports" /* 1 */;
 eval parameter Integer bui.disFloHea.nUni = 1 "Number of served units" /* 1 */;
 eval parameter Boolean bui.disFloHea.have_pum = false "Set to true if the system has a pump" /* false */;
 eval parameter Boolean bui.disFloHea.have_val = false "Set to true if the system has a mixing valve" /* false */;
 eval parameter Buildings.Applications.DHC.Loads.Types.DistributionType bui.disFloHea.typDis = Buildings.Applications.DHC.Loads.Types.DistributionType.HeatingWater "Type of distribution system" /* Buildings.Applications.DHC.Loads.Types.DistributionType.HeatingWater */;
 eval parameter Buildings.Applications.DHC.Loads.Types.PumpControlType bui.disFloHea.typCtr = Buildings.Applications.DHC.Loads.Types.PumpControlType.ConstantHead "Type of distribution pump control" /* Buildings.Applications.DHC.Loads.Types.PumpControlType.ConstantHead */;
 parameter Real bui.disFloHea.spePum_nominal(final unit = "1",final min = 0,final max = 1) = 1 "Pump speed at nominal conditions" /* 1 */;
 structural parameter Modelica.SIunits.Pressure bui.disFloHea.dp_nominal = 100000 "Pressure drop at nominal conditions" /* 100000 */;
 structural parameter Modelica.SIunits.Pressure bui.disFloHea.dpVal_nominal = 0 "Mixing valve pressure drop at nominal conditions" /* 0 */;
 structural parameter Modelica.SIunits.Pressure bui.disFloHea.dpDis_nominal[1] = {25000.0} "Pressure drop between each connected unit at nominal conditions (supply line):
    use zero for each connection downstream the differential pressure sensor" /* { 25000.0 } */;
 structural parameter Modelica.SIunits.Pressure bui.disFloHea.dpMin = 50000.0 "Pressure difference set point for ConstantDp or at zero flow for LinearHead" /* 50000.0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.mUni_flow_nominal[1] = {8.015774378585085} "Mass flow rate of each connected unit at nominal conditions" /* { 8.015774378585085 } */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance (except for the pump always modeled in steady state)" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance (except for the pump always modeled in steady state)" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Modelica.SIunits.Time bui.disFloHea.tau = 120 "Time constant of fluid temperature variation at nominal flow rate" /* 120 */;
 Buildings.Media.Water.MassFlowRate bui.disFloHea.ports_a1[1].m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.ports_a1[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.ports_a1[1].h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.ports_a1[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.ports_a1[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloHea.ports_b1[1].m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.ports_b1[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.ports_b1[1].h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.ports_b1[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.ports_b1[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.mReq_flow[1](each final quantity = "MassFlowRate") "Heating or chilled water flow rate required to meet the load";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.mReqTot_flow(final quantity = "MassFlowRate",final unit = "kg/s") "Total heating or chilled water flow rate required to meet the loads";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.QActTot_flow(final quantity = "HeatFlowRate",final unit = "W") "Total heat flow rate transferred to the loads (>=0 for heating)";
 structural parameter Integer bui.disFloHea.sumMasFloReq.nin = 1 "Number of input connections" /* 1 */;
 final parameter Real bui.disFloHea.sumMasFloReq.k[1] = {1} "Input gains" /* { 1 } */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.disFloHea.sumMasFloReq.u[1] "Connector of Real input signals";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.disFloHea.sumMasFloReq.y "Connector of Real output signal";
 eval parameter Boolean bui.disFloHea.sou_m_flow[1].use_m_flow_in = true "Get the mass flow rate from the input connector" /* true */;
 parameter Modelica.SIunits.MassFlowRate bui.disFloHea.sou_m_flow[1].m_flow = 0 "Fixed mass flow rate going out of the fluid port" /* 0 */;
 eval parameter Boolean bui.disFloHea.sou_m_flow[1].use_T_in = true "Get the temperature from the input connector" /* true */;
 parameter Buildings.Media.Water.Temperature bui.disFloHea.sou_m_flow[1].T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sou_m_flow[1].m_flow_in(final unit = "kg/s") "Prescribed mass flow rate";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sou_m_flow[1].T_in(final unit = "K",displayUnit = "degC") "Prescribed boundary temperature";
 eval parameter Boolean bui.disFloHea.sou_m_flow[1].use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean bui.disFloHea.sou_m_flow[1].use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean bui.disFloHea.sou_m_flow[1].use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Water.MassFraction bui.disFloHea.sou_m_flow[1].X[1](final quantity = {"SimpleLiquidWater"}) = {1.0} "Fixed value of composition" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty bui.disFloHea.sou_m_flow[1].C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer bui.disFloHea.sou_m_flow[1].nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean bui.disFloHea.sou_m_flow[1].verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloHea.sou_m_flow[1].ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.sou_m_flow[1].ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.sou_m_flow[1].ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.sou_m_flow[1].ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.sou_m_flow[1].ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.disFloHea.sin.use_p_in = false "Get the pressure from the input connector" /* false */;
 parameter Buildings.Media.Water.AbsolutePressure bui.disFloHea.sin.p(start = 300000.0) = 300000.0 "Fixed value of pressure" /* 300000.0 */;
 eval parameter Boolean bui.disFloHea.sin.use_T_in = false "Get the temperature from the input connector" /* false */;
 parameter Buildings.Media.Water.Temperature bui.disFloHea.sin.T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 eval parameter Boolean bui.disFloHea.sin.use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean bui.disFloHea.sin.use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean bui.disFloHea.sin.use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Water.MassFraction bui.disFloHea.sin.X[1](final quantity = {"SimpleLiquidWater"}) = {1.0} "Fixed value of composition" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty bui.disFloHea.sin.C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer bui.disFloHea.sin.nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean bui.disFloHea.sin.verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloHea.sin.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.sin.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.sin.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.sin.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.sin.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 structural parameter Integer bui.disFloHea.Q_flowSum.nin = 1 "Number of input connections" /* 1 */;
 parameter Real bui.disFloHea.Q_flowSum.k[1] = fill(1, 1) "Input gains" /* { 1 } */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.disFloHea.Q_flowSum.u[1] "Connector of Real input signals";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.disFloHea.Q_flowSum.y "Connector of Real output signal";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.mAct_flow[1].y(each final unit = "kg/s") = (bui.disFloHea.mReq_flow[1:1] .* Buildings.Utilities.Math.Functions.smoothMin(1, bui.disFloHea.senMasFlo.m_flow / Buildings.Utilities.Math.Functions.smoothMax(bui.disFloHea.mReqTot_flow, 8.015774378585086E-4, 8.015774378585086E-4), 0.01))[1] "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.QAct_flow[1].y(each final unit = "W") = ({bui.disFloHea.mAct_flow[1].y} .* ({bui.disFloHea.ports_b1[1].h_outflow} - inStream({bui.disFloHea.ports_a1[1].h_outflow})))[1] "Value of Real output";
 eval parameter Boolean bui.disFloHea.pipPre.control_m_flow = false "if true, then the mass flow rate is equal to the value of m_flow_in" /* false */;
 eval parameter Boolean bui.disFloHea.pipPre.control_dp = true "if true, then the head is equal to the value of dp_in" /* true */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.pipPre.dp_in(unit = "Pa") "Prescribed pressure difference port_a.p-port_b.p";
 structural parameter Modelica.SIunits.Pressure bui.disFloHea.pipPre.dp_start = 100000.0 "Guess value of dp = port_a.p - port_b.p" /* 100000.0 */;
 structural parameter Buildings.Media.Water.MassFlowRate bui.disFloHea.pipPre.m_flow_start = 8.015774378585085 "Guess value of m_flow = port_a.m_flow" /* 8.015774378585085 */;
 structural parameter Buildings.Media.Water.MassFlowRate bui.disFloHea.pipPre.m_flow_small = 8.015774378585086E-4 "Small mass flow rate for regularization of zero flow" /* 8.015774378585086E-4 */;
 structural parameter Boolean bui.disFloHea.pipPre.show_T = false "= true, if temperatures at port_a and port_b are computed" /* false */;
 structural parameter Boolean bui.disFloHea.pipPre.show_V_flow = false "= true, if volume flow rate at inflowing port is computed" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloHea.pipPre.m_flow(min = 0,start = 8.015774378585085) "Mass flow rate in design flow direction";
 Modelica.SIunits.Pressure bui.disFloHea.pipPre.dp(start = 100000.0,displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
 eval parameter Boolean bui.disFloHea.pipPre.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloHea.pipPre.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.pipPre.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.pipPre.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.pipPre.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.pipPre.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloHea.pipPre.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.pipPre.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.pipPre.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.pipPre.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.pipPre.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 final parameter Modelica.SIunits.HeatFlowRate bui.disFloHea.heaCoo.Q_flow_nominal = -1 "Heat flow rate at u=1, positive for heating" /* -1 */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.heaCoo.u(unit = "1") "Control input";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.Q_flow(unit = "W") "Heat added to the fluid";
 constant Boolean bui.disFloHea.heaCoo.homotopyInitialization = true "= true, use homotopy method";
 parameter Modelica.SIunits.Time bui.disFloHea.heaCoo.tau = bui.disFloHea.tau "Time constant at nominal flow (if energyDynamics <> SteadyState)";
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.heaCoo.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.heaCoo.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.p_start(start = 300000.0) = 300000.0 "Start value of pressure" /* 300000.0 */;
 parameter Buildings.Media.Water.Temperature bui.disFloHea.heaCoo.T_start(start = 293.15) = 293.15 "Start value of temperature" /* 293.15 */;
 parameter Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.X_start[1](final quantity = {"SimpleLiquidWater"}) = {1.0} "Start value of mass fractions m_i/m" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.C_start[0](final quantity = fill("", 0)) = fill(0, 0) "Start value of trace substances" /* (zero-size array) */;
 eval parameter Boolean bui.disFloHea.heaCoo.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.SIunits.ThermodynamicTemperature bui.disFloHea.heaCoo.vol.heatPort.T(start = bui.disFloHea.heaCoo.vol.T_start) "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.disFloHea.heaCoo.vol.heatPort.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 eval parameter Boolean bui.disFloHea.heaCoo.vol.initialize_p = false "= true to set up initial equations for pressure" /* false */;
 constant Boolean bui.disFloHea.heaCoo.vol.prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
 constant Boolean bui.disFloHea.heaCoo.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.vol.m_flow_nominal = 8.015774378585085 "Nominal mass flow rate" /* 8.015774378585085 */;
 eval parameter Integer bui.disFloHea.heaCoo.vol.nPorts = 2 "Number of ports" /* 2 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.vol.m_flow_small = 8.015774378585086E-4 "Small mass flow rate for regularization of zero flow" /* 8.015774378585086E-4 */;
 eval parameter Boolean bui.disFloHea.heaCoo.vol.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports." /* false */;
 parameter Modelica.SIunits.Volume bui.disFloHea.heaCoo.vol.V = 8.015774378585085 * bui.disFloHea.heaCoo.tau / bui.disFloHea.heaCoo.rho_default "Volume";
 Buildings.Media.Water.MassFlowRate bui.disFloHea.heaCoo.vol.ports[1].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.vol.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.heaCoo.vol.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.vol.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.vol.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloHea.heaCoo.vol.ports[2].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.vol.ports[2].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.heaCoo.vol.ports[2].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.vol.ports[2].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.vol.ports[2].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.Temperature bui.disFloHea.heaCoo.vol.T(start = 293.15) = Buildings.Media.Water.temperature_phX(bui.disFloHea.heaCoo.vol.p, bui.disFloHea.heaCoo.vol.hOut_internal, cat(1, bui.disFloHea.heaCoo.vol.Xi[1:0], {1 - sum(bui.disFloHea.heaCoo.vol.Xi[1:0])})) "Temperature of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.U(unit = "J") "Internal energy of the component";
 Modelica.SIunits.Pressure bui.disFloHea.heaCoo.vol.p = bui.disFloHea.heaCoo.vol.ports[1].p "Pressure of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.m(unit = "kg") "Mass of the component";
 Modelica.SIunits.MassFraction bui.disFloHea.heaCoo.vol.Xi[0] = bui.disFloHea.heaCoo.vol.XiOut_internal[1:0] "Species concentration of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.mXi[0](each unit = "kg") "Species mass of the component";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.vol.C[0](nominal = bui.disFloHea.heaCoo.vol.C_nominal[1:0]) = bui.disFloHea.heaCoo.vol.COut_internal[1:0] "Trace substance mixture content";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.mC[0](each unit = "kg") "Trace substance mass of the component";
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.heaCoo.vol.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.heaCoo.vol.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.heaCoo.vol.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.heaCoo.vol.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.vol.p_start(start = 300000.0) = bui.disFloHea.heaCoo.p_start "Start value of pressure";
 parameter Buildings.Media.Water.Temperature bui.disFloHea.heaCoo.vol.T_start(start = 293.15) = bui.disFloHea.heaCoo.T_start "Start value of temperature";
 parameter Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.vol.X_start[1](quantity = {"SimpleLiquidWater"}) = bui.disFloHea.heaCoo.X_start[1:1] "Start value of mass fractions m_i/m";
 parameter Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.vol.C_start[0](quantity = fill("", 0)) = bui.disFloHea.heaCoo.C_start[1:0] "Start value of trace substances";
 parameter Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.vol.C_nominal[0](quantity = fill("", 0)) = fill(0.01, 0) "Nominal value of trace substances. (Set to typical order of magnitude.)" /* (zero-size array) */;
 structural parameter Real bui.disFloHea.heaCoo.vol.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 eval parameter Real bui.disFloHea.heaCoo.preDro.deltaM = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs" /* 0.1 */;
 final parameter Real bui.disFloHea.heaCoo.preDro.k = 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)" /* 0 */;
 constant Boolean bui.disFloHea.heaCoo.preDro.homotopyInitialization = true "= true, use homotopy method";
 eval parameter Boolean bui.disFloHea.heaCoo.preDro.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.disFloHea.heaCoo.preDro.dp_nominal = 0 "Pressure drop at nominal mass flow rate" /* 0 */;
 eval parameter Boolean bui.disFloHea.heaCoo.preDro.linearized = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.preDro.m_flow_turbulent = 0 "Turbulent flow if |m_flow| >= m_flow_turbulent" /* 0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.preDro.m_flow_nominal = 8.015774378585085 "Nominal mass flow rate" /* 8.015774378585085 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.preDro.m_flow_small = 8.015774378585086E-4 "Small mass flow rate for regularization of zero flow" /* 8.015774378585086E-4 */;
 structural parameter Boolean bui.disFloHea.heaCoo.preDro.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.preDro.m_flow(nominal = 8.015774378585085,start = 0.0) = bui.disFloHea.heaCoo.preDro.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.disFloHea.heaCoo.preDro.dp(nominal = 1,start = 0.0,displayUnit = "Pa") = bui.disFloHea.heaCoo.preDro.port_a.p - bui.disFloHea.heaCoo.preDro.port_b.p "Pressure difference between port_a and port_b";
 eval parameter Boolean bui.disFloHea.heaCoo.preDro.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloHea.heaCoo.preDro.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.preDro.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.heaCoo.preDro.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.preDro.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.preDro.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloHea.heaCoo.preDro.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.preDro.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.heaCoo.preDro.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.preDro.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.preDro.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.m_flow_nominal = 8.015774378585085 "Nominal mass flow rate" /* 8.015774378585085 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.m_flow_small = 8.015774378585086E-4 "Small mass flow rate for regularization of zero flow" /* 8.015774378585086E-4 */;
 structural parameter Boolean bui.disFloHea.heaCoo.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.m_flow(start = 0.0) = bui.disFloHea.heaCoo.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.disFloHea.heaCoo.dp(start = 0.0,displayUnit = "Pa") = bui.disFloHea.heaCoo.port_a.p - bui.disFloHea.heaCoo.port_b.p "Pressure difference between port_a and port_b";
 eval parameter Boolean bui.disFloHea.heaCoo.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloHea.heaCoo.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.heaCoo.port_a.h_outflow(start = bui.disFloHea.heaCoo.h_outflow_start,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloHea.heaCoo.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.heaCoo.port_b.h_outflow(start = bui.disFloHea.heaCoo.h_outflow_start,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.disFloHea.heaCoo.computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction" /* true */;
 eval parameter Boolean bui.disFloHea.heaCoo.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.disFloHea.heaCoo.dp_nominal = 0 "Pressure difference" /* 0 */;
 structural parameter Boolean bui.disFloHea.heaCoo.linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real bui.disFloHea.heaCoo.deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.TSupVal.y(final unit = "K",displayUnit = "degC") = bui.disFloHea.TSup "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.senMasFlo.m_flow(quantity = "MassFlowRate",final unit = "kg/s") "Mass flow rate from port_a to port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.disFloHea.senMasFlo.m_flow_nominal = 0 "Nominal mass flow rate, used for regularization near zero flow" /* 0 */;
 final parameter Modelica.SIunits.MassFlowRate bui.disFloHea.senMasFlo.m_flow_small = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)" /* 0 */;
 eval parameter Boolean bui.disFloHea.senMasFlo.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloHea.senMasFlo.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.senMasFlo.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.senMasFlo.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.senMasFlo.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.senMasFlo.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloHea.senMasFlo.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.senMasFlo.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.senMasFlo.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.senMasFlo.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.senMasFlo.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 structural parameter Integer bui.disFloHea.reaRep.nout = 1 "Number of outputs" /* 1 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.disFloHea.reaRep.u "Connector of Real input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.disFloHea.reaRep.y[1] "Connector of Real output signal";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.dpNetVal.y(final unit = "Pa") = bui.disFloHea.dpPum "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.masFloPum.y(final unit = "kg/s") = bui.disFloHea.mPum_flow "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.spePum.y(final unit = "1") = bui.disFloHea.spePum_nominal "Value of Real output";
 Modelica.SIunits.ThermodynamicTemperature bui.disFloHea.TSup(displayUnit = "degC") = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(bui.disFloHea.pipPre.port_a.p, inStream(bui.disFloHea.pipPre.port_a.h_outflow), inStream(bui.disFloHea.pipPre.port_a.Xi_outflow[1:0]))) "Supply temperature";
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.m_flow_nominal = 8.015774378585085 "Nominal mass flow rate" /* 8.015774378585085 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.m_flow_small = 8.015774378585086E-4 "Small mass flow rate for regularization of zero flow" /* 8.015774378585086E-4 */;
 structural parameter Boolean bui.disFloHea.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.disFloHea.m_flow(start = 0.0) = bui.disFloHea.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.disFloHea.dp(start = 0.0,displayUnit = "Pa") = bui.disFloHea.port_a.p - bui.disFloHea.port_b.p "Pressure difference between port_a and port_b";
 eval parameter Boolean bui.disFloHea.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloHea.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloHea.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Buildings.Fluid.Movers.Data.Generic bui.disFloCoo.per(pressure(V_flow(size() = {3}),dp(size() = {3})) = Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters({0, 0.007056001788452546, 0.014112003576905093}, {150000.0, 100000, 50000.0}),use_powerCharacteristic = false,hydraulicEfficiency(V_flow(size() = {1},each min = 0) = {0},eta(size() = {1},each max = 1) = {0.7}),motorEfficiency(V_flow(size() = {1},each min = 0) = {0},eta(size() = {1},each max = 1) = {0.7}),power(V_flow(size() = {1},each min = 0) = {0},P(size() = {1},each min = 0) = {0}),motorCooledByFluid = false,speed_nominal(final min = 0,final unit = "1") = 1,constantSpeed(final min = 0,final unit = "1") = bui.disFloCoo.per.constantSpeed_rpm / bui.disFloCoo.per.speed_rpm_nominal,speeds(size() = {1},each final min = 0,each final unit = "1") = bui.disFloCoo.per.speeds_rpm[1:1] / bui.disFloCoo.per.speed_rpm_nominal,speed_rpm_nominal = 1500,constantSpeed_rpm = bui.disFloCoo.per.speed_rpm_nominal,speeds_rpm(size() = {1}) = {bui.disFloCoo.per.speed_rpm_nominal},havePressureCurve = true) "Record with performance data";
 eval parameter Integer bui.disFloCoo.nPorts_a1 = 1 "Number of terminal units return ports" /* 1 */;
 eval parameter Integer bui.disFloCoo.nPorts_b1 = 1 "Number of terminal units supply ports" /* 1 */;
 eval parameter Integer bui.disFloCoo.nUni = 1 "Number of served units" /* 1 */;
 eval parameter Boolean bui.disFloCoo.have_pum = false "Set to true if the system has a pump" /* false */;
 eval parameter Boolean bui.disFloCoo.have_val = false "Set to true if the system has a mixing valve" /* false */;
 eval parameter Buildings.Applications.DHC.Loads.Types.DistributionType bui.disFloCoo.typDis = Buildings.Applications.DHC.Loads.Types.DistributionType.ChilledWater "Type of distribution system" /* Buildings.Applications.DHC.Loads.Types.DistributionType.ChilledWater */;
 eval parameter Buildings.Applications.DHC.Loads.Types.PumpControlType bui.disFloCoo.typCtr = Buildings.Applications.DHC.Loads.Types.PumpControlType.ConstantHead "Type of distribution pump control" /* Buildings.Applications.DHC.Loads.Types.PumpControlType.ConstantHead */;
 parameter Real bui.disFloCoo.spePum_nominal(final unit = "1",final min = 0,final max = 1) = 1 "Pump speed at nominal conditions" /* 1 */;
 structural parameter Modelica.SIunits.Pressure bui.disFloCoo.dp_nominal = 100000 "Pressure drop at nominal conditions" /* 100000 */;
 structural parameter Modelica.SIunits.Pressure bui.disFloCoo.dpVal_nominal = 0 "Mixing valve pressure drop at nominal conditions" /* 0 */;
 structural parameter Modelica.SIunits.Pressure bui.disFloCoo.dpDis_nominal[1] = {25000.0} "Pressure drop between each connected unit at nominal conditions (supply line):
    use zero for each connection downstream the differential pressure sensor" /* { 25000.0 } */;
 structural parameter Modelica.SIunits.Pressure bui.disFloCoo.dpMin = 50000.0 "Pressure difference set point for ConstantDp or at zero flow for LinearHead" /* 50000.0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.mUni_flow_nominal[1] = {7.024856596558317} "Mass flow rate of each connected unit at nominal conditions" /* { 7.024856596558317 } */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance (except for the pump always modeled in steady state)" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance (except for the pump always modeled in steady state)" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Modelica.SIunits.Time bui.disFloCoo.tau = 120 "Time constant of fluid temperature variation at nominal flow rate" /* 120 */;
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.ports_a1[1].m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.ports_a1[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.ports_a1[1].h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.ports_a1[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.ports_a1[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.ports_b1[1].m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.ports_b1[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.ports_b1[1].h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.ports_b1[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.ports_b1[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.mReq_flow[1](each final quantity = "MassFlowRate") "Heating or chilled water flow rate required to meet the load";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.mReqTot_flow(final quantity = "MassFlowRate",final unit = "kg/s") "Total heating or chilled water flow rate required to meet the loads";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.QActTot_flow(final quantity = "HeatFlowRate",final unit = "W") "Total heat flow rate transferred to the loads (>=0 for heating)";
 structural parameter Integer bui.disFloCoo.sumMasFloReq.nin = 1 "Number of input connections" /* 1 */;
 final parameter Real bui.disFloCoo.sumMasFloReq.k[1] = {1} "Input gains" /* { 1 } */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.disFloCoo.sumMasFloReq.u[1] "Connector of Real input signals";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.disFloCoo.sumMasFloReq.y "Connector of Real output signal";
 eval parameter Boolean bui.disFloCoo.sou_m_flow[1].use_m_flow_in = true "Get the mass flow rate from the input connector" /* true */;
 parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.sou_m_flow[1].m_flow = 0 "Fixed mass flow rate going out of the fluid port" /* 0 */;
 eval parameter Boolean bui.disFloCoo.sou_m_flow[1].use_T_in = true "Get the temperature from the input connector" /* true */;
 parameter Buildings.Media.Water.Temperature bui.disFloCoo.sou_m_flow[1].T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sou_m_flow[1].m_flow_in(final unit = "kg/s") "Prescribed mass flow rate";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sou_m_flow[1].T_in(final unit = "K",displayUnit = "degC") "Prescribed boundary temperature";
 eval parameter Boolean bui.disFloCoo.sou_m_flow[1].use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean bui.disFloCoo.sou_m_flow[1].use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean bui.disFloCoo.sou_m_flow[1].use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Water.MassFraction bui.disFloCoo.sou_m_flow[1].X[1](final quantity = {"SimpleLiquidWater"}) = {1.0} "Fixed value of composition" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty bui.disFloCoo.sou_m_flow[1].C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer bui.disFloCoo.sou_m_flow[1].nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean bui.disFloCoo.sou_m_flow[1].verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.sou_m_flow[1].ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.sou_m_flow[1].ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.sou_m_flow[1].ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.sou_m_flow[1].ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.sou_m_flow[1].ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.disFloCoo.sin.use_p_in = false "Get the pressure from the input connector" /* false */;
 parameter Buildings.Media.Water.AbsolutePressure bui.disFloCoo.sin.p(start = 300000.0) = 300000.0 "Fixed value of pressure" /* 300000.0 */;
 eval parameter Boolean bui.disFloCoo.sin.use_T_in = false "Get the temperature from the input connector" /* false */;
 parameter Buildings.Media.Water.Temperature bui.disFloCoo.sin.T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 eval parameter Boolean bui.disFloCoo.sin.use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean bui.disFloCoo.sin.use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean bui.disFloCoo.sin.use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Water.MassFraction bui.disFloCoo.sin.X[1](final quantity = {"SimpleLiquidWater"}) = {1.0} "Fixed value of composition" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty bui.disFloCoo.sin.C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer bui.disFloCoo.sin.nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean bui.disFloCoo.sin.verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.sin.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.sin.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.sin.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.sin.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.sin.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 structural parameter Integer bui.disFloCoo.Q_flowSum.nin = 1 "Number of input connections" /* 1 */;
 parameter Real bui.disFloCoo.Q_flowSum.k[1] = fill(1, 1) "Input gains" /* { 1 } */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.disFloCoo.Q_flowSum.u[1] "Connector of Real input signals";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.disFloCoo.Q_flowSum.y "Connector of Real output signal";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.mAct_flow[1].y(each final unit = "kg/s") = (bui.disFloCoo.mReq_flow[1:1] .* Buildings.Utilities.Math.Functions.smoothMin(1, bui.disFloCoo.senMasFlo.m_flow / Buildings.Utilities.Math.Functions.smoothMax(bui.disFloCoo.mReqTot_flow, 7.024856596558318E-4, 7.024856596558318E-4), 0.01))[1] "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.QAct_flow[1].y(each final unit = "W") = ({bui.disFloCoo.mAct_flow[1].y} .* ({bui.disFloCoo.ports_b1[1].h_outflow} - inStream({bui.disFloCoo.ports_a1[1].h_outflow})))[1] "Value of Real output";
 eval parameter Boolean bui.disFloCoo.pipPre.control_m_flow = false "if true, then the mass flow rate is equal to the value of m_flow_in" /* false */;
 eval parameter Boolean bui.disFloCoo.pipPre.control_dp = true "if true, then the head is equal to the value of dp_in" /* true */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.pipPre.dp_in(unit = "Pa") "Prescribed pressure difference port_a.p-port_b.p";
 structural parameter Modelica.SIunits.Pressure bui.disFloCoo.pipPre.dp_start = 100000.0 "Guess value of dp = port_a.p - port_b.p" /* 100000.0 */;
 structural parameter Buildings.Media.Water.MassFlowRate bui.disFloCoo.pipPre.m_flow_start = 7.024856596558317 "Guess value of m_flow = port_a.m_flow" /* 7.024856596558317 */;
 structural parameter Buildings.Media.Water.MassFlowRate bui.disFloCoo.pipPre.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 structural parameter Boolean bui.disFloCoo.pipPre.show_T = false "= true, if temperatures at port_a and port_b are computed" /* false */;
 structural parameter Boolean bui.disFloCoo.pipPre.show_V_flow = false "= true, if volume flow rate at inflowing port is computed" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.pipPre.m_flow(min = 0,start = 7.024856596558317) "Mass flow rate in design flow direction";
 Modelica.SIunits.Pressure bui.disFloCoo.pipPre.dp(start = 100000.0,displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
 eval parameter Boolean bui.disFloCoo.pipPre.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.pipPre.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.pipPre.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.pipPre.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.pipPre.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.pipPre.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.pipPre.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.pipPre.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.pipPre.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.pipPre.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.pipPre.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 final parameter Modelica.SIunits.HeatFlowRate bui.disFloCoo.heaCoo.Q_flow_nominal = -1 "Heat flow rate at u=1, positive for heating" /* -1 */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.heaCoo.u(unit = "1") "Control input";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.Q_flow(unit = "W") "Heat added to the fluid";
 constant Boolean bui.disFloCoo.heaCoo.homotopyInitialization = true "= true, use homotopy method";
 parameter Modelica.SIunits.Time bui.disFloCoo.heaCoo.tau = bui.disFloCoo.tau "Time constant at nominal flow (if energyDynamics <> SteadyState)";
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.heaCoo.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.heaCoo.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.p_start(start = 300000.0) = 300000.0 "Start value of pressure" /* 300000.0 */;
 parameter Buildings.Media.Water.Temperature bui.disFloCoo.heaCoo.T_start(start = 293.15) = 293.15 "Start value of temperature" /* 293.15 */;
 parameter Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.X_start[1](final quantity = {"SimpleLiquidWater"}) = {1.0} "Start value of mass fractions m_i/m" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.C_start[0](final quantity = fill("", 0)) = fill(0, 0) "Start value of trace substances" /* (zero-size array) */;
 eval parameter Boolean bui.disFloCoo.heaCoo.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.SIunits.ThermodynamicTemperature bui.disFloCoo.heaCoo.vol.heatPort.T(start = bui.disFloCoo.heaCoo.vol.T_start) "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.disFloCoo.heaCoo.vol.heatPort.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 eval parameter Boolean bui.disFloCoo.heaCoo.vol.initialize_p = false "= true to set up initial equations for pressure" /* false */;
 constant Boolean bui.disFloCoo.heaCoo.vol.prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
 constant Boolean bui.disFloCoo.heaCoo.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.vol.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 eval parameter Integer bui.disFloCoo.heaCoo.vol.nPorts = 2 "Number of ports" /* 2 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.vol.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 eval parameter Boolean bui.disFloCoo.heaCoo.vol.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports." /* false */;
 parameter Modelica.SIunits.Volume bui.disFloCoo.heaCoo.vol.V = 7.024856596558317 * bui.disFloCoo.heaCoo.tau / bui.disFloCoo.heaCoo.rho_default "Volume";
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.heaCoo.vol.ports[1].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.vol.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.heaCoo.vol.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.vol.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.vol.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.heaCoo.vol.ports[2].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.vol.ports[2].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.heaCoo.vol.ports[2].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.vol.ports[2].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.vol.ports[2].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.Temperature bui.disFloCoo.heaCoo.vol.T(start = 293.15) = Buildings.Media.Water.temperature_phX(bui.disFloCoo.heaCoo.vol.p, bui.disFloCoo.heaCoo.vol.hOut_internal, cat(1, bui.disFloCoo.heaCoo.vol.Xi[1:0], {1 - sum(bui.disFloCoo.heaCoo.vol.Xi[1:0])})) "Temperature of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.U(unit = "J") "Internal energy of the component";
 Modelica.SIunits.Pressure bui.disFloCoo.heaCoo.vol.p = bui.disFloCoo.heaCoo.vol.ports[1].p "Pressure of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.m(unit = "kg") "Mass of the component";
 Modelica.SIunits.MassFraction bui.disFloCoo.heaCoo.vol.Xi[0] = bui.disFloCoo.heaCoo.vol.XiOut_internal[1:0] "Species concentration of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.mXi[0](each unit = "kg") "Species mass of the component";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.vol.C[0](nominal = bui.disFloCoo.heaCoo.vol.C_nominal[1:0]) = bui.disFloCoo.heaCoo.vol.COut_internal[1:0] "Trace substance mixture content";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.mC[0](each unit = "kg") "Trace substance mass of the component";
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.heaCoo.vol.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.heaCoo.vol.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.heaCoo.vol.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.heaCoo.vol.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.vol.p_start(start = 300000.0) = bui.disFloCoo.heaCoo.p_start "Start value of pressure";
 parameter Buildings.Media.Water.Temperature bui.disFloCoo.heaCoo.vol.T_start(start = 293.15) = bui.disFloCoo.heaCoo.T_start "Start value of temperature";
 parameter Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.vol.X_start[1](quantity = {"SimpleLiquidWater"}) = bui.disFloCoo.heaCoo.X_start[1:1] "Start value of mass fractions m_i/m";
 parameter Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.vol.C_start[0](quantity = fill("", 0)) = bui.disFloCoo.heaCoo.C_start[1:0] "Start value of trace substances";
 parameter Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.vol.C_nominal[0](quantity = fill("", 0)) = fill(0.01, 0) "Nominal value of trace substances. (Set to typical order of magnitude.)" /* (zero-size array) */;
 structural parameter Real bui.disFloCoo.heaCoo.vol.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 eval parameter Real bui.disFloCoo.heaCoo.preDro.deltaM = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs" /* 0.1 */;
 final parameter Real bui.disFloCoo.heaCoo.preDro.k = 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)" /* 0 */;
 constant Boolean bui.disFloCoo.heaCoo.preDro.homotopyInitialization = true "= true, use homotopy method";
 eval parameter Boolean bui.disFloCoo.heaCoo.preDro.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.disFloCoo.heaCoo.preDro.dp_nominal = 0 "Pressure drop at nominal mass flow rate" /* 0 */;
 eval parameter Boolean bui.disFloCoo.heaCoo.preDro.linearized = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.preDro.m_flow_turbulent = 0 "Turbulent flow if |m_flow| >= m_flow_turbulent" /* 0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.preDro.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.preDro.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 structural parameter Boolean bui.disFloCoo.heaCoo.preDro.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.preDro.m_flow(nominal = 7.024856596558317,start = 0.0) = bui.disFloCoo.heaCoo.preDro.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.disFloCoo.heaCoo.preDro.dp(nominal = 1,start = 0.0,displayUnit = "Pa") = bui.disFloCoo.heaCoo.preDro.port_a.p - bui.disFloCoo.heaCoo.preDro.port_b.p "Pressure difference between port_a and port_b";
 eval parameter Boolean bui.disFloCoo.heaCoo.preDro.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.heaCoo.preDro.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.preDro.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.heaCoo.preDro.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.preDro.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.preDro.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.heaCoo.preDro.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.preDro.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.heaCoo.preDro.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.preDro.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.preDro.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 structural parameter Boolean bui.disFloCoo.heaCoo.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.m_flow(start = 0.0) = bui.disFloCoo.heaCoo.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.disFloCoo.heaCoo.dp(start = 0.0,displayUnit = "Pa") = bui.disFloCoo.heaCoo.port_a.p - bui.disFloCoo.heaCoo.port_b.p "Pressure difference between port_a and port_b";
 eval parameter Boolean bui.disFloCoo.heaCoo.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.heaCoo.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.heaCoo.port_a.h_outflow(start = bui.disFloCoo.heaCoo.h_outflow_start,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.heaCoo.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.heaCoo.port_b.h_outflow(start = bui.disFloCoo.heaCoo.h_outflow_start,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.disFloCoo.heaCoo.computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction" /* true */;
 eval parameter Boolean bui.disFloCoo.heaCoo.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.disFloCoo.heaCoo.dp_nominal = 0 "Pressure difference" /* 0 */;
 structural parameter Boolean bui.disFloCoo.heaCoo.linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real bui.disFloCoo.heaCoo.deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.TSupVal.y(final unit = "K",displayUnit = "degC") = bui.disFloCoo.TSup "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.senMasFlo.m_flow(quantity = "MassFlowRate",final unit = "kg/s") "Mass flow rate from port_a to port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.senMasFlo.m_flow_nominal = 0 "Nominal mass flow rate, used for regularization near zero flow" /* 0 */;
 final parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.senMasFlo.m_flow_small = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)" /* 0 */;
 eval parameter Boolean bui.disFloCoo.senMasFlo.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.senMasFlo.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.senMasFlo.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.senMasFlo.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.senMasFlo.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.senMasFlo.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.senMasFlo.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.senMasFlo.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.senMasFlo.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.senMasFlo.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.senMasFlo.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 structural parameter Integer bui.disFloCoo.reaRep.nout = 1 "Number of outputs" /* 1 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.disFloCoo.reaRep.u "Connector of Real input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.disFloCoo.reaRep.y[1] "Connector of Real output signal";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.dpNetVal.y(final unit = "Pa") = bui.disFloCoo.dpPum "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.masFloPum.y(final unit = "kg/s") = bui.disFloCoo.mPum_flow "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.spePum.y(final unit = "1") = bui.disFloCoo.spePum_nominal "Value of Real output";
 Modelica.SIunits.ThermodynamicTemperature bui.disFloCoo.TSup(displayUnit = "degC") = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(bui.disFloCoo.pipPre.port_a.p, inStream(bui.disFloCoo.pipPre.port_a.h_outflow), inStream(bui.disFloCoo.pipPre.port_a.Xi_outflow[1:0]))) "Supply temperature";
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 structural parameter Boolean bui.disFloCoo.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.disFloCoo.m_flow(start = 0.0) = bui.disFloCoo.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.disFloCoo.dp(start = 0.0,displayUnit = "Pa") = bui.disFloCoo.port_a.p - bui.disFloCoo.port_b.p "Pressure difference between port_a and port_b";
 eval parameter Boolean bui.disFloCoo.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 structural parameter Buildings.Fluid.Types.HeatExchangerConfiguration bui.terUniCoo.hexConHea = Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow "Heating heat exchanger configuration" /* Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow */;
 final parameter Buildings.Fluid.Types.HeatExchangerConfiguration bui.terUniCoo.hexConCoo = Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow "Cooling heat exchanger configuration" /* Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow */;
 structural parameter Buildings.Controls.OBC.CDL.Types.SimpleController bui.terUniCoo.con.controllerType = Buildings.Controls.OBC.CDL.Types.SimpleController.PI "Type of controller" /* Buildings.Controls.OBC.CDL.Types.SimpleController.PI */;
 parameter Real bui.terUniCoo.con.k(min = 0) = 1 "Gain of controller" /* 1 */;
 parameter Modelica.SIunits.Time bui.terUniCoo.con.Ti(min = 1.0E-60) = 10 "Time constant of integrator block" /* 10 */;
 parameter Modelica.SIunits.Time bui.terUniCoo.con.Td(min = 0) = 0.1 "Time constant of derivative block" /* 0.1 */;
 parameter Real bui.terUniCoo.con.yMax = 1 "Upper limit of output" /* 1 */;
 parameter Real bui.terUniCoo.con.yMin = 0 "Lower limit of output" /* 0 */;
 parameter Real bui.terUniCoo.con.wp(min = 0) = 1 "Set-point weight for Proportional block (0..1)" /* 1 */;
 parameter Real bui.terUniCoo.con.wd(min = 0) = 0 "Set-point weight for Derivative block (0..1)" /* 0 */;
 parameter Real bui.terUniCoo.con.Ni(min = 100 * 1.0E-15) = 0.9 "Ni*Ti is time constant of anti-windup compensation" /* 0.9 */;
 parameter Real bui.terUniCoo.con.Nd(min = 100 * 1.0E-15) = 10 "The higher Nd, the more ideal the derivative block" /* 10 */;
 parameter Real bui.terUniCoo.con.xi_start = 0 "Initial value of integrator state" /* 0 */;
 parameter Real bui.terUniCoo.con.yd_start = 0 "Initial value of derivative output" /* 0 */;
 parameter Boolean bui.terUniCoo.con.reverseAction = false "Set to true for throttling the water flow rate through a cooling coil controller" /* false */;
 eval parameter Buildings.Controls.OBC.CDL.Types.Reset bui.terUniCoo.con.reset = Buildings.Controls.OBC.CDL.Types.Reset.Disabled "Type of controller output reset" /* Buildings.Controls.OBC.CDL.Types.Reset.Disabled */;
 parameter Real bui.terUniCoo.con.y_reset = bui.terUniCoo.con.xi_start "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == CDL.Types.Reset.Parameter";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.u_s "Connector of setpoint input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.u_m "Connector of measurement input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.y "Connector of actuator output signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.controlError.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.controlError.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.controlError.y "Connector of Real output signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.I.u "Connector of Real input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.I.y "Connector of Real output signal";
 parameter Real bui.terUniCoo.con.I.k(unit = "1") = 1 / bui.terUniCoo.con.Ti "Integrator gain";
 parameter Real bui.terUniCoo.con.I.y_start = bui.terUniCoo.con.xi_start "Initial or guess value of output (= state)";
 eval parameter Buildings.Controls.OBC.CDL.Types.Reset bui.terUniCoo.con.I.reset = Buildings.Controls.OBC.CDL.Types.Reset.Disabled "Type of integrator reset" /* Buildings.Controls.OBC.CDL.Types.Reset.Disabled */;
 parameter Real bui.terUniCoo.con.I.y_reset = bui.terUniCoo.con.y_reset "Value to which integrator is reset, used if reset = Types.Reset.Parameter";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.errP.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.errP.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.errP.y "Connector of Real output signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.errI1.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.errI1.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.errI1.y "Connector of Real output signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.errI2.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.errI2.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.errI2.y "Connector of Real output signal";
 parameter Real bui.terUniCoo.con.lim.uMax = bui.terUniCoo.con.yMax "Upper limit of input signal";
 parameter Real bui.terUniCoo.con.lim.uMin = bui.terUniCoo.con.yMin "Lower limit of input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.lim.u "Connector of Real input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.lim.y "Connector of Real output signal";
 structural parameter Modelica.SIunits.Pressure bui.terUniCoo.fan.dp_nominal = 200 "Nominal pressure raise, used for default pressure curve if not specified in record per" /* 200 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.m_flow_start(min = 0) = 0 "Initial value of mass flow rate" /* 0 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.constantMassFlowRate = 14.485382537898948 "Constant pump mass flow rate, used when inputType=Constant" /* 14.485382537898948 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.massFlowRates[1] = 14.485382537898948 * {bui.terUniCoo.fan.per.speeds[1] / bui.terUniCoo.fan.per.speeds[1]} "Vector of mass flow rate set points, used when inputType=Stage";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.m_flow_in(final unit = "kg/s",nominal = 14.485382537898948) "Prescribed mass flow rate";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.m_flow_actual(final unit = "kg/s",nominal = 14.485382537898948) "Actual mass flow rate";
 parameter Buildings.Fluid.Movers.Data.Generic bui.terUniCoo.fan.per(pressure(V_flow(size() = {2}),dp(size() = {2})) = Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters({0, 0}, {0, 0}),use_powerCharacteristic = false,hydraulicEfficiency(V_flow(size() = {1},each min = 0) = {0},eta(size() = {1},each max = 1) = {0.7}),motorEfficiency(V_flow(size() = {1},each min = 0) = {0},eta(size() = {1},each max = 1) = {0.7}),power(V_flow(size() = {1},each min = 0) = {0},P(size() = {1},each min = 0) = {0}),motorCooledByFluid = true,speed_nominal(final min = 0,final unit = "1") = 1,constantSpeed(final min = 0,final unit = "1") = bui.terUniCoo.fan.per.constantSpeed_rpm / bui.terUniCoo.fan.per.speed_rpm_nominal,speeds(size() = {1},each final min = 0,each final unit = "1") = bui.terUniCoo.fan.per.speeds_rpm[1:1] / bui.terUniCoo.fan.per.speed_rpm_nominal,speed_rpm_nominal = 1500,constantSpeed_rpm = bui.terUniCoo.fan.per.speed_rpm_nominal,speeds_rpm(size() = {1}) = {bui.terUniCoo.fan.per.speed_rpm_nominal},havePressureCurve = false);
 structural parameter Buildings.Fluid.Types.InputType bui.terUniCoo.fan.inputType = Buildings.Fluid.Types.InputType.Continuous "Control input type" /* Buildings.Fluid.Types.InputType.Continuous */;
 parameter Real bui.terUniCoo.fan.constInput(final unit = "kg/s") = bui.terUniCoo.fan.constantMassFlowRate "Constant input set point";
 parameter Real bui.terUniCoo.fan.stageInputs[1](each final unit = "kg/s") = bui.terUniCoo.fan.massFlowRates[1:1] "Vector of input set points corresponding to stages";
 structural parameter Boolean bui.terUniCoo.fan.computePowerUsingSimilarityLaws = false "= true, compute power exactly, using similarity laws. Otherwise approximate." /* false */;
 structural parameter Boolean bui.terUniCoo.fan.addPowerToMedium = false "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations)" /* false */;
 parameter Boolean bui.terUniCoo.fan.nominalValuesDefineDefaultPressureCurve = true "Set to true to avoid warning if m_flow_nominal and dp_nominal are used to construct the default pressure curve" /* true */;
 parameter Modelica.SIunits.Time bui.terUniCoo.fan.tau = 1 "Time constant of fluid volume for nominal flow, used if energy or mass balance is dynamic" /* 1 */;
 structural parameter Boolean bui.terUniCoo.fan.use_inputFilter = true "= true, if speed is filtered with a 2nd order CriticalDamping filter" /* true */;
 parameter Modelica.SIunits.Time bui.terUniCoo.fan.riseTime = 30 "Rise time of the filter (time to reach 99.6 % of the speed)" /* 30 */;
 structural parameter Modelica.Blocks.Types.Init bui.terUniCoo.fan.init = Modelica.Blocks.Types.Init.InitialOutput "Type of initialization (no init/steady state/initial state/initial output)" /* Modelica.Blocks.Types.Init.InitialOutput */;
 parameter Real bui.terUniCoo.fan.y_start(min = 0,max = 1,unit = "1") = 0 "Initial value of speed" /* 0 */;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.y_actual(final unit = "1") "Actual normalised pump speed that is used for computations";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.P(quantity = "Power",final unit = "W") "Electrical power consumed";
 Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.fan.heatPort.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniCoo.fan.heatPort.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.SIunits.VolumeFlowRate bui.terUniCoo.fan.VMachine_flow(start = 0.0) = bui.terUniCoo.fan.eff.V_flow "Volume flow rate";
 Modelica.SIunits.Pressure bui.terUniCoo.fan.dpMachine(displayUnit = "Pa") = - bui.terUniCoo.fan.preSou.dp "Pressure difference";
 Real bui.terUniCoo.fan.eta(unit = "1",final quantity = "Efficiency") = bui.terUniCoo.fan.eff.eta "Global efficiency";
 Real bui.terUniCoo.fan.etaHyd(unit = "1",final quantity = "Efficiency") = bui.terUniCoo.fan.eff.etaHyd "Hydraulic efficiency";
 Real bui.terUniCoo.fan.etaMot(unit = "1",final quantity = "Efficiency") = bui.terUniCoo.fan.eff.etaMot "Motor efficiency";
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.p_start(displayUnit = "Pa",start = 101325.0) = 101325.0 "Start value of pressure" /* 101325.0 */;
 parameter Buildings.Media.Air.Temperature bui.terUniCoo.fan.T_start(start = 293.15) = 293.15 "Start value of temperature" /* 293.15 */;
 parameter Buildings.Media.Air.MassFraction bui.terUniCoo.fan.X_start[2](quantity = {"water", "air"}) = {0.01, 0.99} "Start value of mass fractions m_i/m" /* { 0.01, 0.99 } */;
 parameter Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.C_start[0](quantity = fill("", 0)) = fill(0, 0) "Start value of trace substances" /* (zero-size array) */;
 parameter Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.C_nominal[0](quantity = fill("", 0)) = fill(0.01, 0) "Nominal value of trace substances. (Set to typical order of magnitude.)" /* (zero-size array) */;
 final parameter Real bui.terUniCoo.fan.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.m_flow_nominal = 14.485382537898948 "Nominal mass flow rate" /* 14.485382537898948 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.m_flow_small = 0.0014485382537898948 "Small mass flow rate for regularization of zero flow" /* 0.0014485382537898948 */;
 structural parameter Boolean bui.terUniCoo.fan.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.m_flow(start = 0.0) = bui.terUniCoo.fan.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniCoo.fan.dp(start = 0.0,displayUnit = "Pa") = bui.terUniCoo.fan.port_a.p - bui.terUniCoo.fan.port_b.p "Pressure difference between port_a and port_b";
 eval parameter Boolean bui.terUniCoo.fan.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.port_a.h_outflow(start = bui.terUniCoo.fan.h_outflow_start,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.port_b.p(start = bui.terUniCoo.fan.p_start) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.port_b.h_outflow(start = bui.terUniCoo.fan.h_outflow_start,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Real bui.terUniCoo.hex.r_nominal(min = 0,max = 1) = 2 / 3 "Ratio between air-side and water-side convective heat transfer (hA-value) at nominal condition" /* 0.6666666666666666 */;
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.hA.UA_nominal(min = 0) = bui.terUniCoo.hex.UA_nominal "Thermal conductance at nominal flow";
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.hA.m_flow_nominal_w = bui.terUniCoo.hex.m1_flow_nominal "Water mass flow rate";
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.hA.m_flow_nominal_a = 14.485382537898948 "Air mass flow rate" /* 14.485382537898948 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.hex.hA.m1_flow(final unit = "kg/s") "Mass flow rate medium 1";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.hex.hA.m2_flow(final unit = "kg/s") "Mass flow rate medium 2";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.hex.hA.T_1(final unit = "K") "Temperature medium 1";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.hex.hA.T_2(final unit = "K") "Temperature medium 2";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.hA.hA_1(final unit = "W/K") "Convective heat transfer medium 1";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.hA.hA_2(final unit = "W/K") "Convective heat transfer medium 2";
 parameter Real bui.terUniCoo.hex.hA.r_nominal(min = 0) = bui.terUniCoo.hex.r_nominal "Ratio between air-side and water-side convective heat transfer coefficient";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.hA.hA_nominal_w(min = 0) = bui.terUniCoo.hex.hA.UA_nominal * (bui.terUniCoo.hex.hA.r_nominal + 1) / bui.terUniCoo.hex.hA.r_nominal "Water side convective heat transfer coefficient";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.hA.hA_nominal_a(min = 0) = bui.terUniCoo.hex.hA.r_nominal * bui.terUniCoo.hex.hA.hA_nominal_w "Air side convective heat transfer coefficient, including fin resistance";
 parameter Real bui.terUniCoo.hex.hA.n_w(min = 0,max = 1) = 0.85 "Water-side exponent for convective heat transfer coefficient, h~m_flow^n" /* 0.85 */;
 parameter Real bui.terUniCoo.hex.hA.n_a(min = 0,max = 1) = 0.8 "Air-side exponent for convective heat transfer coefficient, h~m_flow^n" /* 0.8 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.hex.hA.T0_w = Modelica.SIunits.Conversions.from_degC(20) "Water temperature" /* 293.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.hex.hA.T0_a = Modelica.SIunits.Conversions.from_degC(20) "Air temperature" /* 293.15 */;
 eval parameter Boolean bui.terUniCoo.hex.hA.waterSideFlowDependent = true "Set to false to make water-side hA independent of mass flow rate" /* true */;
 eval parameter Boolean bui.terUniCoo.hex.hA.airSideFlowDependent = true "Set to false to make air-side hA independent of mass flow rate" /* true */;
 eval parameter Boolean bui.terUniCoo.hex.hA.waterSideTemperatureDependent = false "Set to false to make water-side hA independent of temperature" /* false */;
 eval parameter Boolean bui.terUniCoo.hex.hA.airSideTemperatureDependent = false "Set to false to make air-side hA independent of temperature" /* false */;
 eval parameter Buildings.Fluid.Types.HeatExchangerConfiguration bui.terUniCoo.hex.configuration = Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow "Heat exchanger configuration" /* Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow */;
 eval parameter Boolean bui.terUniCoo.hex.use_Q_flow_nominal = true "Set to true to specify Q_flow_nominal and temperatures, or to false to specify effectiveness" /* true */;
 structural parameter Modelica.SIunits.HeatFlowRate bui.terUniCoo.hex.Q_flow_nominal = -146960.0 "Nominal heat transfer" /* -146960.0 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.hex.T_a1_nominal(fixed = true) = 287.15 "Nominal temperature at port a1" /* 287.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.hex.T_a2_nominal(fixed = true) = bui.terUniCoo.T_aLoaCoo_nominal "Nominal temperature at port a2";
 initial parameter Real bui.terUniCoo.hex.eps_nominal(fixed = not true) "Nominal heat transfer effectiveness";
 Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.UA = 1 / (1 / bui.terUniCoo.hex.hA.hA_1 + 1 / bui.terUniCoo.hex.hA.hA_2) "UA value";
 Real bui.terUniCoo.hex.eps(min = 0,max = 1) "Heat exchanger effectiveness";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.UA_nominal(fixed = false) "Nominal UA value";
 initial parameter Real bui.terUniCoo.hex.NTU_nominal(min = 0,fixed = false) "Nominal number of transfer units";
 Buildings.Media.Water.Temperature bui.terUniCoo.hex.T_in1(start = 293.15) = Buildings.Media.Water.temperature(bui.terUniCoo.hex.state_a1_inflow) "Inlet temperature medium 1";
 Buildings.Media.Air.Temperature bui.terUniCoo.hex.T_in2(start = 293.15) = Buildings.Media.Air.temperature(bui.terUniCoo.hex.state_a2_inflow) "Inlet temperature medium 2";
 Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.C1_flow = abs(bui.terUniCoo.hex.m1_flow) * Buildings.Media.Water.specificHeatCapacityCp(bui.terUniCoo.hex.state_a1_inflow) "Heat capacity flow rate medium 1";
 Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.C2_flow = abs(bui.terUniCoo.hex.m2_flow) * Buildings.Media.Air.specificHeatCapacityCp(bui.terUniCoo.hex.state_a2_inflow) "Heat capacity flow rate medium 2";
 Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.CMin_flow(min = 0) = min(bui.terUniCoo.hex.C1_flow, bui.terUniCoo.hex.C2_flow) "Minimum heat capacity flow rate";
 Modelica.SIunits.HeatFlowRate bui.terUniCoo.hex.QMax_flow = bui.terUniCoo.hex.CMin_flow * (bui.terUniCoo.hex.T_in2 - bui.terUniCoo.hex.T_in1) "Maximum heat flow rate into medium 1";
 constant Boolean bui.terUniCoo.hex.prescribedHeatFlowRate1 = true "Set to true if the heat flow rate into fluid 1 is not a function of the component temperature";
 constant Boolean bui.terUniCoo.hex.prescribedHeatFlowRate2 = true "Set to true if the heat flow rate into fluid 2 is not a function of the component temperature";
 constant Boolean bui.terUniCoo.hex.homotopyInitialization = true "= true, use homotopy method";
 Modelica.SIunits.HeatFlowRate bui.terUniCoo.hex.Q1_flow = bui.terUniCoo.hex.eps * bui.terUniCoo.hex.QMax_flow "Heat transferred into the medium 1";
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.mWat1_flow = 0 "Moisture mass flow rate added to the medium 1";
 Modelica.SIunits.HeatFlowRate bui.terUniCoo.hex.Q2_flow = - bui.terUniCoo.hex.Q1_flow "Heat transferred into the medium 2";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.mWat2_flow = 0 "Moisture mass flow rate added to the medium 2";
 constant Boolean bui.terUniCoo.hex.sensibleOnly1 = true "Set to true if sensible exchange only for medium 1";
 constant Boolean bui.terUniCoo.hex.sensibleOnly2 = true "Set to true if sensible exchange only for medium 2";
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.m1_flow_nominal(min = 0) = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.m2_flow_nominal = 14.485382537898948 "Nominal mass flow rate" /* 14.485382537898948 */;
 parameter Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.m1_flow_small(min = 0) = 1.0E-4 * abs(bui.terUniCoo.hex.m1_flow_nominal) "Small mass flow rate for regularization of zero flow";
 structural parameter Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.m2_flow_small = 0.0014485382537898948 "Small mass flow rate for regularization of zero flow" /* 0.0014485382537898948 */;
 structural parameter Boolean bui.terUniCoo.hex.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.m1_flow = bui.terUniCoo.hex.port_a1.m_flow "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniCoo.hex.dp1(displayUnit = "Pa") = bui.terUniCoo.hex.port_a1.p - bui.terUniCoo.hex.port_b1.p "Pressure difference between port_a1 and port_b1";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.m2_flow = bui.terUniCoo.hex.port_a2.m_flow "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniCoo.hex.dp2(displayUnit = "Pa") = bui.terUniCoo.hex.port_a2.p - bui.terUniCoo.hex.port_b2.p "Pressure difference between port_a2 and port_b2";
 eval parameter Boolean bui.terUniCoo.hex.allowFlowReversal1 = false "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1" /* false */;
 eval parameter Boolean bui.terUniCoo.hex.allowFlowReversal2 = false "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.port_a1.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.hex.port_a1.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.hex.port_a1.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.hex.port_a1.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.hex.port_a1.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.port_b1.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.hex.port_b1.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.hex.port_b1.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.hex.port_b1.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.hex.port_b1.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.port_a2.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.hex.port_a2.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.hex.port_a2.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.hex.port_a2.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.hex.port_a2.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.port_b2.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.hex.port_b2.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.hex.port_b2.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.hex.port_b2.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.hex.port_b2.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.terUniCoo.hex.computeFlowResistance1 = false "=true, compute flow resistance. Set to false to assume no friction" /* false */;
 eval parameter Boolean bui.terUniCoo.hex.from_dp1 = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.dp1_nominal = 0 "Pressure difference" /* 0 */;
 structural parameter Boolean bui.terUniCoo.hex.linearizeFlowResistance1 = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real bui.terUniCoo.hex.deltaM1 = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 eval parameter Boolean bui.terUniCoo.hex.computeFlowResistance2 = true "=true, compute flow resistance. Set to false to assume no friction" /* true */;
 eval parameter Boolean bui.terUniCoo.hex.from_dp2 = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.dp2_nominal = 200 "Pressure difference" /* 200 */;
 structural parameter Boolean bui.terUniCoo.hex.linearizeFlowResistance2 = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real bui.terUniCoo.hex.deltaM2 = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 parameter Real bui.terUniCoo.gaiMasFlo.k = 7.024856596558317 "Gain value multiplied with input signal" /* 7.024856596558317 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.gaiMasFlo.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.gaiMasFlo.y "Output signal connector";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.Q_flowCoo.y = bui.terUniCoo.hex.Q2_flow "Value of Real output";
 structural parameter Real bui.terUniCoo.gaiFloNom2.k = 14.485382537898948 "Gain value multiplied with input signal" /* 14.485382537898948 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.gaiFloNom2.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.gaiFloNom2.y "Output signal connector";
 eval parameter Boolean bui.terUniCoo.sinAir.use_p_in = false "Get the pressure from the input connector" /* false */;
 parameter Buildings.Media.Air.AbsolutePressure bui.terUniCoo.sinAir.p(start = 101325.0) = 101325.0 "Fixed value of pressure" /* 101325.0 */;
 eval parameter Boolean bui.terUniCoo.sinAir.use_T_in = false "Get the temperature from the input connector" /* false */;
 parameter Buildings.Media.Air.Temperature bui.terUniCoo.sinAir.T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 eval parameter Boolean bui.terUniCoo.sinAir.use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean bui.terUniCoo.sinAir.use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean bui.terUniCoo.sinAir.use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Air.MassFraction bui.terUniCoo.sinAir.X[2](final quantity = {"water", "air"}) = {0.01, 0.99} "Fixed value of composition" /* { 0.01, 0.99 } */;
 parameter Buildings.Media.Air.ExtraProperty bui.terUniCoo.sinAir.C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer bui.terUniCoo.sinAir.nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean bui.terUniCoo.sinAir.verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.sinAir.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.sinAir.ports[1].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.sinAir.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.sinAir.ports[1].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.sinAir.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.terUniCoo.retAir.use_p_in = false "Get the pressure from the input connector" /* false */;
 parameter Buildings.Media.Air.AbsolutePressure bui.terUniCoo.retAir.p(displayUnit = "Pa",start = 101325.0) = 101325.0 "Fixed value of pressure" /* 101325.0 */;
 eval parameter Boolean bui.terUniCoo.retAir.use_T_in = true "Get the temperature from the input connector" /* true */;
 parameter Buildings.Media.Air.Temperature bui.terUniCoo.retAir.T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.retAir.T_in(final unit = "K",displayUnit = "degC") "Prescribed boundary temperature";
 eval parameter Boolean bui.terUniCoo.retAir.use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean bui.terUniCoo.retAir.use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean bui.terUniCoo.retAir.use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Air.MassFraction bui.terUniCoo.retAir.X[2](final quantity = {"water", "air"}) = {0.01, 0.99} "Fixed value of composition" /* { 0.01, 0.99 } */;
 parameter Buildings.Media.Air.ExtraProperty bui.terUniCoo.retAir.C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer bui.terUniCoo.retAir.nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean bui.terUniCoo.retAir.verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.retAir.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.retAir.ports[1].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.retAir.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.retAir.ports[1].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.retAir.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.TLoaODE.TOutHea_nominal(displayUnit = "degC") = 273.15 - 5 "Outdoor air temperature at heating nominal conditions" /* 268.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.TLoaODE.TIndHea_nominal(displayUnit = "degC") = bui.terUniCoo.T_aLoaHea_nominal "Indoor air temperature at heating nominal conditions";
 structural parameter Modelica.SIunits.HeatFlowRate bui.terUniCoo.TLoaODE.QHea_flow_nominal = 167690.0 "Heating heat flow rate (for TInd=TIndHea_nominal, TOut=TOutHea_nominal,
    with no internal gains, no solar radiation)" /* 167690.0 */;
 eval parameter Boolean bui.terUniCoo.TLoaODE.steadyStateInitial = false "true initializes T with dT(0)/dt=0, false initializes T with T(0)=TIndHea_nominal" /* false */;
 parameter Modelica.SIunits.Time bui.terUniCoo.TLoaODE.tau(displayUnit = "h") = 1800 "Time constant of the indoor temperature" /* 1800 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.TLoaODE.TSet(final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC") "Temperature set point for heating or cooling";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.TLoaODE.QReq_flow(final quantity = "HeatFlowRate",final unit = "W") "Required heat flow rate to meet temperature set point (>=0 for heating)";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.TLoaODE.QAct_flow(final quantity = "HeatFlowRate",final unit = "W") "Actual heating or cooling heat flow rate (>=0 for heating)";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.TLoaODE.TAir(final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC") "Room air temperature";
 structural parameter Real bui.terUniCoo.gaiHeaFlo.k = -6.804572672836146E-6 "Gain value multiplied with input signal" /* -6.804572672836146E-6 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.gaiHeaFlo.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.gaiHeaFlo.y "Output signal connector";
 structural parameter Real bui.terUniCoo.gaiHeaFlo1.k = -6.804572672836146E-6 "Gain value multiplied with input signal" /* -6.804572672836146E-6 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.gaiHeaFlo1.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.gaiHeaFlo1.y "Output signal connector";
 eval parameter Boolean bui.terUniCoo.allowFlowReversal = false "Set to true to allow flow reversal on the source side" /* false */;
 eval parameter Boolean bui.terUniCoo.allowFlowReversalLoa = true "Set to true to allow flow reversal on the load side" /* true */;
 parameter Real bui.terUniCoo.facSca = 1 "Scaling factor to be applied to each extensive quantity" /* 1 */;
 eval parameter Boolean bui.terUniCoo.have_watHea = false "Set to true if the system has a heating water based heat exchanger" /* false */;
 eval parameter Boolean bui.terUniCoo.have_watCoo = true "Set to true if the system has a chilled water based heat exchanger" /* true */;
 eval parameter Boolean bui.terUniCoo.have_chaOve = false "Set to true if the chilled water based heat exchanger operates in change-over" /* false */;
 eval parameter Boolean bui.terUniCoo.have_eleHea = false "Set to true if the system has an electric heating equipment" /* false */;
 eval parameter Boolean bui.terUniCoo.have_eleCoo = false "Set to true if the system has an electric cooling equipment" /* false */;
 eval parameter Boolean bui.terUniCoo.have_heaPor = false "Set to true for heat ports on the load side" /* false */;
 eval parameter Boolean bui.terUniCoo.have_fluPor = false "Set to true for fluid ports on the load side" /* false */;
 eval parameter Boolean bui.terUniCoo.have_TSen = false "Set to true for measured temperature as an input" /* false */;
 eval parameter Boolean bui.terUniCoo.have_QReq_flow = true "Set to true for required heat flow rate as an input" /* true */;
 eval parameter Boolean bui.terUniCoo.have_weaBus = false "Set to true to enable the weather bus" /* false */;
 eval parameter Boolean bui.terUniCoo.have_fan = true "Set to true if the system has a fan" /* true */;
 eval parameter Boolean bui.terUniCoo.have_pum = false "Set to true if the system has a pump" /* false */;
 structural parameter Modelica.SIunits.HeatFlowRate bui.terUniCoo.QHea_flow_nominal = 167690.0 "Heat flow rate for water based heating at nominal conditions (>=0)" /* 167690.0 */;
 structural parameter Modelica.SIunits.HeatFlowRate bui.terUniCoo.QCoo_flow_nominal = -146960.0 "Heat flow rate for water based cooling at nominal conditions (<=0)" /* -146960.0 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.mHeaWat_flow_nominal(min = 0) = 0 "Heating water mass flow rate at nominal conditions" /* 0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.mChiWat_flow_nominal = 7.024856596558317 "Chilled water mass flow rate at nominal conditions" /* 7.024856596558317 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.mLoaHea_flow_nominal(min = 0) = 0 "Load side mass flow rate at nominal conditions in heating mode" /* 0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.mLoaCoo_flow_nominal = 14.485382537898948 "Load side mass flow rate at nominal conditions in cooling mode" /* 14.485382537898948 */;
 structural parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.T_aHeaWat_nominal = 313.15 "Heating water inlet temperature at nominal conditions" /* 313.15 */;
 structural parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.T_bHeaWat_nominal = 308.15 "Heating water outlet temperature at nominal conditions" /* 308.15 */;
 structural parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.T_aChiWat_nominal = 287.15 "Chilled water inlet temperature at nominal conditions " /* 287.15 */;
 structural parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.T_bChiWat_nominal = 292.15 "Chilled water outlet temperature at nominal conditions" /* 292.15 */;
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.T_aLoaHea_nominal(min = 273.15,displayUnit = "degC") = bui.T_aLoaHea_nominal "Load side inlet temperature at nominal conditions in heating mode";
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.T_aLoaCoo_nominal(min = 273.15,displayUnit = "degC") = bui.T_aLoaCoo_nominal "Load side inlet temperature at nominal conditions in cooling mode";
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Modelica.SIunits.Time bui.terUniCoo.tau = 1 "Time constant at nominal flow (if energyDynamics <> SteadyState)" /* 1 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.TSetCoo(final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC") "Cooling set point";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.QReqCoo_flow(final quantity = "HeatFlowRate",final unit = "W") "Required heat flow rate to meet cooling set point (<=0)";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.QActCoo_flow(final quantity = "HeatFlowRate",final unit = "W") "Cooling heat flow rate transferred to the load (<=0)";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.PFan(final quantity = "Power",final unit = "W") "Power drawn by fans motors";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.mReqChiWat_flow(final quantity = "MassFlowRate",final unit = "kg/s") "Required chilled water flow rate to meet cooling set point";
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.port_aChiWat.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.port_aChiWat.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.port_aChiWat.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.port_aChiWat.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.port_aChiWat.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.port_bChiWat.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.port_bChiWat.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.port_bChiWat.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.port_bChiWat.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.port_bChiWat.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Real bui.terUniCoo.scaQReqCoo_flow.k = 1 / bui.terUniCoo.facSca "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.scaQReqCoo_flow.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.scaQReqCoo_flow.y "Output signal connector";
 parameter Real bui.terUniCoo.scaQActCoo_flow.k = bui.terUniCoo.facSca "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.scaQActCoo_flow.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.scaQActCoo_flow.y "Output signal connector";
 parameter Real bui.terUniCoo.scaPFan.k = bui.terUniCoo.facSca "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.scaPFan.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.scaPFan.y "Output signal connector";
 parameter Real bui.terUniCoo.scaMasFloReqChiWat.k = bui.terUniCoo.facSca "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.scaMasFloReqChiWat.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.scaMasFloReqChiWat.y "Output signal connector";
 parameter Real bui.terUniCoo.scaChiWatFloInl.k = 1 / bui.terUniCoo.facSca "Gain for mass flow rate";
 eval parameter Boolean bui.terUniCoo.scaChiWatFloInl.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.scaChiWatFloInl.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.scaChiWatFloInl.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.scaChiWatFloInl.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.scaChiWatFloInl.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.scaChiWatFloInl.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.scaChiWatFloInl.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.scaChiWatFloInl.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.scaChiWatFloInl.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.scaChiWatFloInl.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.scaChiWatFloInl.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Real bui.terUniCoo.scaChiWatFloOut.k = bui.terUniCoo.facSca "Gain for mass flow rate";
 eval parameter Boolean bui.terUniCoo.scaChiWatFloOut.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.scaChiWatFloOut.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.scaChiWatFloOut.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.scaChiWatFloOut.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.scaChiWatFloOut.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.scaChiWatFloOut.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.scaChiWatFloOut.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.scaChiWatFloOut.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.scaChiWatFloOut.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.scaChiWatFloOut.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.scaChiWatFloOut.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 parameter Real bui.minTSet.k = 20 + 273.15 "Constant output value" /* 293.15 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.minTSet.y(unit = "K",displayUnit = "degC") "Connector of Real output signal";
 parameter Real bui.maxTSet.k = 24 + 273.15 "Constant output value" /* 297.15 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.maxTSet.y(unit = "K",displayUnit = "degC") "Connector of Real output signal";
 eval parameter Integer bui.nPorts_aHea = 1 "Number of inlet fluid ports on source side" /* 1 */;
 eval parameter Integer bui.nPorts_bHea = 1 "Number of outlet fluid ports on source side" /* 1 */;
 eval parameter Integer bui.nPorts_aCoo = 1 "Number of inlet fluid ports on source side" /* 1 */;
 eval parameter Integer bui.nPorts_bCoo = 1 "Number of outlet fluid ports on source side" /* 1 */;
 eval parameter Boolean bui.have_heaLoa = true "Set to true if the building has heating loads" /* true */;
 eval parameter Boolean bui.have_cooLoa = true "Set to true if the building has cooling loads" /* true */;
 eval parameter Boolean bui.have_fan = false "Set to true if the power drawn by fan motors is computed" /* false */;
 eval parameter Boolean bui.have_pum = false "Set to true if the power drawn by pump motors is computed" /* false */;
 eval parameter Boolean bui.have_eleHea = false "Set to true if the building has decentralized electric heating equipment" /* false */;
 eval parameter Boolean bui.have_eleCoo = false "Set to true if the building has decentralized electric cooling equipment" /* false */;
 eval parameter Boolean bui.have_weaBus = false "Set to true for weather bus" /* false */;
 eval parameter Boolean bui.allowFlowReversal = false "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)" /* false */;
 Buildings.Media.Water.MassFlowRate bui.secHeaSup[1].m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.secHeaSup[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.secHeaSup[1].h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.secHeaSup[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.secHeaSup[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.secHeaRet[1].m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.secHeaRet[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.secHeaRet[1].h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.secHeaRet[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.secHeaRet[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.secCooSup[1].m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.secCooSup[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.secCooSup[1].h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.secCooSup[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.secCooSup[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.secCooRet[1].m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.secCooRet[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.secCooRet[1].h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.secCooRet[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.secCooRet[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput bui.QHea_flow(final quantity = "HeatFlowRate",final unit = "W") "Total heating heat flow rate transferred to the loads (>=0)";
 Modelica.Blocks.Interfaces.RealOutput bui.QCoo_flow(final quantity = "HeatFlowRate",final unit = "W") "Total cooling heat flow rate transferred to the loads (<=0)";
 eval parameter Boolean supChiWat.use_m_flow_in = true "Get the mass flow rate from the input connector" /* true */;
 parameter Modelica.SIunits.MassFlowRate supChiWat.m_flow = 0 "Fixed mass flow rate going out of the fluid port" /* 0 */;
 eval parameter Boolean supChiWat.use_T_in = false "Get the temperature from the input connector" /* false */;
 parameter Buildings.Media.Water.Temperature supChiWat.T(start = 293.15) = 281.15 "Fixed value of temperature" /* 281.15 */;
 Modelica.Blocks.Interfaces.RealInput supChiWat.m_flow_in(final unit = "kg/s") "Prescribed mass flow rate";
 eval parameter Boolean supChiWat.use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean supChiWat.use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean supChiWat.use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Water.MassFraction supChiWat.X[1](final quantity = {"SimpleLiquidWater"}) = {1.0} "Fixed value of composition" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty supChiWat.C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer supChiWat.nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean supChiWat.verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Water.MassFlowRate supChiWat.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure supChiWat.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy supChiWat.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction supChiWat.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty supChiWat.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean supHeaWat.use_m_flow_in = false "Get the mass flow rate from the input connector" /* false */;
 structural parameter Modelica.SIunits.MassFlowRate supHeaWat.m_flow = 8.015774378585085 "Fixed mass flow rate going out of the fluid port" /* 8.015774378585085 */;
 eval parameter Boolean supHeaWat.use_T_in = true "Get the temperature from the input connector" /* true */;
 parameter Buildings.Media.Water.Temperature supHeaWat.T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 Modelica.Blocks.Interfaces.RealInput supHeaWat.T_in(final unit = "K",displayUnit = "degC") "Prescribed boundary temperature";
 eval parameter Boolean supHeaWat.use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean supHeaWat.use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean supHeaWat.use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Water.MassFraction supHeaWat.X[1](final quantity = {"SimpleLiquidWater"}) = {1.0} "Fixed value of composition" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty supHeaWat.C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer supHeaWat.nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean supHeaWat.verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Water.MassFlowRate supHeaWat.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure supHeaWat.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy supHeaWat.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction supHeaWat.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty supHeaWat.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean sinChiWat.use_p_in = false "Get the pressure from the input connector" /* false */;
 parameter Buildings.Media.Water.AbsolutePressure sinChiWat.p(start = 300000.0) = 300000.0 "Fixed value of pressure" /* 300000.0 */;
 eval parameter Boolean sinChiWat.use_T_in = false "Get the temperature from the input connector" /* false */;
 parameter Buildings.Media.Water.Temperature sinChiWat.T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 eval parameter Boolean sinChiWat.use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean sinChiWat.use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean sinChiWat.use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Water.MassFraction sinChiWat.X[1](final quantity = {"SimpleLiquidWater"}) = {1.0} "Fixed value of composition" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty sinChiWat.C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer sinChiWat.nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean sinChiWat.verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Water.MassFlowRate sinChiWat.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure sinChiWat.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy sinChiWat.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction sinChiWat.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty sinChiWat.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput TChiWatSet.y = 14 + 273.15 "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput THeaWatSup.y = 313.15 "Value of Real output";
 eval parameter Boolean sinHeaWat.use_p_in = false "Get the pressure from the input connector" /* false */;
 parameter Buildings.Media.Water.AbsolutePressure sinHeaWat.p(start = 300000.0) = 300000.0 "Fixed value of pressure" /* 300000.0 */;
 eval parameter Boolean sinHeaWat.use_T_in = false "Get the temperature from the input connector" /* false */;
 parameter Buildings.Media.Water.Temperature sinHeaWat.T(start = 293.15) = 293.15 "Fixed value of temperature" /* 293.15 */;
 eval parameter Boolean sinHeaWat.use_X_in = false "Get the composition (all fractions) from the input connector" /* false */;
 eval parameter Boolean sinHeaWat.use_Xi_in = false "Get the composition (independent fractions) from the input connector" /* false */;
 eval parameter Boolean sinHeaWat.use_C_in = false "Get the trace substances from the input connector" /* false */;
 parameter Buildings.Media.Water.MassFraction sinHeaWat.X[1](final quantity = {"SimpleLiquidWater"}) = {1.0} "Fixed value of composition" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty sinHeaWat.C[0](final quantity = fill("", 0)) = fill(0, 0) "Fixed values of trace substances" /* (zero-size array) */;
 structural parameter Integer sinHeaWat.nPorts = 1 "Number of ports" /* 1 */;
 eval parameter Boolean sinHeaWat.verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range" /* false */;
 Buildings.Media.Water.MassFlowRate sinHeaWat.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure sinHeaWat.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy sinHeaWat.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction sinHeaWat.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty sinHeaWat.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput secMasFloRat.y = 2 * bui.disFloCoo.mReqTot_flow "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput priMasFloRat.y = bui.disFloCoo.mReqTot_flow .* (bui.delTBuiCoo / delTDisCoo) "Value of Real output";
 structural parameter Modelica.SIunits.Pressure pumBui.dp_nominal = 150000 "Nominal pressure raise, used for default pressure curve if not specified in record per" /* 150000 */;
 parameter Modelica.SIunits.MassFlowRate pumBui.m_flow_start(min = 0) = 0 "Initial value of mass flow rate" /* 0 */;
 structural parameter Modelica.SIunits.MassFlowRate pumBui.constantMassFlowRate = 7.024856596558317 "Constant pump mass flow rate, used when inputType=Constant" /* 7.024856596558317 */;
 parameter Modelica.SIunits.MassFlowRate pumBui.massFlowRates[1] = 7.024856596558317 * {pumBui.per.speeds[1] / pumBui.per.speeds[1]} "Vector of mass flow rate set points, used when inputType=Stage";
 Modelica.Blocks.Interfaces.RealInput pumBui.m_flow_in(final unit = "kg/s",nominal = 7.024856596558317) "Prescribed mass flow rate";
 Modelica.Blocks.Interfaces.RealOutput pumBui.m_flow_actual(final unit = "kg/s",nominal = 7.024856596558317) "Actual mass flow rate";
 parameter Buildings.Fluid.Movers.Data.Generic pumBui.per(pressure(V_flow(size() = {2}),dp(size() = {2})) = Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters({0, 0}, {0, 0}),use_powerCharacteristic = false,hydraulicEfficiency(V_flow(size() = {1},each min = 0) = {0},eta(size() = {1},each max = 1) = {0.7}),motorEfficiency(V_flow(size() = {1},each min = 0) = {0},eta(size() = {1},each max = 1) = {0.7}),power(V_flow(size() = {1},each min = 0) = {0},P(size() = {1},each min = 0) = {0}),motorCooledByFluid = true,speed_nominal(final min = 0,final unit = "1") = 1,constantSpeed(final min = 0,final unit = "1") = pumBui.per.constantSpeed_rpm / pumBui.per.speed_rpm_nominal,speeds(size() = {1},each final min = 0,each final unit = "1") = pumBui.per.speeds_rpm[1:1] / pumBui.per.speed_rpm_nominal,speed_rpm_nominal = 1500,constantSpeed_rpm = pumBui.per.speed_rpm_nominal,speeds_rpm(size() = {1}) = {pumBui.per.speed_rpm_nominal},havePressureCurve = false) "Record with performance data";
 structural parameter Buildings.Fluid.Types.InputType pumBui.inputType = Buildings.Fluid.Types.InputType.Continuous "Control input type" /* Buildings.Fluid.Types.InputType.Continuous */;
 structural parameter Real pumBui.constInput = 7.024856596558317 "Constant input set point" /* 7.024856596558317 */;
 parameter Real pumBui.stageInputs[1](each final unit = "kg/s") = pumBui.massFlowRates[1:1] "Vector of input set points corresponding to stages";
 structural parameter Boolean pumBui.computePowerUsingSimilarityLaws = false "= true, compute power exactly, using similarity laws. Otherwise approximate." /* false */;
 structural parameter Boolean pumBui.addPowerToMedium = true "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations)" /* true */;
 parameter Boolean pumBui.nominalValuesDefineDefaultPressureCurve = true "Set to true to avoid warning if m_flow_nominal and dp_nominal are used to construct the default pressure curve" /* true */;
 parameter Modelica.SIunits.Time pumBui.tau = 1 "Time constant of fluid volume for nominal flow, used if energy or mass balance is dynamic" /* 1 */;
 structural parameter Boolean pumBui.use_inputFilter = false "= true, if speed is filtered with a 2nd order CriticalDamping filter" /* false */;
 parameter Modelica.SIunits.Time pumBui.riseTime = 30 "Rise time of the filter (time to reach 99.6 % of the speed)" /* 30 */;
 parameter Modelica.Blocks.Types.Init pumBui.init = Modelica.Blocks.Types.Init.InitialOutput "Type of initialization (no init/steady state/initial state/initial output)" /* Modelica.Blocks.Types.Init.InitialOutput */;
 parameter Real pumBui.y_start(min = 0,max = 1,unit = "1") = 0 "Initial value of speed" /* 0 */;
 Modelica.Blocks.Interfaces.RealOutput pumBui.y_actual(final unit = "1") "Actual normalised pump speed that is used for computations";
 Modelica.Blocks.Interfaces.RealOutput pumBui.P(quantity = "Power",final unit = "W") "Electrical power consumed";
 Modelica.SIunits.ThermodynamicTemperature pumBui.heatPort.T "Port temperature";
 Modelica.SIunits.HeatFlowRate pumBui.heatPort.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.SIunits.VolumeFlowRate pumBui.VMachine_flow(start = 0.0) = pumBui.eff.V_flow "Volume flow rate";
 Modelica.SIunits.Pressure pumBui.dpMachine(displayUnit = "Pa") = - pumBui.preSou.dp "Pressure difference";
 Real pumBui.eta(unit = "1",final quantity = "Efficiency") = pumBui.eff.eta "Global efficiency";
 Real pumBui.etaHyd(unit = "1",final quantity = "Efficiency") = pumBui.eff.etaHyd "Hydraulic efficiency";
 Real pumBui.etaMot(unit = "1",final quantity = "Efficiency") = pumBui.eff.etaMot "Motor efficiency";
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Water.AbsolutePressure pumBui.p_start(start = 300000.0) = 300000.0 "Start value of pressure" /* 300000.0 */;
 parameter Buildings.Media.Water.Temperature pumBui.T_start(start = 293.15) = 293.15 "Start value of temperature" /* 293.15 */;
 parameter Buildings.Media.Water.MassFraction pumBui.X_start[1](quantity = {"SimpleLiquidWater"}) = {1.0} "Start value of mass fractions m_i/m" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty pumBui.C_start[0](quantity = fill("", 0)) = fill(0, 0) "Start value of trace substances" /* (zero-size array) */;
 parameter Buildings.Media.Water.ExtraProperty pumBui.C_nominal[0](quantity = fill("", 0)) = fill(0.01, 0) "Nominal value of trace substances. (Set to typical order of magnitude.)" /* (zero-size array) */;
 final parameter Real pumBui.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 structural parameter Modelica.SIunits.MassFlowRate pumBui.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.MassFlowRate pumBui.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 structural parameter Boolean pumBui.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate pumBui.m_flow(start = 0.0) = pumBui.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure pumBui.dp(start = 0.0,displayUnit = "Pa") = pumBui.port_a.p - pumBui.port_b.p "Pressure difference between port_a and port_b";
 eval parameter Boolean pumBui.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate pumBui.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.port_a.h_outflow(start = pumBui.h_outflow_start,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate pumBui.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.port_b.p(start = pumBui.p_start) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.port_b.h_outflow(start = pumBui.h_outflow_start,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean pre.use_p = true "select p or d" /* true */;
 parameter Buildings.Media.Water.AbsolutePressure pre.p(start = 300000.0) = 300000.0 "Boundary pressure" /* 300000.0 */;
 structural parameter Buildings.Media.Water.Density pre.d = 995.586 "Boundary density" /* 995.586 */;
 eval parameter Boolean pre.use_T = false "select T or h" /* false */;
 parameter Buildings.Media.Water.Temperature pre.T(start = 293.15) = 293.15 "Boundary temperature" /* 293.15 */;
 parameter Buildings.Media.Water.SpecificEnthalpy pre.h = 83680.0 "Boundary specific enthalpy" /* 83680.0 */;
 parameter Buildings.Media.Water.MassFraction pre.X[1](quantity = {"SimpleLiquidWater"}) = {1.0} "Boundary mass fractions m_i/m" /* { 1.0 } */;
 parameter Buildings.Media.Water.ExtraProperty pre.C[0](quantity = fill("", 0)) = fill(0, 0) "Boundary trace substances" /* (zero-size array) */;
 structural parameter Integer pre.nPorts = 1 "Number of ports" /* 1 */;
 Buildings.Media.Water.Temperature pre.medium.T(stateSelect = StateSelect.default,start = 293.15) "Temperature of medium";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pre.medium.InputAbsolutePressure pre.medium.p "Absolute pressure of medium";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pre.medium.InputMassFraction pre.medium.Xi[0] = fill(0, 0) "Structurally independent mass fractions";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pre.medium.InputSpecificEnthalpy pre.medium.h "Specific enthalpy of medium";
 Modelica.SIunits.SpecificEnergy pre.medium.u "Specific internal energy of medium";
 Modelica.SIunits.Density pre.medium.d = 995.586 "Density of medium";
 Modelica.SIunits.MassFraction pre.medium.X[1] = {1} "Mass fractions (= (component mass)/total mass  m_i/m)";
 Modelica.SIunits.SpecificHeatCapacity pre.medium.R = 0 "Gas constant (of mixture if applicable)";
 Modelica.SIunits.MolarMass pre.medium.MM = 0.018015268 "Molar mass (of mixture or single fluid)";
 Buildings.Media.Water.ThermodynamicState pre.medium.state(p(start = 300000.0),T(start = 293.15)) "Thermodynamic state record for optional functions";
 eval parameter Boolean pre.medium.preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium" /* false */;
 final parameter Boolean pre.medium.standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones" /* true */;
 Modelica.SIunits.Conversions.NonSIunits.Temperature_degC pre.medium.T_degC = Modelica.SIunits.Conversions.to_degC(pre.medium.T) "Temperature of medium in [degC]";
 Modelica.SIunits.Conversions.NonSIunits.Pressure_bar pre.medium.p_bar = Modelica.SIunits.Conversions.to_bar(pre.medium.p) "Absolute pressure of medium in [bar]";
 Buildings.Media.Water.MassFlowRate pre.ports[1].m_flow(each max = 1.0E60,each min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pre.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pre.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pre.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pre.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
protected
 initial parameter Modelica.SIunits.ThermalConductance coo.hex.hA1_nominal(min = 0) = 2 * coo.hex.UA_nominal "Nominal convective heat transfer coefficient for medium 1";
 initial parameter Modelica.SIunits.ThermalConductance coo.hex.hA2_nominal(min = 0) = 2 * coo.hex.UA_nominal "Nominal convective heat transfer coefficient for medium 2";
 parameter Real coo.hex.n1(min = 0,max = 1) = 0.8 "Exponent for convective heat transfer coefficient, h1~m1_flow^n1" /* 0.8 */;
 parameter Real coo.hex.n2(min = 0,max = 1) = 0.8 "Exponent for convective heat transfer coefficient, h2~m2_flow^n2" /* 0.8 */;
 Modelica.SIunits.ThermalConductance coo.hex.hA1 "Convective heat transfer coefficient for medium 1";
 Modelica.SIunits.ThermalConductance coo.hex.hA2 "Convective heat transfer coefficient for medium 2";
 parameter Buildings.Media.Water.ThermodynamicState coo.hex.sta1_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Default state for medium 1";
 parameter Buildings.Media.Water.ThermodynamicState coo.hex.sta2_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Default state for medium 2";
 initial parameter Modelica.SIunits.SpecificHeatCapacity coo.hex.cp1_nominal(fixed = false) "Specific heat capacity of medium 1 at nominal condition";
 initial parameter Modelica.SIunits.SpecificHeatCapacity coo.hex.cp2_nominal(fixed = false) "Specific heat capacity of medium 2 at nominal condition";
 initial parameter Modelica.SIunits.ThermalConductance coo.hex.C1_flow_nominal(fixed = false) "Nominal capacity flow rate of Medium 1";
 initial parameter Modelica.SIunits.ThermalConductance coo.hex.C2_flow_nominal(fixed = false) "Nominal capacity flow rate of Medium 2";
 initial parameter Modelica.SIunits.ThermalConductance coo.hex.CMin_flow_nominal(fixed = false) "Minimal capacity flow rate at nominal condition";
 initial parameter Modelica.SIunits.ThermalConductance coo.hex.CMax_flow_nominal(fixed = false) "Maximum capacity flow rate at nominal condition";
 initial parameter Real coo.hex.Z_nominal(min = 0,max = 1,fixed = false) "Ratio of capacity flow rate at nominal condition";
 initial parameter Modelica.SIunits.ThermodynamicTemperature coo.hex.T_b1_nominal(fixed = false) "Nominal temperature at port b1";
 initial parameter Modelica.SIunits.ThermodynamicTemperature coo.hex.T_b2_nominal(fixed = false) "Nominal temperature at port b2";
 initial parameter Buildings.Fluid.Types.HeatExchangerFlowRegime coo.hex.flowRegime_nominal(fixed = false) "Heat exchanger flow regime at nominal flow rates";
 discrete Buildings.Fluid.Types.HeatExchangerFlowRegime coo.hex.flowRegime(fixed = false,start = coo.hex.flowRegime_nominal) "Heat exchanger flow regime";
 parameter Real coo.hex.delta = 0.001 "Parameter used for smoothing" /* 0.001 */;
 initial parameter Modelica.SIunits.SpecificHeatCapacity coo.hex.cp1_default(fixed = false) "Specific heat capacity of medium 1 at default medium state";
 initial parameter Modelica.SIunits.SpecificHeatCapacity coo.hex.cp2_default(fixed = false) "Specific heat capacity of medium 2 at default medium state";
 initial parameter Modelica.SIunits.ThermalConductance coo.hex.CMin_flow_small(fixed = false) "Small value for smoothing of minimum heat capacity flow rate";
 Real coo.hex.fra_a1(min = 0,max = 1) = Modelica.Fluid.Utilities.regStep(coo.hex.m1_flow, 1, 0, coo.hex.m1_flow_small) "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
 Real coo.hex.fra_b1(min = 0,max = 1) = 1 - coo.hex.fra_a1 "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
 Real coo.hex.fra_a2(min = 0,max = 1) = Modelica.Fluid.Utilities.regStep(coo.hex.m2_flow, 1, 0, 7.024856596558318E-4) "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
 Real coo.hex.fra_b2(min = 0,max = 1) = 1 - coo.hex.fra_a2 "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
 constant Boolean coo.hex.bal1.sensibleOnly = true "Set to true if sensible exchange only";
 constant Boolean coo.hex.bal1.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of the component temperature";
 constant Boolean coo.hex.bal1.homotopyInitialization = true "= true, use homotopy method";
 Modelica.SIunits.HeatFlowRate coo.hex.bal1.Q_flow = coo.hex.Q1_flow "Heat transferred into the medium";
 Modelica.SIunits.MassFlowRate coo.hex.bal1.mWat_flow = coo.hex.mWat1_flow "Moisture mass flow rate added to the medium";
 constant Boolean coo.hex.bal1.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 constant Boolean coo.hex.bal1.vol.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";
 eval parameter Boolean coo.hex.bal1.vol.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean coo.hex.bal1.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput coo.hex.bal1.vol.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal1.vol.hOut(unit = "J/kg",start = Buildings.Media.Water.specificEnthalpy_pTX(300000.0, 293.15, {1.0})) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal1.vol.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal1.vol.COut[0](each min = 0) "Leaving trace substances of the component";
 eval parameter Boolean coo.hex.bal1.vol.use_m_flowInv = true "Flag, true if m_flowInv is used in the model" /* true */;
 final parameter Real coo.hex.bal1.vol.s[0] = {} "Vector with zero everywhere except where species is" /* (zero-size array) */;
 Real coo.hex.bal1.vol.m_flowInv(unit = "s/kg") "Regularization of 1/m_flow of port_a";
 Modelica.SIunits.MassFlowRate coo.hex.bal1.vol.mXi_flow[0] "Mass flow rates of independent substances added to the medium";
 parameter Real coo.hex.bal1.vol.deltaReg = coo.hex.bal1.vol.m_flow_small / 1000.0 "Smoothing region for inverseXRegularized";
 parameter Real coo.hex.bal1.vol.deltaInvReg = 1 / coo.hex.bal1.vol.deltaReg "Inverse value of delta for inverseXRegularized";
 parameter Real coo.hex.bal1.vol.aReg = -15 * coo.hex.bal1.vol.deltaInvReg "Polynomial coefficient for inverseXRegularized";
 parameter Real coo.hex.bal1.vol.bReg = 119 * coo.hex.bal1.vol.deltaInvReg ^ 2 "Polynomial coefficient for inverseXRegularized";
 parameter Real coo.hex.bal1.vol.cReg = -361 * coo.hex.bal1.vol.deltaInvReg ^ 3 "Polynomial coefficient for inverseXRegularized";
 parameter Real coo.hex.bal1.vol.dReg = 534 * coo.hex.bal1.vol.deltaInvReg ^ 4 "Polynomial coefficient for inverseXRegularized";
 parameter Real coo.hex.bal1.vol.eReg = -380 * coo.hex.bal1.vol.deltaInvReg ^ 5 "Polynomial coefficient for inverseXRegularized";
 parameter Real coo.hex.bal1.vol.fReg = 104 * coo.hex.bal1.vol.deltaInvReg ^ 6 "Polynomial coefficient for inverseXRegularized";
 parameter Buildings.Media.Water.ThermodynamicState coo.hex.bal1.vol.state_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Medium state at default values";
 parameter Modelica.SIunits.SpecificHeatCapacity coo.hex.bal1.vol.cp_default = Buildings.Media.Water.specificHeatCapacityCp(coo.hex.bal1.vol.state_default) "Specific heat capacity, used to verify energy conservation";
 constant Modelica.SIunits.TemperatureDifference coo.hex.bal1.vol.dTMax = 200 "Maximum temperature difference across the StaticTwoPortConservationEquation" annotation(absoluteValue = false);
 Modelica.Blocks.Interfaces.RealInput coo.hex.bal1.vol.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput coo.hex.bal1.vol.C_flow_internal[0] "Needed to connect to conditional connector";
 parameter Modelica.SIunits.MassFlowRate coo.hex.bal1.vol.m_flow_nominal = coo.hex.bal1.m_flow_nominal "Nominal mass flow rate";
 parameter Modelica.SIunits.MassFlowRate coo.hex.bal1.vol.m_flow_small(min = 0) = coo.hex.bal1.m_flow_small "Small mass flow rate for regularization of zero flow";
 structural parameter Boolean coo.hex.bal1.vol.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate coo.hex.bal1.vol.m_flow(start = 0.0) = coo.hex.bal1.vol.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure coo.hex.bal1.vol.dp(start = 0.0,displayUnit = "Pa") = coo.hex.bal1.vol.port_a.p - coo.hex.bal1.vol.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate coo.hex.bal1.vol._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure coo.hex.bal1.vol._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean coo.hex.bal1.vol.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.hex.bal1.vol.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal1.vol.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal1.vol.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal1.vol.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal1.vol.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.hex.bal1.vol.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal1.vol.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal1.vol.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal1.vol.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal1.vol.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Real coo.hex.bal1.preDro.deltaM = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs" /* 0.1 */;
 parameter Real coo.hex.bal1.preDro.k = if 500.0 > 1.0E-15 then coo.hex.bal1.preDro.m_flow_nominal_pos / sqrt(500.0) else 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
 eval parameter Boolean coo.hex.bal1.preDro.computeFlowResistance = true "Flag to enable/disable computation of flow resistance" /* true */;
 parameter Real coo.hex.bal1.preDro.coeff = 0 "Precomputed coefficient to avoid division by parameter" /* 0 */;
 constant Boolean coo.hex.bal1.preDro.homotopyInitialization = true "= true, use homotopy method";
 eval parameter Boolean coo.hex.bal1.preDro.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure coo.hex.bal1.preDro.dp_nominal = 500 "Pressure drop at nominal mass flow rate" /* 500 */;
 eval parameter Boolean coo.hex.bal1.preDro.linearized = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 parameter Modelica.SIunits.MassFlowRate coo.hex.bal1.preDro.m_flow_turbulent(min = 0) = 0.1 * coo.hex.bal1.preDro.m_flow_nominal_pos "Turbulent flow if |m_flow| >= m_flow_turbulent";
 parameter Buildings.Media.Water.ThermodynamicState coo.hex.bal1.preDro.sta_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0});
 parameter Modelica.SIunits.DynamicViscosity coo.hex.bal1.preDro.eta_default = Buildings.Media.Water.dynamicViscosity(coo.hex.bal1.preDro.sta_default) "Dynamic viscosity, used to compute transition to turbulent flow regime";
 parameter Modelica.SIunits.MassFlowRate coo.hex.bal1.preDro.m_flow_nominal_pos = abs(coo.hex.bal1.preDro.m_flow_nominal) "Absolute value of nominal flow rate";
 structural parameter Modelica.SIunits.Pressure coo.hex.bal1.preDro.dp_nominal_pos = 500.0 "Absolute value of nominal pressure difference" /* 500.0 */;
 parameter Modelica.SIunits.MassFlowRate coo.hex.bal1.preDro.m_flow_nominal = coo.hex.bal1.m_flow_nominal "Nominal mass flow rate";
 parameter Modelica.SIunits.MassFlowRate coo.hex.bal1.preDro.m_flow_small(min = 0) = 1.0E-4 * abs(coo.hex.bal1.preDro.m_flow_nominal) "Small mass flow rate for regularization of zero flow";
 structural parameter Boolean coo.hex.bal1.preDro.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate coo.hex.bal1.preDro.m_flow(nominal = if coo.hex.bal1.preDro.m_flow_nominal_pos > 1.0E-15 then coo.hex.bal1.preDro.m_flow_nominal_pos else 1,start = 0.0) = coo.hex.bal1.preDro.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure coo.hex.bal1.preDro.dp(nominal = 500.0,start = 0.0,displayUnit = "Pa") = coo.hex.bal1.preDro.port_a.p - coo.hex.bal1.preDro.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate coo.hex.bal1.preDro._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure coo.hex.bal1.preDro._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean coo.hex.bal1.preDro.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.hex.bal1.preDro.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal1.preDro.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal1.preDro.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal1.preDro.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal1.preDro.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.hex.bal1.preDro.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal1.preDro.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal1.preDro.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal1.preDro.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal1.preDro.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal1.hOut(unit = "J/kg") "Leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal1.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal1.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal1.heaInp.y = coo.hex.bal1.Q_flow "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal1.masExc.y = coo.hex.bal1.mWat_flow "Value of Real output";
 parameter Modelica.SIunits.MassFlowRate coo.hex.bal1.m_flow_nominal = coo.hex.m1_flow_nominal "Nominal mass flow rate";
 parameter Modelica.SIunits.MassFlowRate coo.hex.bal1.m_flow_small(min = 0) = coo.hex.m1_flow_small "Small mass flow rate for regularization of zero flow";
 structural parameter Boolean coo.hex.bal1.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate coo.hex.bal1.m_flow(start = 0.0) = coo.hex.bal1.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure coo.hex.bal1.dp(start = 0.0,displayUnit = "Pa") = coo.hex.bal1.port_a.p - coo.hex.bal1.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate coo.hex.bal1._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure coo.hex.bal1._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean coo.hex.bal1.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.hex.bal1.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal1.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal1.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal1.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal1.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.hex.bal1.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal1.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal1.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal1.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal1.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean coo.hex.bal1.computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction" /* true */;
 eval parameter Boolean coo.hex.bal1.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure coo.hex.bal1.dp_nominal = 500 "Pressure difference" /* 500 */;
 structural parameter Boolean coo.hex.bal1.linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real coo.hex.bal1.deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 constant Boolean coo.hex.bal2.sensibleOnly = true "Set to true if sensible exchange only";
 constant Boolean coo.hex.bal2.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of the component temperature";
 constant Boolean coo.hex.bal2.homotopyInitialization = true "= true, use homotopy method";
 Modelica.SIunits.HeatFlowRate coo.hex.bal2.Q_flow = coo.hex.Q2_flow "Heat transferred into the medium";
 Modelica.SIunits.MassFlowRate coo.hex.bal2.mWat_flow = coo.hex.mWat2_flow "Moisture mass flow rate added to the medium";
 constant Boolean coo.hex.bal2.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 constant Boolean coo.hex.bal2.vol.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";
 eval parameter Boolean coo.hex.bal2.vol.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean coo.hex.bal2.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput coo.hex.bal2.vol.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal2.vol.hOut(unit = "J/kg",start = Buildings.Media.Water.specificEnthalpy_pTX(300000.0, 293.15, {1.0})) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal2.vol.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal2.vol.COut[0](each min = 0) "Leaving trace substances of the component";
 eval parameter Boolean coo.hex.bal2.vol.use_m_flowInv = true "Flag, true if m_flowInv is used in the model" /* true */;
 final parameter Real coo.hex.bal2.vol.s[0] = {} "Vector with zero everywhere except where species is" /* (zero-size array) */;
 Real coo.hex.bal2.vol.m_flowInv(unit = "s/kg") "Regularization of 1/m_flow of port_a";
 Modelica.SIunits.MassFlowRate coo.hex.bal2.vol.mXi_flow[0] "Mass flow rates of independent substances added to the medium";
 structural parameter Real coo.hex.bal2.vol.deltaReg = 7.024856596558318E-7 "Smoothing region for inverseXRegularized" /* 7.024856596558318E-7 */;
 structural parameter Real coo.hex.bal2.vol.deltaInvReg = 1423516.6031573217 "Inverse value of delta for inverseXRegularized" /* 1423516.6031573217 */;
 structural parameter Real coo.hex.bal2.vol.aReg = -2.1352749047359824E7 "Polynomial coefficient for inverseXRegularized" /* -2.1352749047359824E7 */;
 structural parameter Real coo.hex.bal2.vol.bReg = 2.411415428162826E14 "Polynomial coefficient for inverseXRegularized" /* 2.411415428162826E14 */;
 structural parameter Real coo.hex.bal2.vol.cReg = -1.0413454231722027E21 "Polynomial coefficient for inverseXRegularized" /* -1.0413454231722027E21 */;
 structural parameter Real coo.hex.bal2.vol.dReg = 2.19276153666763E27 "Polynomial coefficient for inverseXRegularized" /* 2.19276153666763E27 */;
 structural parameter Real coo.hex.bal2.vol.eReg = -2.221244068539758E33 "Polynomial coefficient for inverseXRegularized" /* -2.221244068539758E33 */;
 structural parameter Real coo.hex.bal2.vol.fReg = 8.65383400968502E38 "Polynomial coefficient for inverseXRegularized" /* 8.65383400968502E38 */;
 parameter Buildings.Media.Water.ThermodynamicState coo.hex.bal2.vol.state_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Medium state at default values";
 parameter Modelica.SIunits.SpecificHeatCapacity coo.hex.bal2.vol.cp_default = Buildings.Media.Water.specificHeatCapacityCp(coo.hex.bal2.vol.state_default) "Specific heat capacity, used to verify energy conservation";
 constant Modelica.SIunits.TemperatureDifference coo.hex.bal2.vol.dTMax = 200 "Maximum temperature difference across the StaticTwoPortConservationEquation" annotation(absoluteValue = false);
 Modelica.Blocks.Interfaces.RealInput coo.hex.bal2.vol.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput coo.hex.bal2.vol.C_flow_internal[0] "Needed to connect to conditional connector";
 structural parameter Modelica.SIunits.MassFlowRate coo.hex.bal2.vol.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.MassFlowRate coo.hex.bal2.vol.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 structural parameter Boolean coo.hex.bal2.vol.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate coo.hex.bal2.vol.m_flow(start = 0.0) = coo.hex.bal2.vol.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure coo.hex.bal2.vol.dp(start = 0.0,displayUnit = "Pa") = coo.hex.bal2.vol.port_a.p - coo.hex.bal2.vol.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate coo.hex.bal2.vol._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure coo.hex.bal2.vol._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean coo.hex.bal2.vol.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.hex.bal2.vol.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal2.vol.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal2.vol.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal2.vol.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal2.vol.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.hex.bal2.vol.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal2.vol.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal2.vol.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal2.vol.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal2.vol.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Real coo.hex.bal2.preDro.deltaM = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs" /* 0.1 */;
 parameter Real coo.hex.bal2.preDro.k = if 500.0 > 1.0E-15 then 7.024856596558317 / sqrt(500.0) else 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)" /* 0.3141611376418442 */;
 eval parameter Boolean coo.hex.bal2.preDro.computeFlowResistance = true "Flag to enable/disable computation of flow resistance" /* true */;
 parameter Real coo.hex.bal2.preDro.coeff = 0 "Precomputed coefficient to avoid division by parameter" /* 0 */;
 constant Boolean coo.hex.bal2.preDro.homotopyInitialization = true "= true, use homotopy method";
 eval parameter Boolean coo.hex.bal2.preDro.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure coo.hex.bal2.preDro.dp_nominal = 500 "Pressure drop at nominal mass flow rate" /* 500 */;
 eval parameter Boolean coo.hex.bal2.preDro.linearized = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Modelica.SIunits.MassFlowRate coo.hex.bal2.preDro.m_flow_turbulent = 0.7024856596558318 "Turbulent flow if |m_flow| >= m_flow_turbulent" /* 0.7024856596558318 */;
 parameter Buildings.Media.Water.ThermodynamicState coo.hex.bal2.preDro.sta_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0});
 parameter Modelica.SIunits.DynamicViscosity coo.hex.bal2.preDro.eta_default = Buildings.Media.Water.dynamicViscosity(coo.hex.bal2.preDro.sta_default) "Dynamic viscosity, used to compute transition to turbulent flow regime";
 structural parameter Modelica.SIunits.MassFlowRate coo.hex.bal2.preDro.m_flow_nominal_pos = 7.024856596558317 "Absolute value of nominal flow rate" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.Pressure coo.hex.bal2.preDro.dp_nominal_pos = 500.0 "Absolute value of nominal pressure difference" /* 500.0 */;
 structural parameter Modelica.SIunits.MassFlowRate coo.hex.bal2.preDro.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.MassFlowRate coo.hex.bal2.preDro.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 structural parameter Boolean coo.hex.bal2.preDro.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate coo.hex.bal2.preDro.m_flow(nominal = 7.024856596558317,start = 0.0) = coo.hex.bal2.preDro.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure coo.hex.bal2.preDro.dp(nominal = 500.0,start = 0.0,displayUnit = "Pa") = coo.hex.bal2.preDro.port_a.p - coo.hex.bal2.preDro.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate coo.hex.bal2.preDro._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure coo.hex.bal2.preDro._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean coo.hex.bal2.preDro.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.hex.bal2.preDro.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal2.preDro.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal2.preDro.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal2.preDro.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal2.preDro.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.hex.bal2.preDro.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal2.preDro.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal2.preDro.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal2.preDro.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal2.preDro.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal2.hOut(unit = "J/kg") "Leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal2.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal2.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal2.heaInp.y = coo.hex.bal2.Q_flow "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput coo.hex.bal2.masExc.y = coo.hex.bal2.mWat_flow "Value of Real output";
 structural parameter Modelica.SIunits.MassFlowRate coo.hex.bal2.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.MassFlowRate coo.hex.bal2.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 structural parameter Boolean coo.hex.bal2.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate coo.hex.bal2.m_flow(start = 0.0) = coo.hex.bal2.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure coo.hex.bal2.dp(start = 0.0,displayUnit = "Pa") = coo.hex.bal2.port_a.p - coo.hex.bal2.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate coo.hex.bal2._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure coo.hex.bal2._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean coo.hex.bal2.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate coo.hex.bal2.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal2.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal2.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal2.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal2.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate coo.hex.bal2.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure coo.hex.bal2.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy coo.hex.bal2.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction coo.hex.bal2.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty coo.hex.bal2.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean coo.hex.bal2.computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction" /* true */;
 eval parameter Boolean coo.hex.bal2.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure coo.hex.bal2.dp_nominal = 500 "Pressure difference" /* 500 */;
 structural parameter Boolean coo.hex.bal2.linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real coo.hex.bal2.deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 Buildings.Media.Water.ThermodynamicState coo.hex.state_a1_inflow(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(coo.hex.port_a1.p, inStream(coo.hex.port_a1.h_outflow), inStream(coo.hex.port_a1.Xi_outflow[1:0])) "state for medium inflowing through port_a1";
 Buildings.Media.Water.ThermodynamicState coo.hex.state_b1_inflow(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(coo.hex.port_b1.p, inStream(coo.hex.port_b1.h_outflow), inStream(coo.hex.port_b1.Xi_outflow[1:0])) "state for medium inflowing through port_b1";
 Buildings.Media.Water.ThermodynamicState coo.hex.state_a2_inflow(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(coo.hex.port_a2.p, inStream(coo.hex.port_a2.h_outflow), inStream(coo.hex.port_a2.Xi_outflow[1:0])) "state for medium inflowing through port_a2";
 Buildings.Media.Water.ThermodynamicState coo.hex.state_b2_inflow(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(coo.hex.port_b2.p, inStream(coo.hex.port_b2.h_outflow), inStream(coo.hex.port_b2.Xi_outflow[1:0])) "state for medium inflowing through port_b2";
 Modelica.Blocks.Interfaces.RealInput coo.con.I.y_reset_internal "Internal connector for integrator reset";
 discrete Modelica.Blocks.Interfaces.BooleanInput coo.con.I.trigger_internal "Needed to use conditional connector trigger";
 structural parameter Boolean coo.con.D.zeroGain = false /* false */;
 constant Modelica.SIunits.Time coo.con.unitTime = 1;
 parameter Real coo.con.revAct = if coo.con.reverseAction then -1 else 1 "Switch for sign for reverse action";
 eval parameter Boolean coo.con.with_I = true "Boolean flag to enable integral action" /* true */;
 eval parameter Boolean coo.con.with_D = true "Boolean flag to enable derivative action" /* true */;
 Modelica.Blocks.Interfaces.RealInput coo.con.y_reset_internal "Internal connector for controller output reset";
 parameter Real coo.con.addI.k1 = coo.con.revAct "Gain of upper input";
 parameter Real coo.con.addI.k2 = - coo.con.revAct "Gain of middle input";
 parameter Real coo.con.addI.k3 = 1 "Gain of lower input" /* 1 */;
 Modelica.Blocks.Interfaces.RealInput coo.con.addI.u1 "Connector 1 of Real input signals";
 Modelica.Blocks.Interfaces.RealInput coo.con.addI.u2 "Connector 2 of Real input signals";
 Modelica.Blocks.Interfaces.RealInput coo.con.addI.u3 "Connector 3 of Real input signals";
 Modelica.Blocks.Interfaces.RealOutput coo.con.addI.y "Connector of Real output signals";
 final parameter Real coo.con.addSat.k1 = 1 "Gain of upper input" /* 1 */;
 final parameter Real coo.con.addSat.k2 = -1 "Gain of lower input" /* -1 */;
 Modelica.Blocks.Interfaces.RealInput coo.con.addSat.u1 "Connector of Real input signal 1";
 Modelica.Blocks.Interfaces.RealInput coo.con.addSat.u2 "Connector of Real input signal 2";
 Modelica.Blocks.Interfaces.RealOutput coo.con.addSat.y "Connector of Real output signal";
 parameter Real coo.con.gainPID.k(start = 1,unit = "1") = coo.con.k "Gain value multiplied with input signal";
 Modelica.Blocks.Interfaces.RealInput coo.con.gainPID.u "Input signal connector";
 Modelica.Blocks.Interfaces.RealOutput coo.con.gainPID.y "Output signal connector";
 parameter Real coo.con.gainTrack.k(start = 1,unit = "1") = 1 / (coo.con.k * coo.con.Ni) "Gain value multiplied with input signal";
 Modelica.Blocks.Interfaces.RealInput coo.con.gainTrack.u "Input signal connector";
 Modelica.Blocks.Interfaces.RealOutput coo.con.gainTrack.y "Output signal connector";
 parameter Real coo.con.limiter.uMax(start = 1) = 1.0 "Upper limits of input signals" /* 1.0 */;
 parameter Real coo.con.limiter.uMin = 0.0 "Lower limits of input signals" /* 0.0 */;
 eval parameter Boolean coo.con.limiter.strict = true "= true, if strict limits with noEvent(..)" /* true */;
 eval parameter Boolean coo.con.limiter.limitsAtInit = true "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)" /* true */;
 Modelica.Blocks.Interfaces.RealInput coo.con.limiter.u "Connector of Real input signal";
 Modelica.Blocks.Interfaces.RealOutput coo.con.limiter.y "Connector of Real output signal";
 parameter Real coo.senTDisSup.tauHeaTraInv(final unit = "1/s") = if coo.senTDisSup.tauHeaTra < 1.0E-10 then 0 else 1 / coo.senTDisSup.tauHeaTra "Dummy parameter to avoid division by tauHeaTra";
 parameter Real coo.senTDisSup.ratTau = coo.senTDisSup.tauHeaTra "Ratio of tau";
 Buildings.Media.Water.Temperature coo.senTDisSup.TMed(start = coo.senTDisSup.T_start) "Medium temperature to which the sensor is exposed";
 Buildings.Media.Water.Temperature coo.senTDisSup.T_a_inflow(start = 293.15) "Temperature of inflowing fluid at port_a";
 Buildings.Media.Water.Temperature coo.senTDisSup.T_b_inflow(start = 293.15) "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow";
 Real coo.senTDisSup.k(start = 1) "Gain to take flow rate into account for sensor time constant";
 eval parameter Boolean coo.senTDisSup.dynamic = true "Flag, true if the sensor is a dynamic sensor" /* true */;
 Real coo.senTDisSup.mNor_flow "Normalized mass flow rate";
 structural parameter Real coo.senTDisSup.tauInv = 1.0 "Inverse of tau" /* 1.0 */;
 parameter Real coo.senTDisRet.tauHeaTraInv(final unit = "1/s") = if coo.senTDisRet.tauHeaTra < 1.0E-10 then 0 else 1 / coo.senTDisRet.tauHeaTra "Dummy parameter to avoid division by tauHeaTra";
 parameter Real coo.senTDisRet.ratTau = coo.senTDisRet.tauHeaTra "Ratio of tau";
 Buildings.Media.Water.Temperature coo.senTDisRet.TMed(start = coo.senTDisRet.T_start) "Medium temperature to which the sensor is exposed";
 Buildings.Media.Water.Temperature coo.senTDisRet.T_a_inflow(start = 293.15) "Temperature of inflowing fluid at port_a";
 Buildings.Media.Water.Temperature coo.senTDisRet.T_b_inflow(start = 293.15) "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow";
 Real coo.senTDisRet.k(start = 1) "Gain to take flow rate into account for sensor time constant";
 eval parameter Boolean coo.senTDisRet.dynamic = true "Flag, true if the sensor is a dynamic sensor" /* true */;
 Real coo.senTDisRet.mNor_flow "Normalized mass flow rate";
 structural parameter Real coo.senTDisRet.tauInv = 1.0 "Inverse of tau" /* 1.0 */;
 parameter Real coo.TBuiSup.tauHeaTraInv(final unit = "1/s") = if coo.TBuiSup.tauHeaTra < 1.0E-10 then 0 else 1 / coo.TBuiSup.tauHeaTra "Dummy parameter to avoid division by tauHeaTra";
 parameter Real coo.TBuiSup.ratTau = coo.TBuiSup.tauHeaTra "Ratio of tau";
 Buildings.Media.Water.Temperature coo.TBuiSup.TMed(start = coo.TBuiSup.T_start) "Medium temperature to which the sensor is exposed";
 Buildings.Media.Water.Temperature coo.TBuiSup.T_a_inflow(start = 293.15) "Temperature of inflowing fluid at port_a";
 Buildings.Media.Water.Temperature coo.TBuiSup.T_b_inflow(start = 293.15) "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow";
 Real coo.TBuiSup.k(start = 1) "Gain to take flow rate into account for sensor time constant";
 eval parameter Boolean coo.TBuiSup.dynamic = true "Flag, true if the sensor is a dynamic sensor" /* true */;
 Real coo.TBuiSup.mNor_flow "Normalized mass flow rate";
 structural parameter Real coo.TBuiSup.tauInv = 1.0 "Inverse of tau" /* 1.0 */;
 parameter Real coo.val.alpInv = 1 / coo.val.alp "Inverse of alpha";
 parameter Buildings.Media.Water.ThermodynamicState coo.val.sta_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0});
 parameter Modelica.SIunits.DynamicViscosity coo.val.eta_default = Buildings.Media.Water.dynamicViscosity(coo.val.sta_default) "Dynamic viscosity, used to compute transition to turbulent flow regime";
 parameter Modelica.SIunits.MassFlowRate coo.val.m_flow_nominal_pos = abs(coo.val.m_flow_nominal) "Absolute value of nominal flow rate";
 parameter Modelica.SIunits.Pressure coo.val.dp_nominal_pos(displayUnit = "Pa") = abs(coo.val.dp_nominal) "Absolute value of nominal pressure difference";
 final parameter Modelica.SIunits.MassFlowRate coo.val._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure coo.val._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 initial parameter Real coo.val.Kv_SI(min = 0,fixed = false) "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)]";
 parameter Real coo.TBuiRet.tauHeaTraInv(final unit = "1/s") = if coo.TBuiRet.tauHeaTra < 1.0E-10 then 0 else 1 / coo.TBuiRet.tauHeaTra "Dummy parameter to avoid division by tauHeaTra";
 parameter Real coo.TBuiRet.ratTau = coo.TBuiRet.tauHeaTra "Ratio of tau";
 Buildings.Media.Water.Temperature coo.TBuiRet.TMed(start = coo.TBuiRet.T_start) "Medium temperature to which the sensor is exposed";
 Buildings.Media.Water.Temperature coo.TBuiRet.T_a_inflow(start = 293.15) "Temperature of inflowing fluid at port_a";
 Buildings.Media.Water.Temperature coo.TBuiRet.T_b_inflow(start = 293.15) "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow";
 Real coo.TBuiRet.k(start = 1) "Gain to take flow rate into account for sensor time constant";
 eval parameter Boolean coo.TBuiRet.dynamic = true "Flag, true if the sensor is a dynamic sensor" /* true */;
 Real coo.TBuiRet.mNor_flow "Normalized mass flow rate";
 structural parameter Real coo.TBuiRet.tauInv = 1.0 "Inverse of tau" /* 1.0 */;
 parameter Buildings.Media.Water.ThermodynamicState coo.sta_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0}) "Medium state at default properties";
 parameter Modelica.SIunits.SpecificHeatCapacity coo.cp_default = Buildings.Media.Water.specificHeatCapacityCp(coo.sta_default) "Specific heat capacity of the fluid";
 parameter Real bui.loa.p_offset[3] = ones(3) * bui.loa.offset[1] "Offsets of output signals";
 parameter Modelica.Blocks.Types.ExternalCombiTimeTable bui.loa.tableID = Modelica.Blocks.Types.ExternalCombiTimeTable.constructor(if true then bui.loa.tableName else "NoName", if true and bui.loa.fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(bui.loa.fileName) then bui.loa.fileName else "NoName", bui.loa.table[1:0,1:2], bui.loa.startTime, bui.loa.columns[1:3], Modelica.Blocks.Types.Smoothness.LinearSegments, bui.loa.extrapolation) "External table object";
 discrete Modelica.SIunits.Time bui.loa.nextTimeEvent(start = 0,fixed = true) "Next time event instant";
 discrete Real bui.loa.nextTimeEventScaled(start = 0,fixed = true) "Next scaled time event instant";
 initial parameter Real bui.loa.tableOnFileRead(fixed = false) "= 1, if table was successfully read from file";
 constant Real bui.loa.DBL_MAX = 1.7976931348623157E308;
 Real bui.loa.timeScaled "Scaled time";
 final parameter Modelica.SIunits.VolumeFlowRate bui.terUniHea.fan._VMachine_flow = 0 "Start value for VMachine_flow, used to avoid a warning if not specified" /* 0 */;
 structural parameter Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable bui.terUniHea.fan.preVar = Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate "Type of prescribed variable" /* Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate */;
 structural parameter Boolean bui.terUniHea.fan.speedIsInput = false "Parameter that is true if speed is the controlled variables" /* false */;
 eval parameter Integer bui.terUniHea.fan.nOri = 2 "Number of data points for pressure curve" /* 2 */;
 structural parameter Boolean bui.terUniHea.fan.haveVMax = true "Flag, true if user specified data that contain V_flow_max" /* true */;
 structural parameter Modelica.SIunits.VolumeFlowRate bui.terUniHea.fan.V_flow_max = 13.773894244353764 "Maximum volume flow rate, used for smoothing" /* 13.773894244353764 */;
 structural parameter Modelica.SIunits.Density bui.terUniHea.fan.rho_default = 1.2 "Default medium density" /* 1.2 */;
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniHea.fan.sta_start(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(bui.terUniHea.fan.p_start, bui.terUniHea.fan.T_start, bui.terUniHea.fan.X_start[1:2]) "Medium state at start values";
 parameter Modelica.SIunits.SpecificEnergy bui.terUniHea.fan.h_outflow_start = Buildings.Media.Air.specificEnthalpy(bui.terUniHea.fan.sta_start) "Start value for outflowing enthalpy";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.inputSwitch.u "Connector of Real input signal";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.inputSwitch.y "Connector of Real output signal";
 parameter Modelica.SIunits.Time bui.terUniHea.fan.vol.tau = bui.terUniHea.fan.tau "Time constant at nominal flow";
 parameter Modelica.SIunits.Volume bui.terUniHea.fan.vol.V_nominal = 16.528673093224516 * bui.terUniHea.fan.vol.tau / bui.terUniHea.fan.vol.rho_default "Volume of delay element";
 eval parameter Boolean bui.terUniHea.fan.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.fan.vol.heatPort.T(start = bui.terUniHea.fan.vol.T_start) "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.fan.vol.heatPort.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 eval parameter Boolean bui.terUniHea.fan.vol.initialize_p = true "= true to set up initial equations for pressure" /* true */;
 constant Boolean bui.terUniHea.fan.vol.prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
 constant Boolean bui.terUniHea.fan.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.fan.vol.m_flow_nominal = 16.528673093224516 "Nominal mass flow rate" /* 16.528673093224516 */;
 eval parameter Integer bui.terUniHea.fan.vol.nPorts = 2 "Number of ports" /* 2 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.fan.vol.m_flow_small = 0.0016528673093224517 "Small mass flow rate for regularization of zero flow" /* 0.0016528673093224517 */;
 eval parameter Boolean bui.terUniHea.fan.vol.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports." /* true */;
 parameter Modelica.SIunits.Volume bui.terUniHea.fan.vol.V = bui.terUniHea.fan.vol.V_nominal "Volume";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.vol.ports[1].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.vol.ports[1].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.vol.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.vol.ports[1].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.vol.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.vol.ports[2].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.vol.ports[2].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.vol.ports[2].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.vol.ports[2].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.vol.ports[2].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.Temperature bui.terUniHea.fan.vol.T(start = 293.15) = Buildings.Media.Air.temperature_phX(bui.terUniHea.fan.vol.p, bui.terUniHea.fan.vol.hOut_internal, cat(1, bui.terUniHea.fan.vol.Xi[1:1], {1 - sum(bui.terUniHea.fan.vol.Xi[1:1])})) "Temperature of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.U(unit = "J") "Internal energy of the component";
 Modelica.SIunits.Pressure bui.terUniHea.fan.vol.p = bui.terUniHea.fan.vol.ports[1].p "Pressure of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.m(unit = "kg") "Mass of the component";
 Modelica.SIunits.MassFraction bui.terUniHea.fan.vol.Xi[1] = bui.terUniHea.fan.vol.XiOut_internal[1:1] "Species concentration of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.mXi[1](each unit = "kg") "Species mass of the component";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.vol.C[0](nominal = bui.terUniHea.fan.vol.C_nominal[1:0]) = bui.terUniHea.fan.vol.COut_internal[1:0] "Trace substance mixture content";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.mC[0](each unit = "kg") "Trace substance mass of the component";
 eval parameter Boolean bui.terUniHea.fan.vol.dynBal.initialize_p = true "= true to set up initial equations for pressure" /* true */;
 constant Boolean bui.terUniHea.fan.vol.dynBal.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";
 eval parameter Integer bui.terUniHea.fan.vol.dynBal.nPorts = 2 "Number of ports" /* 2 */;
 eval parameter Boolean bui.terUniHea.fan.vol.dynBal.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean bui.terUniHea.fan.vol.dynBal.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.vol.dynBal.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.dynBal.hOut(unit = "J/kg",start = bui.terUniHea.fan.vol.dynBal.hStart) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.dynBal.XiOut[1](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.dynBal.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.dynBal.UOut(unit = "J") "Internal energy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.dynBal.mXiOut[1](each min = 0,each unit = "kg") "Species mass of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.dynBal.mOut(min = 0,unit = "kg") "Mass of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.dynBal.mCOut[0](each min = 0,each unit = "kg") "Trace substance mass of the component";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.vol.dynBal.ports[1].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.vol.dynBal.ports[1].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.vol.dynBal.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.vol.dynBal.ports[1].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.vol.dynBal.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.vol.dynBal.ports[2].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.vol.dynBal.ports[2].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.vol.dynBal.ports[2].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.vol.dynBal.ports[2].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.vol.dynBal.ports[2].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 constant Modelica.SIunits.MolarMass bui.terUniHea.fan.vol.dynBal.medium.MMX[2] = {0.01801528, 0.0289651159} "Molar masses of components";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.vol.dynBal.medium.X_steam "Mass fraction of steam water";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.vol.dynBal.medium.X_air "Mass fraction of air";
 Modelica.SIunits.TemperatureDifference bui.terUniHea.fan.vol.dynBal.medium.dT(start = 293.15 - 273.15) "Temperature difference used to compute enthalpy" annotation(absoluteValue = false);
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol.dynBal.medium.InputAbsolutePressure bui.terUniHea.fan.vol.dynBal.medium.p(start = bui.terUniHea.fan.vol.dynBal.p_start) "Absolute pressure of medium";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol.dynBal.medium.InputMassFraction bui.terUniHea.fan.vol.dynBal.medium.Xi[1](start = bui.terUniHea.fan.vol.dynBal.X_start[1:1],each stateSelect = StateSelect.default) "Structurally independent mass fractions";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol.dynBal.medium.InputSpecificEnthalpy bui.terUniHea.fan.vol.dynBal.medium.h(start = bui.terUniHea.fan.vol.dynBal.hStart) "Specific enthalpy of medium";
 Buildings.Media.Air.Density bui.terUniHea.fan.vol.dynBal.medium.d(start = bui.terUniHea.fan.vol.dynBal.rho_start) "Density of medium";
 Buildings.Media.Air.Temperature bui.terUniHea.fan.vol.dynBal.medium.T(start = bui.terUniHea.fan.vol.dynBal.T_start,stateSelect = StateSelect.default) "Temperature of medium";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.vol.dynBal.medium.X[2](start = bui.terUniHea.fan.vol.dynBal.X_start[1:2]) "Mass fractions (= (component mass)/total mass  m_i/m)";
 Buildings.Media.Air.SpecificEnergy bui.terUniHea.fan.vol.dynBal.medium.u "Specific internal energy of medium";
 Buildings.Media.Air.SpecificHeatCapacity bui.terUniHea.fan.vol.dynBal.medium.R "Gas constant (of mixture if applicable)";
 Buildings.Media.Air.MolarMass bui.terUniHea.fan.vol.dynBal.medium.MM "Molar mass (of mixture or single fluid)";
 Buildings.Media.Air.ThermodynamicState bui.terUniHea.fan.vol.dynBal.medium.state(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) "Thermodynamic state record for optional functions";
 eval parameter Boolean bui.terUniHea.fan.vol.dynBal.medium.preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium" /* false */;
 structural parameter Boolean bui.terUniHea.fan.vol.dynBal.medium.standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones" /* true */;
 Modelica.SIunits.Conversions.NonSIunits.Temperature_degC bui.terUniHea.fan.vol.dynBal.medium.T_degC = Modelica.SIunits.Conversions.to_degC(bui.terUniHea.fan.vol.dynBal.medium.T) "Temperature of medium in [degC]";
 Modelica.SIunits.Conversions.NonSIunits.Pressure_bar bui.terUniHea.fan.vol.dynBal.medium.p_bar = Modelica.SIunits.Conversions.to_bar(bui.terUniHea.fan.vol.dynBal.medium.p) "Absolute pressure of medium in [bar]";
 Modelica.SIunits.Energy bui.terUniHea.fan.vol.dynBal.U(start = bui.terUniHea.fan.vol.dynBal.fluidVolume * bui.terUniHea.fan.vol.dynBal.rho_start * Buildings.Media.Air.specificInternalEnergy(Buildings.Media.Air.setState_pTX(bui.terUniHea.fan.vol.dynBal.p_start, bui.terUniHea.fan.vol.dynBal.T_start, bui.terUniHea.fan.vol.dynBal.X_start[1:1])) + (bui.terUniHea.fan.vol.dynBal.T_start - 273.15) * bui.terUniHea.fan.vol.dynBal.CSen,nominal = 100000.0) "Internal energy of fluid";
 Modelica.SIunits.Mass bui.terUniHea.fan.vol.dynBal.m(start = bui.terUniHea.fan.vol.V * bui.terUniHea.fan.vol.rho_start,stateSelect = StateSelect.prefer) "Mass of fluid";
 Modelica.SIunits.Mass bui.terUniHea.fan.vol.dynBal.mXi[1](start = bui.terUniHea.fan.vol.dynBal.fluidVolume * bui.terUniHea.fan.vol.dynBal.rho_start * bui.terUniHea.fan.vol.dynBal.X_start[1:1]) "Masses of independent components in the fluid";
 Modelica.SIunits.Mass bui.terUniHea.fan.vol.dynBal.mC[0](start = bui.terUniHea.fan.vol.dynBal.fluidVolume * bui.terUniHea.fan.vol.dynBal.rho_start * bui.terUniHea.fan.vol.dynBal.C_start[1:0]) "Masses of trace substances in the fluid";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.vol.dynBal.C[0](nominal = bui.terUniHea.fan.vol.dynBal.C_nominal[1:0]) "Trace substance mixture content";
 Modelica.SIunits.MassFlowRate bui.terUniHea.fan.vol.dynBal.mb_flow "Mass flows across boundaries";
 Modelica.SIunits.MassFlowRate bui.terUniHea.fan.vol.dynBal.mbXi_flow[1] "Substance mass flows across boundaries";
 Buildings.Media.Air.ExtraPropertyFlowRate bui.terUniHea.fan.vol.dynBal.mbC_flow[0] "Trace substance mass flows across boundaries";
 Modelica.SIunits.EnthalpyFlowRate bui.terUniHea.fan.vol.dynBal.Hb_flow "Enthalpy flow across boundaries or energy source/sink";
 parameter Modelica.SIunits.Volume bui.terUniHea.fan.vol.dynBal.fluidVolume = bui.terUniHea.fan.vol.V "Volume";
 parameter Modelica.SIunits.HeatCapacity bui.terUniHea.fan.vol.dynBal.CSen = (1.0 - 1) * bui.terUniHea.fan.vol.dynBal.rho_default * bui.terUniHea.fan.vol.dynBal.cp_default * bui.terUniHea.fan.vol.dynBal.fluidVolume "Aditional heat capacity for implementing mFactor";
 Buildings.Media.Air.EnthalpyFlowRate bui.terUniHea.fan.vol.dynBal.ports_H_flow[2];
 Modelica.SIunits.MassFlowRate bui.terUniHea.fan.vol.dynBal.ports_mXi_flow[2,1];
 Buildings.Media.Air.ExtraPropertyFlowRate bui.terUniHea.fan.vol.dynBal.ports_mC_flow[2,0];
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.fan.vol.dynBal.cp_default = Buildings.Media.Air.specificHeatCapacityCp(bui.terUniHea.fan.vol.dynBal.state_default) "Heat capacity, to compute additional dry mass";
 parameter Modelica.SIunits.Density bui.terUniHea.fan.vol.dynBal.rho_start = Buildings.Media.Air.density(Buildings.Media.Air.setState_pTX(bui.terUniHea.fan.vol.dynBal.p_start, bui.terUniHea.fan.vol.dynBal.T_start, bui.terUniHea.fan.vol.dynBal.X_start[1:1])) "Density, used to compute fluid mass";
 eval parameter Boolean bui.terUniHea.fan.vol.dynBal.computeCSen = false /* false */;
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniHea.fan.vol.dynBal.state_default(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01}) "Medium state at default values";
 parameter Modelica.SIunits.Density bui.terUniHea.fan.vol.dynBal.rho_default = Buildings.Media.Air.density(bui.terUniHea.fan.vol.dynBal.state_default) "Density, used to compute fluid mass";
 final parameter Real bui.terUniHea.fan.vol.dynBal.s[1] = {1} "Vector with zero everywhere except where species is" /* { 1 } */;
 parameter Modelica.SIunits.SpecificEnergy bui.terUniHea.fan.vol.dynBal.hStart = Buildings.Media.Air.specificEnthalpy_pTX(bui.terUniHea.fan.vol.dynBal.p_start, bui.terUniHea.fan.vol.dynBal.T_start, bui.terUniHea.fan.vol.dynBal.X_start[1:2]) "Start value for specific enthalpy";
 constant Boolean bui.terUniHea.fan.vol.dynBal._simplify_mWat_flow = true "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.vol.dynBal.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.vol.dynBal.C_flow_internal[0] "Needed to connect to conditional connector";
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.vol.dynBal.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.vol.dynBal.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.vol.dynBal.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.vol.dynBal.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.vol.dynBal.p_start(start = 101325.0) = bui.terUniHea.fan.vol.p_start "Start value of pressure";
 parameter Buildings.Media.Air.Temperature bui.terUniHea.fan.vol.dynBal.T_start(start = 293.15) = bui.terUniHea.fan.vol.T_start "Start value of temperature";
 parameter Buildings.Media.Air.MassFraction bui.terUniHea.fan.vol.dynBal.X_start[2](quantity = {"water", "air"}) = bui.terUniHea.fan.vol.X_start[1:2] "Start value of mass fractions m_i/m";
 parameter Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.vol.dynBal.C_start[0](quantity = fill("", 0)) = bui.terUniHea.fan.vol.C_start[1:0] "Start value of trace substances";
 parameter Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.vol.dynBal.C_nominal[0](quantity = fill("", 0)) = bui.terUniHea.fan.vol.C_nominal[1:0] "Nominal value of trace substances. (Set to typical order of magnitude.)";
 structural parameter Real bui.terUniHea.fan.vol.dynBal.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 parameter Modelica.SIunits.Density bui.terUniHea.fan.vol.rho_start = Buildings.Media.Air.density(bui.terUniHea.fan.vol.state_start) "Density, used to compute start and guess values";
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniHea.fan.vol.state_default(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01}) "Medium state at default values";
 parameter Modelica.SIunits.Density bui.terUniHea.fan.vol.rho_default = Buildings.Media.Air.density(bui.terUniHea.fan.vol.state_default) "Density, used to compute fluid mass";
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniHea.fan.vol.state_start(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(bui.terUniHea.fan.vol.p_start, bui.terUniHea.fan.vol.T_start, bui.terUniHea.fan.vol.X_start[1:1]) "Medium state at start values";
 eval parameter Boolean bui.terUniHea.fan.vol.useSteadyStateTwoPort = false "Flag, true if the model has two ports only and uses a steady state balance" /* false */;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.hOut_internal(unit = "J/kg") "Internal connector for leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.XiOut_internal[1](each unit = "1") "Internal connector for leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.COut_internal[0](each unit = "1") "Internal connector for leaving trace substances of the component";
 Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.fan.vol.preTem.port.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.fan.vol.preTem.port.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.vol.preTem.T;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.portT.y = bui.terUniHea.fan.vol.T "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.vol.heaFloSen.Q_flow(unit = "W") "Heat flow from port_a to port_b as output signal";
 Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.fan.vol.heaFloSen.port_a.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.fan.vol.heaFloSen.port_a.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.fan.vol.heaFloSen.port_b.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.fan.vol.heaFloSen.port_b.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.vol.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.vol.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.vol.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniHea.fan.vol.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.vol.p_start(start = 101325.0) = bui.terUniHea.fan.p_start "Start value of pressure";
 parameter Buildings.Media.Air.Temperature bui.terUniHea.fan.vol.T_start(start = 293.15) = bui.terUniHea.fan.T_start "Start value of temperature";
 parameter Buildings.Media.Air.MassFraction bui.terUniHea.fan.vol.X_start[2](quantity = {"water", "air"}) = bui.terUniHea.fan.X_start[1:2] "Start value of mass fractions m_i/m";
 parameter Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.vol.C_start[0](quantity = fill("", 0)) = bui.terUniHea.fan.C_start[1:0] "Start value of trace substances";
 parameter Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.vol.C_nominal[0](quantity = fill("", 0)) = fill(0.01, 0) "Nominal value of trace substances. (Set to typical order of magnitude.)" /* (zero-size array) */;
 structural parameter Real bui.terUniHea.fan.vol.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 structural parameter Modelica.Blocks.Types.AnalogFilter bui.terUniHea.fan.filter.analogFilter = Modelica.Blocks.Types.AnalogFilter.CriticalDamping "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI)" /* Modelica.Blocks.Types.AnalogFilter.CriticalDamping */;
 structural parameter Modelica.Blocks.Types.FilterType bui.terUniHea.fan.filter.filterType = Modelica.Blocks.Types.FilterType.LowPass "Type of filter (LowPass/HighPass/BandPass/BandStop)" /* Modelica.Blocks.Types.FilterType.LowPass */;
 structural parameter Integer bui.terUniHea.fan.filter.order = 2 "Order of filter" /* 2 */;
 parameter Modelica.SIunits.Frequency bui.terUniHea.fan.filter.f_cut = 5 / (2 * 3.141592653589793 * bui.terUniHea.fan.riseTime) "Cut-off frequency";
 parameter Real bui.terUniHea.fan.filter.gain = 1.0 "Gain (= amplitude of frequency response at zero frequency)" /* 1.0 */;
 parameter Real bui.terUniHea.fan.filter.A_ripple(unit = "dB") = 0.5 "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required" /* 0.5 */;
 parameter Modelica.SIunits.Frequency bui.terUniHea.fan.filter.f_min = 0 "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain)" /* 0 */;
 parameter Boolean bui.terUniHea.fan.filter.normalized = true "= true, if amplitude at f_cut = -3db, otherwise unmodified filter" /* true */;
 eval parameter Modelica.Blocks.Types.Init bui.terUniHea.fan.filter.init = Modelica.Blocks.Types.Init.InitialOutput "Type of initialization (no init/steady state/initial state/initial output)" /* Modelica.Blocks.Types.Init.InitialOutput */;
 structural parameter Integer bui.terUniHea.fan.filter.nx = 2 /* 2 */;
 parameter Real bui.terUniHea.fan.filter.x_start[2] = zeros(2) "Initial or guess values of states" /* { 0, 0 } */;
 parameter Real bui.terUniHea.fan.filter.y_start = bui.terUniHea.fan.m_flow_start "Initial value of output";
 structural parameter Real bui.terUniHea.fan.filter.u_nominal = 16.528673093224516 "Nominal value of input (used for scaling the states)" /* 16.528673093224516 */;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.filter.x[2](each stateSelect = StateSelect.always) "Filter states";
 structural parameter Integer bui.terUniHea.fan.filter.ncr = 2 /* 2 */;
 structural parameter Integer bui.terUniHea.fan.filter.nc0 = 0 /* 0 */;
 structural parameter Integer bui.terUniHea.fan.filter.na = 0 /* 0 */;
 structural parameter Integer bui.terUniHea.fan.filter.nr = 2 /* 2 */;
 initial parameter Real bui.terUniHea.fan.filter.cr[2](each fixed = false);
 parameter Real bui.terUniHea.fan.filter.c0[0](each fixed = false);
 parameter Real bui.terUniHea.fan.filter.c1[0](each fixed = false);
 initial parameter Real bui.terUniHea.fan.filter.r[2](each fixed = false);
 parameter Real bui.terUniHea.fan.filter.a[0](each fixed = false);
 parameter Real bui.terUniHea.fan.filter.b[0](each fixed = false);
 parameter Real bui.terUniHea.fan.filter.ku[0](each fixed = false);
 parameter Real bui.terUniHea.fan.filter.k1[0](each fixed = false);
 parameter Real bui.terUniHea.fan.filter.k2[0](each fixed = false);
 Real bui.terUniHea.fan.filter.uu[3];
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.filter.u(final unit = "kg/s") "Connector of Real input signal";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.filter.y(final unit = "kg/s") "Connector of Real output signal";
 eval parameter Boolean bui.terUniHea.fan.preSou.control_m_flow = true "if true, then the mass flow rate is equal to the value of m_flow_in" /* true */;
 eval parameter Boolean bui.terUniHea.fan.preSou.control_dp = false "if true, then the head is equal to the value of dp_in" /* false */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.preSou.m_flow_in(unit = "kg/s") "Prescribed mass flow rate";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.preSou.m_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.preSou.dp_internal(unit = "Pa") "Needed to connect to conditional connector";
 parameter Modelica.SIunits.Pressure bui.terUniHea.fan.preSou.dp_start(displayUnit = "Pa") = 0 "Guess value of dp = port_a.p - port_b.p" /* 0 */;
 parameter Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.preSou.m_flow_start = bui.terUniHea.fan.m_flow_start "Guess value of m_flow = port_a.m_flow";
 structural parameter Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.preSou.m_flow_small = 0.0016528673093224517 "Small mass flow rate for regularization of zero flow" /* 0.0016528673093224517 */;
 structural parameter Boolean bui.terUniHea.fan.preSou.show_T = false "= true, if temperatures at port_a and port_b are computed" /* false */;
 structural parameter Boolean bui.terUniHea.fan.preSou.show_V_flow = true "= true, if volume flow rate at inflowing port is computed" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.preSou.m_flow(min = -1.0E60,start = bui.terUniHea.fan.preSou.m_flow_start) "Mass flow rate in design flow direction";
 Modelica.SIunits.Pressure bui.terUniHea.fan.preSou.dp(start = bui.terUniHea.fan.preSou.dp_start,displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
 Modelica.SIunits.VolumeFlowRate bui.terUniHea.fan.preSou.V_flow = bui.terUniHea.fan.preSou.m_flow / Modelica.Fluid.Utilities.regStep(bui.terUniHea.fan.preSou.m_flow, Buildings.Media.Air.density(Buildings.Media.Air.setState_phX(bui.terUniHea.fan.preSou.port_a.p, inStream(bui.terUniHea.fan.preSou.port_a.h_outflow), inStream(bui.terUniHea.fan.preSou.port_a.Xi_outflow[1:1]))), Buildings.Media.Air.density(Buildings.Media.Air.setState_phX(bui.terUniHea.fan.preSou.port_b.p, inStream(bui.terUniHea.fan.preSou.port_b.h_outflow), inStream(bui.terUniHea.fan.preSou.port_b.Xi_outflow[1:1]))), 0.0016528673093224517) "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
 eval parameter Boolean bui.terUniHea.fan.preSou.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.preSou.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.preSou.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.preSou.port_a.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.preSou.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.preSou.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.preSou.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.preSou.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.preSou.port_b.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.preSou.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.preSou.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 constant Boolean bui.terUniHea.fan.heaDis.homotopyInitialization = true "= true, use homotopy method";
 parameter Boolean bui.terUniHea.fan.heaDis.motorCooledByFluid = bui.terUniHea.fan.per.motorCooledByFluid "Flag, true if the motor is cooled by the fluid stream";
 structural parameter Modelica.SIunits.VolumeFlowRate bui.terUniHea.fan.heaDis.delta_V_flow = 0.013773894244353765 "Factor used for setting heat input into medium to zero at very small flows" /* 0.013773894244353765 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.heaDis.etaHyd(final quantity = "Efficiency",final unit = "1") "Hydraulic efficiency";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.heaDis.V_flow(final quantity = "VolumeFlowRate",final unit = "m3/s") "Volume flow rate";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.heaDis.WFlo(final quantity = "Power",final unit = "W") "Flow work";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.heaDis.PEle(final quantity = "Power",final unit = "W") "Electrical power consumed";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.heaDis.Q_flow(quantity = "Power",final unit = "W") "Heat input from fan or pump to medium";
 Modelica.SIunits.Power bui.terUniHea.fan.heaDis.WHyd "Hydraulic power input (converted to flow work and heat)";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.fan.heaDis.QThe_flow "Heat input from fan or pump to medium";
 final parameter Real bui.terUniHea.fan.PToMed.k1 = 1 "Gain of upper input" /* 1 */;
 final parameter Real bui.terUniHea.fan.PToMed.k2 = 1 "Gain of lower input" /* 1 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.PToMed.u1 "Connector of Real input signal 1";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.PToMed.u2 "Connector of Real input signal 2";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.PToMed.y "Connector of Real output signal";
 parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.fan.prePow.T_ref = 293.15 "Reference temperature" /* 293.15 */;
 final parameter Modelica.SIunits.LinearTemperatureCoefficient bui.terUniHea.fan.prePow.alpha = 0 "Temperature coefficient of heat flow rate" /* 0 */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.prePow.Q_flow(unit = "W");
 Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.fan.prePow.port.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.fan.prePow.port.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.rho_inlet.y = Buildings.Media.Air.density(Buildings.Media.Air.setState_phX(bui.terUniHea.fan.port_a.p, inStream(bui.terUniHea.fan.port_a.h_outflow), inStream(bui.terUniHea.fan.port_a.Xi_outflow[1:1]))) "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.senMasFlo.m_flow(quantity = "MassFlowRate",final unit = "kg/s") "Mass flow rate from port_a to port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniHea.fan.senMasFlo.m_flow_nominal = 0 "Nominal mass flow rate, used for regularization near zero flow" /* 0 */;
 final parameter Modelica.SIunits.MassFlowRate bui.terUniHea.fan.senMasFlo.m_flow_small = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)" /* 0 */;
 eval parameter Boolean bui.terUniHea.fan.senMasFlo.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.senMasFlo.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.senMasFlo.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.senMasFlo.port_a.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.senMasFlo.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.senMasFlo.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.senMasFlo.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.senMasFlo.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.senMasFlo.port_b.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.senMasFlo.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.senMasFlo.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.senRelPre.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.senRelPre.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.senRelPre.port_a.h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.senRelPre.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.senRelPre.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.fan.senRelPre.port_b.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.fan.senRelPre.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.fan.senRelPre.port_b.h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.fan.senRelPre.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.fan.senRelPre.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.senRelPre.p_rel(final quantity = "PressureDifference",final unit = "Pa",displayUnit = "Pa") "Relative pressure of port_a minus port_b";
 constant Boolean bui.terUniHea.fan.eff.homotopyInitialization = true "= true, use homotopy method";
 parameter Buildings.Fluid.Movers.Data.Generic bui.terUniHea.fan.eff.per(pressure(V_flow(size() = {2}),dp(size() = {2})) = Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters({0, 27.54778848870753}, {400.0, 0}),use_powerCharacteristic = false,hydraulicEfficiency(V_flow(size() = {1},each min = 0),eta(size() = {1},each max = 1)) = bui.terUniHea.fan.per.hydraulicEfficiency,motorEfficiency(V_flow(size() = {1},each min = 0),eta(size() = {1},each max = 1)) = bui.terUniHea.fan.per.motorEfficiency,power(V_flow(size() = {1},each min = 0),P(size() = {1},each min = 0)) = bui.terUniHea.fan.per.power,motorCooledByFluid = bui.terUniHea.fan.per.motorCooledByFluid,speed_nominal = 0,constantSpeed = 0,speeds(size() = {1}) = {0},speed_rpm_nominal = 1500,constantSpeed_rpm = bui.terUniHea.fan.eff.per.speed_rpm_nominal,speeds_rpm(size() = {1}) = {bui.terUniHea.fan.eff.per.speed_rpm_nominal},havePressureCurve = true) "Record with performance data";
 structural parameter Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable bui.terUniHea.fan.eff.preVar = Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate "Type of prescribed variable" /* Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate */;
 structural parameter Boolean bui.terUniHea.fan.eff.computePowerUsingSimilarityLaws = false "= true, compute power exactly, using similarity laws. Otherwise approximate." /* false */;
 structural parameter Modelica.SIunits.VolumeFlowRate bui.terUniHea.fan.eff.V_flow_nominal = 27.54778848870753 "Nominal volume flow rate, used for homotopy" /* 27.54778848870753 */;
 structural parameter Modelica.SIunits.Density bui.terUniHea.fan.eff.rho_default = 1.2 "Fluid density at medium default state" /* 1.2 */;
 structural parameter Boolean bui.terUniHea.fan.eff.haveVMax = true "Flag, true if user specified data that contain V_flow_max" /* true */;
 structural parameter Modelica.SIunits.VolumeFlowRate bui.terUniHea.fan.eff.V_flow_max = 13.773894244353764 "Maximum volume flow rate, used for smoothing" /* 13.773894244353764 */;
 eval parameter Integer bui.terUniHea.fan.eff.nOri = 2 "Number of data points for pressure curve" /* 2 */;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.eff.y_out(final unit = "1") "Mover speed (prescribed or computed)";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.eff.m_flow(final quantity = "MassFlowRate",final unit = "kg/s") "Mass flow rate";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.eff.rho(final quantity = "Density",final unit = "kg/m3",min = 0.0) "Medium density";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.eff.V_flow(quantity = "VolumeFlowRate",final unit = "m3/s") "Volume flow rate";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.fan.eff.dp_in(quantity = "PressureDifference",final unit = "Pa") "Prescribed pressure increase";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.eff.WFlo(quantity = "Power",final unit = "W") "Flow work";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.eff.PEle(quantity = "Power",final unit = "W") "Electrical power consumed";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.eff.eta(final quantity = "Efficiency",final unit = "1") "Overall efficiency";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.eff.etaHyd(final quantity = "Efficiency",final unit = "1") "Hydraulic efficiency";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.eff.etaMot(final quantity = "Efficiency",final unit = "1") "Motor efficiency";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.eff.r_N(start = bui.terUniHea.fan.y_start,unit = "1") "Ratio N_actual/N_nominal";
 Real bui.terUniHea.fan.eff.r_V(start = 16.528673093224516 / 1.2,unit = "1") "Ratio V_flow/V_flow_max";
 structural parameter Boolean bui.terUniHea.fan.eff.preSpe = false "True if speed is a prescribed variable of this block" /* false */;
 structural parameter Boolean bui.terUniHea.fan.eff.prePre = true "True if pressure head is a prescribed variable of this block" /* true */;
 initial parameter Real bui.terUniHea.fan.eff.motDer[1](each fixed = false) "Coefficients for polynomial of motor efficiency vs. volume flow rate";
 initial parameter Real bui.terUniHea.fan.eff.hydDer[1](each fixed = false) "Coefficients for polynomial of hydraulic efficiency vs. volume flow rate";
 structural parameter Modelica.SIunits.Pressure bui.terUniHea.fan.eff.dpMax = 400.0 "Maximum head" /* 400.0 */;
 structural parameter Real bui.terUniHea.fan.eff.delta = 0.05 "Small value used to for regularization and to approximate an internal flow resistance of the fan" /* 0.05 */;
 structural parameter Real bui.terUniHea.fan.eff.kRes = 0.007260110918957602 "Coefficient for internal pressure drop of fan or pump" /* 0.007260110918957602 */;
 structural parameter Integer bui.terUniHea.fan.eff.curve = 1 "Flag, used to pick the right representatio of the fan or pump pressure curve" /* 1 */;
 parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal bui.terUniHea.fan.eff.pCur1(n = 2,V_flow(size() = {2}) = {0, 27.54778848870753},dp(size() = {2},each min = 0,each displayUnit = "Pa") = {400.0, 27.54778848870753 * 0.007260110918957602}) "Volume flow rate vs. total pressure rise with correction for pump resistance added";
 parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal bui.terUniHea.fan.eff.pCur2(n = 3,V_flow(size() = {3},each min = 0) = zeros(2 + 1),dp(size() = {3},each min = 0,each displayUnit = "Pa") = zeros(2 + 1)) "Volume flow rate vs. total pressure rise with correction for pump resistance added";
 parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal bui.terUniHea.fan.eff.pCur3(n = 4,V_flow(size() = {4},each min = 0) = zeros(2 + 2),dp(size() = {4},each min = 0,each displayUnit = "Pa") = zeros(2 + 2)) "Volume flow rate vs. total pressure rise with correction for pump resistance added";
 initial parameter Real bui.terUniHea.fan.eff.preDer1[2](each fixed = false) "Derivatives of flow rate vs. pressure at the support points";
 initial parameter Real bui.terUniHea.fan.eff.preDer2[3](each fixed = false) "Derivatives of flow rate vs. pressure at the support points";
 initial parameter Real bui.terUniHea.fan.eff.preDer3[4](each fixed = false) "Derivatives of flow rate vs. pressure at the support points";
 parameter Real bui.terUniHea.fan.eff.powDer[1] = if false then Buildings.Utilities.Math.Functions.splineDerivatives(bui.terUniHea.fan.eff.per.power.V_flow[1:1], bui.terUniHea.fan.eff.per.power.P[1:1], Buildings.Utilities.Math.Functions.isMonotonic(bui.terUniHea.fan.eff.per.power.P[1:1], false)) else zeros(size(bui.terUniHea.fan.eff.per.power.V_flow[1:1], 1)) "Coefficients for polynomial of power vs. flow rate";
 structural parameter Boolean bui.terUniHea.fan.eff.haveMinimumDecrease = true "Flag used for reporting" /* true */;
 structural parameter Boolean bui.terUniHea.fan.eff.haveDPMax = true "Flag, true if user specified data that contain dpMax" /* true */;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.fan.eff.dp_internal "If dp is prescribed, use dp_in and solve for r_N, otherwise compute dp using r_N";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniHea.fan._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniHea.fan._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.I.y_reset_internal "Internal connector for integrator reset";
 discrete Buildings.Controls.OBC.CDL.Interfaces.BooleanInput bui.terUniHea.con.I.trigger_internal "Needed to use conditional connector trigger";
 parameter Real bui.terUniHea.con.revAct = if bui.terUniHea.con.reverseAction then -1 else 1 "Switch for sign for reverse action";
 eval parameter Boolean bui.terUniHea.con.with_I = true "Boolean flag to enable integral action" /* true */;
 eval parameter Boolean bui.terUniHea.con.with_D = false "Boolean flag to enable derivative action" /* false */;
 final parameter Real bui.terUniHea.con.Dzero.k = 0 "Constant output value" /* 0 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.Dzero.y "Connector of Real output signal";
 parameter Real bui.terUniHea.con.uS_revAct.k = bui.terUniHea.con.revAct "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.uS_revAct.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.uS_revAct.y "Output signal connector";
 parameter Real bui.terUniHea.con.uSetWp.k = bui.terUniHea.con.wp "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.uSetWp.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.uSetWp.y "Output signal connector";
 parameter Real bui.terUniHea.con.uMea_revAct.k = bui.terUniHea.con.revAct "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.uMea_revAct.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.uMea_revAct.y "Output signal connector";
 final parameter Real bui.terUniHea.con.addPD.k1 = 1 "Gain for input u1" /* 1 */;
 final parameter Real bui.terUniHea.con.addPD.k2 = 1 "Gain for input u2" /* 1 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.addPD.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.addPD.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.addPD.y "Connector of Real output signal";
 parameter Real bui.terUniHea.con.gainPID.k = bui.terUniHea.con.k "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.gainPID.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.gainPID.y "Output signal connector";
 final parameter Real bui.terUniHea.con.addPID.k1 = 1 "Gain for input u1" /* 1 */;
 final parameter Real bui.terUniHea.con.addPID.k2 = 1 "Gain for input u2" /* 1 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.addPID.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.addPID.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.addPID.y "Connector of Real output signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.antWinErr.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.antWinErr.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.antWinErr.y "Connector of Real output signal";
 parameter Real bui.terUniHea.con.antWinGai.k = 1 / (bui.terUniHea.con.k * bui.terUniHea.con.Ni) "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniHea.con.antWinGai.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniHea.con.antWinGai.y "Output signal connector";
 parameter Boolean bui.terUniHea.con.cheYMinMax.k = bui.terUniHea.con.yMin < bui.terUniHea.con.yMax "Constant output value";
 discrete Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput bui.terUniHea.con.cheYMinMax.y "Connector of Boolean output signal";
 parameter String bui.terUniHea.con.assMesYMinMax.message = "LimPID: Limits must be yMin < yMax" "Message written when u becomes false" /* "LimPID: Limits must be yMin < yMax" */;
 discrete Buildings.Controls.OBC.CDL.Interfaces.BooleanInput bui.terUniHea.con.assMesYMinMax.u "Boolean input that triggers assert when it becomes false";
 Real bui.terUniHea.hex.hA.x_a(min = 0) "Factor for air side temperature dependent variation of heat transfer coefficient";
 Real bui.terUniHea.hex.hA.x_w(min = 0) "Factor for water side temperature dependent variation of heat transfer coefficient";
 initial parameter Real bui.terUniHea.hex.hA.s_w(min = 0,fixed = false) "Coefficient for temperature dependence of water side heat transfer coefficient";
 Real bui.terUniHea.hex.hA.fm_w "Fraction of actual to nominal mass flow rate";
 Real bui.terUniHea.hex.hA.fm_a "Fraction of actual to nominal mass flow rate";
 parameter Buildings.Media.Water.ThermodynamicState bui.terUniHea.hex.sta1_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Default state for medium 1";
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniHea.hex.sta2_default(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01}) "Default state for medium 2";
 initial parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.hex.cp1_nominal(fixed = false) "Specific heat capacity of medium 1 at nominal condition";
 initial parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.hex.cp2_nominal(fixed = false) "Specific heat capacity of medium 2 at nominal condition";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniHea.hex.C1_flow_nominal(fixed = false) "Nominal capacity flow rate of Medium 1";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniHea.hex.C2_flow_nominal(fixed = false) "Nominal capacity flow rate of Medium 2";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniHea.hex.CMin_flow_nominal(fixed = false) "Minimal capacity flow rate at nominal condition";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniHea.hex.CMax_flow_nominal(fixed = false) "Maximum capacity flow rate at nominal condition";
 initial parameter Real bui.terUniHea.hex.Z_nominal(min = 0,max = 1,fixed = false) "Ratio of capacity flow rate at nominal condition";
 initial parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.hex.T_b1_nominal(fixed = false) "Nominal temperature at port b1";
 initial parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniHea.hex.T_b2_nominal(fixed = false) "Nominal temperature at port b2";
 initial parameter Buildings.Fluid.Types.HeatExchangerFlowRegime bui.terUniHea.hex.flowRegime_nominal(fixed = false) "Heat exchanger flow regime at nominal flow rates";
 discrete Buildings.Fluid.Types.HeatExchangerFlowRegime bui.terUniHea.hex.flowRegime(fixed = false,start = bui.terUniHea.hex.flowRegime_nominal) "Heat exchanger flow regime";
 parameter Real bui.terUniHea.hex.delta = 0.001 "Parameter used for smoothing" /* 0.001 */;
 initial parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.hex.cp1_default(fixed = false) "Specific heat capacity of medium 1 at default medium state";
 initial parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.hex.cp2_default(fixed = false) "Specific heat capacity of medium 2 at default medium state";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniHea.hex.CMin_flow_small(fixed = false) "Small value for smoothing of minimum heat capacity flow rate";
 Real bui.terUniHea.hex.fra_a1(min = 0,max = 1) = 1 "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
 Real bui.terUniHea.hex.fra_b1(min = 0,max = 1) = 0 "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
 Real bui.terUniHea.hex.fra_a2(min = 0,max = 1) = Modelica.Fluid.Utilities.regStep(bui.terUniHea.hex.m2_flow, 1, 0, 0.0016528673093224517) "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
 Real bui.terUniHea.hex.fra_b2(min = 0,max = 1) = 1 - bui.terUniHea.hex.fra_a2 "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
 constant Boolean bui.terUniHea.hex.bal1.sensibleOnly = true "Set to true if sensible exchange only";
 constant Boolean bui.terUniHea.hex.bal1.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of the component temperature";
 constant Boolean bui.terUniHea.hex.bal1.homotopyInitialization = true "= true, use homotopy method";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.hex.bal1.Q_flow = bui.terUniHea.hex.Q1_flow "Heat transferred into the medium";
 Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.mWat_flow = bui.terUniHea.hex.mWat1_flow "Moisture mass flow rate added to the medium";
 constant Boolean bui.terUniHea.hex.bal1.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 constant Boolean bui.terUniHea.hex.bal1.vol.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";
 eval parameter Boolean bui.terUniHea.hex.bal1.vol.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean bui.terUniHea.hex.bal1.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.hex.bal1.vol.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal1.vol.hOut(unit = "J/kg",start = Buildings.Media.Water.specificEnthalpy_pTX(300000.0, 293.15, {1.0})) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal1.vol.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal1.vol.COut[0](each min = 0) "Leaving trace substances of the component";
 eval parameter Boolean bui.terUniHea.hex.bal1.vol.use_m_flowInv = true "Flag, true if m_flowInv is used in the model" /* true */;
 final parameter Real bui.terUniHea.hex.bal1.vol.s[0] = {} "Vector with zero everywhere except where species is" /* (zero-size array) */;
 Real bui.terUniHea.hex.bal1.vol.m_flowInv(unit = "s/kg") "Regularization of 1/m_flow of port_a";
 Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.vol.mXi_flow[0] "Mass flow rates of independent substances added to the medium";
 parameter Real bui.terUniHea.hex.bal1.vol.deltaReg = bui.terUniHea.hex.bal1.vol.m_flow_small / 1000.0 "Smoothing region for inverseXRegularized";
 parameter Real bui.terUniHea.hex.bal1.vol.deltaInvReg = 1 / bui.terUniHea.hex.bal1.vol.deltaReg "Inverse value of delta for inverseXRegularized";
 parameter Real bui.terUniHea.hex.bal1.vol.aReg = -15 * bui.terUniHea.hex.bal1.vol.deltaInvReg "Polynomial coefficient for inverseXRegularized";
 parameter Real bui.terUniHea.hex.bal1.vol.bReg = 119 * bui.terUniHea.hex.bal1.vol.deltaInvReg ^ 2 "Polynomial coefficient for inverseXRegularized";
 parameter Real bui.terUniHea.hex.bal1.vol.cReg = -361 * bui.terUniHea.hex.bal1.vol.deltaInvReg ^ 3 "Polynomial coefficient for inverseXRegularized";
 parameter Real bui.terUniHea.hex.bal1.vol.dReg = 534 * bui.terUniHea.hex.bal1.vol.deltaInvReg ^ 4 "Polynomial coefficient for inverseXRegularized";
 parameter Real bui.terUniHea.hex.bal1.vol.eReg = -380 * bui.terUniHea.hex.bal1.vol.deltaInvReg ^ 5 "Polynomial coefficient for inverseXRegularized";
 parameter Real bui.terUniHea.hex.bal1.vol.fReg = 104 * bui.terUniHea.hex.bal1.vol.deltaInvReg ^ 6 "Polynomial coefficient for inverseXRegularized";
 parameter Buildings.Media.Water.ThermodynamicState bui.terUniHea.hex.bal1.vol.state_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Medium state at default values";
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.hex.bal1.vol.cp_default = Buildings.Media.Water.specificHeatCapacityCp(bui.terUniHea.hex.bal1.vol.state_default) "Specific heat capacity, used to verify energy conservation";
 constant Modelica.SIunits.TemperatureDifference bui.terUniHea.hex.bal1.vol.dTMax = 200 "Maximum temperature difference across the StaticTwoPortConservationEquation" annotation(absoluteValue = false);
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.hex.bal1.vol.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.hex.bal1.vol.C_flow_internal[0] "Needed to connect to conditional connector";
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.vol.m_flow_nominal = bui.terUniHea.hex.bal1.m_flow_nominal "Nominal mass flow rate";
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.vol.m_flow_small(min = 0) = bui.terUniHea.hex.bal1.m_flow_small "Small mass flow rate for regularization of zero flow";
 structural parameter Boolean bui.terUniHea.hex.bal1.vol.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.vol.m_flow(start = 0.0) = bui.terUniHea.hex.bal1.vol.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniHea.hex.bal1.vol.dp(start = 0.0,displayUnit = "Pa") = bui.terUniHea.hex.bal1.vol.port_a.p - bui.terUniHea.hex.bal1.vol.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.vol._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal1.vol._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniHea.hex.bal1.vol.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.bal1.vol.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.hex.bal1.vol.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.hex.bal1.vol.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.hex.bal1.vol.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.hex.bal1.vol.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.bal1.vol.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.hex.bal1.vol.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.hex.bal1.vol.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.hex.bal1.vol.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.hex.bal1.vol.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Real bui.terUniHea.hex.bal1.preDro.deltaM = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs" /* 0.1 */;
 parameter Real bui.terUniHea.hex.bal1.preDro.k = 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)" /* 0 */;
 eval parameter Boolean bui.terUniHea.hex.bal1.preDro.computeFlowResistance = false "Flag to enable/disable computation of flow resistance" /* false */;
 parameter Real bui.terUniHea.hex.bal1.preDro.coeff = 0 "Precomputed coefficient to avoid division by parameter" /* 0 */;
 constant Boolean bui.terUniHea.hex.bal1.preDro.homotopyInitialization = true "= true, use homotopy method";
 eval parameter Boolean bui.terUniHea.hex.bal1.preDro.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal1.preDro.dp_nominal = 0 "Pressure drop at nominal mass flow rate" /* 0 */;
 eval parameter Boolean bui.terUniHea.hex.bal1.preDro.linearized = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.preDro.m_flow_turbulent(min = 0) = 0 "Turbulent flow if |m_flow| >= m_flow_turbulent" /* 0 */;
 parameter Buildings.Media.Water.ThermodynamicState bui.terUniHea.hex.bal1.preDro.sta_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0});
 parameter Modelica.SIunits.DynamicViscosity bui.terUniHea.hex.bal1.preDro.eta_default = Buildings.Media.Water.dynamicViscosity(bui.terUniHea.hex.bal1.preDro.sta_default) "Dynamic viscosity, used to compute transition to turbulent flow regime";
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.preDro.m_flow_nominal_pos = abs(bui.terUniHea.hex.bal1.preDro.m_flow_nominal) "Absolute value of nominal flow rate";
 structural parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal1.preDro.dp_nominal_pos = 0.0 "Absolute value of nominal pressure difference" /* 0.0 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.preDro.m_flow_nominal = bui.terUniHea.hex.bal1.m_flow_nominal "Nominal mass flow rate";
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.preDro.m_flow_small(min = 0) = 1.0E-4 * abs(bui.terUniHea.hex.bal1.preDro.m_flow_nominal) "Small mass flow rate for regularization of zero flow";
 structural parameter Boolean bui.terUniHea.hex.bal1.preDro.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.preDro.m_flow(nominal = if bui.terUniHea.hex.bal1.preDro.m_flow_nominal_pos > 1.0E-15 then bui.terUniHea.hex.bal1.preDro.m_flow_nominal_pos else 1,start = 0.0) = bui.terUniHea.hex.bal1.preDro.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniHea.hex.bal1.preDro.dp(nominal = 1,start = 0.0,displayUnit = "Pa") = bui.terUniHea.hex.bal1.preDro.port_a.p - bui.terUniHea.hex.bal1.preDro.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.preDro._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal1.preDro._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniHea.hex.bal1.preDro.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.bal1.preDro.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.hex.bal1.preDro.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.hex.bal1.preDro.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.hex.bal1.preDro.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.hex.bal1.preDro.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.bal1.preDro.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.hex.bal1.preDro.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.hex.bal1.preDro.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.hex.bal1.preDro.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.hex.bal1.preDro.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal1.hOut(unit = "J/kg") "Leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal1.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal1.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal1.heaInp.y = bui.terUniHea.hex.bal1.Q_flow "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal1.masExc.y = bui.terUniHea.hex.bal1.mWat_flow "Value of Real output";
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.m_flow_nominal = bui.terUniHea.hex.m1_flow_nominal "Nominal mass flow rate";
 parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.m_flow_small(min = 0) = bui.terUniHea.hex.m1_flow_small "Small mass flow rate for regularization of zero flow";
 structural parameter Boolean bui.terUniHea.hex.bal1.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1.m_flow(start = 0.0) = bui.terUniHea.hex.bal1.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniHea.hex.bal1.dp(start = 0.0,displayUnit = "Pa") = bui.terUniHea.hex.bal1.port_a.p - bui.terUniHea.hex.bal1.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal1._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal1._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniHea.hex.bal1.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.bal1.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.hex.bal1.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.hex.bal1.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.hex.bal1.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.hex.bal1.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniHea.hex.bal1.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniHea.hex.bal1.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniHea.hex.bal1.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniHea.hex.bal1.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniHea.hex.bal1.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.terUniHea.hex.bal1.computeFlowResistance = false "=true, compute flow resistance. Set to false to assume no friction" /* false */;
 eval parameter Boolean bui.terUniHea.hex.bal1.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal1.dp_nominal = 0 "Pressure difference" /* 0 */;
 structural parameter Boolean bui.terUniHea.hex.bal1.linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real bui.terUniHea.hex.bal1.deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 constant Boolean bui.terUniHea.hex.bal2.sensibleOnly = true "Set to true if sensible exchange only";
 constant Boolean bui.terUniHea.hex.bal2.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of the component temperature";
 constant Boolean bui.terUniHea.hex.bal2.homotopyInitialization = true "= true, use homotopy method";
 Modelica.SIunits.HeatFlowRate bui.terUniHea.hex.bal2.Q_flow = bui.terUniHea.hex.Q2_flow "Heat transferred into the medium";
 Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.mWat_flow = bui.terUniHea.hex.mWat2_flow "Moisture mass flow rate added to the medium";
 constant Boolean bui.terUniHea.hex.bal2.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 constant Boolean bui.terUniHea.hex.bal2.vol.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";
 eval parameter Boolean bui.terUniHea.hex.bal2.vol.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean bui.terUniHea.hex.bal2.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.hex.bal2.vol.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal2.vol.hOut(unit = "J/kg",start = Buildings.Media.Air.specificEnthalpy_pTX(101325.0, 293.15, {0.01, 0.99})) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal2.vol.XiOut[1](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal2.vol.COut[0](each min = 0) "Leaving trace substances of the component";
 eval parameter Boolean bui.terUniHea.hex.bal2.vol.use_m_flowInv = true "Flag, true if m_flowInv is used in the model" /* true */;
 final parameter Real bui.terUniHea.hex.bal2.vol.s[1] = {1} "Vector with zero everywhere except where species is" /* { 1 } */;
 Real bui.terUniHea.hex.bal2.vol.m_flowInv(unit = "s/kg") "Regularization of 1/m_flow of port_a";
 Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.vol.mXi_flow[1] "Mass flow rates of independent substances added to the medium";
 structural parameter Real bui.terUniHea.hex.bal2.vol.deltaReg = 1.6528673093224517E-6 "Smoothing region for inverseXRegularized" /* 1.6528673093224517E-6 */;
 structural parameter Real bui.terUniHea.hex.bal2.vol.deltaInvReg = 605009.2432464666 "Inverse value of delta for inverseXRegularized" /* 605009.2432464666 */;
 structural parameter Real bui.terUniHea.hex.bal2.vol.aReg = -9075138.648697 "Polynomial coefficient for inverseXRegularized" /* -9075138.648697 */;
 structural parameter Real bui.terUniHea.hex.bal2.vol.bReg = 4.3558305945225805E13 "Polynomial coefficient for inverseXRegularized" /* 4.3558305945225805E13 */;
 structural parameter Real bui.terUniHea.hex.bal2.vol.cReg = -7.994535425078913E19 "Polynomial coefficient for inverseXRegularized" /* -7.994535425078913E19 */;
 structural parameter Real bui.terUniHea.hex.bal2.vol.dReg = 7.154664875226009E25 "Polynomial coefficient for inverseXRegularized" /* 7.154664875226009E25 */;
 structural parameter Real bui.terUniHea.hex.bal2.vol.eReg = -3.080304466479727E31 "Polynomial coefficient for inverseXRegularized" /* -3.080304466479727E31 */;
 structural parameter Real bui.terUniHea.hex.bal2.vol.fReg = 5.100413634744618E36 "Polynomial coefficient for inverseXRegularized" /* 5.100413634744618E36 */;
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniHea.hex.bal2.vol.state_default(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01}) "Medium state at default values";
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.hex.bal2.vol.cp_default = Buildings.Media.Air.specificHeatCapacityCp(bui.terUniHea.hex.bal2.vol.state_default) "Specific heat capacity, used to verify energy conservation";
 constant Modelica.SIunits.TemperatureDifference bui.terUniHea.hex.bal2.vol.dTMax = 200 "Maximum temperature difference across the StaticTwoPortConservationEquation" annotation(absoluteValue = false);
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.hex.bal2.vol.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.hex.bal2.vol.C_flow_internal[0] "Needed to connect to conditional connector";
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.vol.m_flow_nominal = 16.528673093224516 "Nominal mass flow rate" /* 16.528673093224516 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.vol.m_flow_small = 0.0016528673093224517 "Small mass flow rate for regularization of zero flow" /* 0.0016528673093224517 */;
 structural parameter Boolean bui.terUniHea.hex.bal2.vol.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.vol.m_flow(start = 0.0) = bui.terUniHea.hex.bal2.vol.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniHea.hex.bal2.vol.dp(start = 0.0,displayUnit = "Pa") = bui.terUniHea.hex.bal2.vol.port_a.p - bui.terUniHea.hex.bal2.vol.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.vol._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal2.vol._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniHea.hex.bal2.vol.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.bal2.vol.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.hex.bal2.vol.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.hex.bal2.vol.port_a.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.hex.bal2.vol.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.hex.bal2.vol.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.bal2.vol.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.hex.bal2.vol.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.hex.bal2.vol.port_b.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.hex.bal2.vol.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.hex.bal2.vol.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Real bui.terUniHea.hex.bal2.preDro.deltaM = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs" /* 0.1 */;
 parameter Real bui.terUniHea.hex.bal2.preDro.k = if 200.0 > 1.0E-15 then 16.528673093224516 / sqrt(200.0) else 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)" /* 1.1687536828234684 */;
 eval parameter Boolean bui.terUniHea.hex.bal2.preDro.computeFlowResistance = true "Flag to enable/disable computation of flow resistance" /* true */;
 parameter Real bui.terUniHea.hex.bal2.preDro.coeff = 0 "Precomputed coefficient to avoid division by parameter" /* 0 */;
 constant Boolean bui.terUniHea.hex.bal2.preDro.homotopyInitialization = true "= true, use homotopy method";
 eval parameter Boolean bui.terUniHea.hex.bal2.preDro.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal2.preDro.dp_nominal = 200 "Pressure drop at nominal mass flow rate" /* 200 */;
 eval parameter Boolean bui.terUniHea.hex.bal2.preDro.linearized = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.preDro.m_flow_turbulent = 1.6528673093224517 "Turbulent flow if |m_flow| >= m_flow_turbulent" /* 1.6528673093224517 */;
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniHea.hex.bal2.preDro.sta_default(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01, 0.99});
 parameter Modelica.SIunits.DynamicViscosity bui.terUniHea.hex.bal2.preDro.eta_default = Buildings.Media.Air.dynamicViscosity(bui.terUniHea.hex.bal2.preDro.sta_default) "Dynamic viscosity, used to compute transition to turbulent flow regime";
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.preDro.m_flow_nominal_pos = 16.528673093224516 "Absolute value of nominal flow rate" /* 16.528673093224516 */;
 structural parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal2.preDro.dp_nominal_pos = 200.0 "Absolute value of nominal pressure difference" /* 200.0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.preDro.m_flow_nominal = 16.528673093224516 "Nominal mass flow rate" /* 16.528673093224516 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.preDro.m_flow_small = 0.0016528673093224517 "Small mass flow rate for regularization of zero flow" /* 0.0016528673093224517 */;
 structural parameter Boolean bui.terUniHea.hex.bal2.preDro.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.preDro.m_flow(nominal = 16.528673093224516,start = 0.0) = bui.terUniHea.hex.bal2.preDro.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniHea.hex.bal2.preDro.dp(nominal = 200.0,start = 0.0,displayUnit = "Pa") = bui.terUniHea.hex.bal2.preDro.port_a.p - bui.terUniHea.hex.bal2.preDro.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.preDro._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal2.preDro._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniHea.hex.bal2.preDro.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.bal2.preDro.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.hex.bal2.preDro.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.hex.bal2.preDro.port_a.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.hex.bal2.preDro.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.hex.bal2.preDro.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.bal2.preDro.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.hex.bal2.preDro.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.hex.bal2.preDro.port_b.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.hex.bal2.preDro.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.hex.bal2.preDro.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal2.hOut(unit = "J/kg") "Leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal2.XiOut[1](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal2.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal2.heaInp.y = bui.terUniHea.hex.bal2.Q_flow "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniHea.hex.bal2.masExc.y = bui.terUniHea.hex.bal2.mWat_flow "Value of Real output";
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.m_flow_nominal = 16.528673093224516 "Nominal mass flow rate" /* 16.528673093224516 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.m_flow_small = 0.0016528673093224517 "Small mass flow rate for regularization of zero flow" /* 0.0016528673093224517 */;
 structural parameter Boolean bui.terUniHea.hex.bal2.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2.m_flow(start = 0.0) = bui.terUniHea.hex.bal2.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniHea.hex.bal2.dp(start = 0.0,displayUnit = "Pa") = bui.terUniHea.hex.bal2.port_a.p - bui.terUniHea.hex.bal2.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniHea.hex.bal2._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal2._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniHea.hex.bal2.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.bal2.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.hex.bal2.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.hex.bal2.port_a.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.hex.bal2.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.hex.bal2.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniHea.hex.bal2.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniHea.hex.bal2.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniHea.hex.bal2.port_b.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniHea.hex.bal2.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniHea.hex.bal2.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.terUniHea.hex.bal2.computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction" /* true */;
 eval parameter Boolean bui.terUniHea.hex.bal2.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniHea.hex.bal2.dp_nominal = 200 "Pressure difference" /* 200 */;
 structural parameter Boolean bui.terUniHea.hex.bal2.linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real bui.terUniHea.hex.bal2.deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 Buildings.Media.Water.ThermodynamicState bui.terUniHea.hex.state_a1_inflow(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(bui.terUniHea.hex.port_a1.p, inStream(bui.terUniHea.hex.port_a1.h_outflow), inStream(bui.terUniHea.hex.port_a1.Xi_outflow[1:0])) "state for medium inflowing through port_a1";
 Buildings.Media.Water.ThermodynamicState bui.terUniHea.hex.state_b1_inflow(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(bui.terUniHea.hex.port_b1.p, inStream(bui.terUniHea.hex.port_b1.h_outflow), inStream(bui.terUniHea.hex.port_b1.Xi_outflow[1:0])) "state for medium inflowing through port_b1";
 Buildings.Media.Air.ThermodynamicState bui.terUniHea.hex.state_a2_inflow(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_phX(bui.terUniHea.hex.port_a2.p, inStream(bui.terUniHea.hex.port_a2.h_outflow), inStream(bui.terUniHea.hex.port_a2.Xi_outflow[1:1])) "state for medium inflowing through port_a2";
 Buildings.Media.Air.ThermodynamicState bui.terUniHea.hex.state_b2_inflow(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_phX(bui.terUniHea.hex.port_b2.p, inStream(bui.terUniHea.hex.port_b2.h_outflow), inStream(bui.terUniHea.hex.port_b2.Xi_outflow[1:1])) "state for medium inflowing through port_b2";
 constant Boolean bui.terUniHea.sinAir.checkWaterPressure = false "Evaluates to true if the pressure should be checked";
 constant Boolean bui.terUniHea.sinAir.checkAirPressure = true "Evaluates to true if the pressure should be checked";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.sinAir.T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.sinAir.h_internal = Buildings.Media.Air.specificEnthalpy(Buildings.Media.Air.setState_pTX(bui.terUniHea.sinAir.p_in_internal, bui.terUniHea.sinAir.T_in_internal, bui.terUniHea.sinAir.X_in_internal[1:2])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection bui.terUniHea.sinAir.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.sinAir.p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.sinAir.Xi_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.sinAir.X_in_internal[2](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.sinAir.C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 constant Boolean bui.terUniHea.retAir.checkWaterPressure = false "Evaluates to true if the pressure should be checked";
 constant Boolean bui.terUniHea.retAir.checkAirPressure = true "Evaluates to true if the pressure should be checked";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.retAir.T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.retAir.h_internal = Buildings.Media.Air.specificEnthalpy(Buildings.Media.Air.setState_pTX(bui.terUniHea.retAir.p_in_internal, bui.terUniHea.retAir.T_in_internal, bui.terUniHea.retAir.X_in_internal[1:2])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection bui.terUniHea.retAir.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.retAir.p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.retAir.Xi_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.retAir.X_in_internal[2](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniHea.retAir.C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 parameter Modelica.SIunits.ThermalConductance bui.terUniHea.TLoaODE.G = -167690.0 / (bui.terUniHea.TLoaODE.TOutHea_nominal - bui.terUniHea.TLoaODE.TIndHea_nominal) "Lumped thermal conductance representing all temperature dependent heat transfer mechanisms";
 structural parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.cpHeaWat_nominal = 4184 "Heating water specific heat capacity at nominal conditions" /* 4184 */;
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.cpChiWat_nominal = Buildings.Media.Water.specificHeatCapacityCp(Buildings.Media.Water.setState_pTX(300000.0, bui.terUniHea.T_aChiWat_nominal, global(Buildings.Media.Water.reference_X[1:1]))) "Chilled water specific heat capacity at nominal conditions";
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.cpLoaHea_nominal = Buildings.Media.Air.specificHeatCapacityCp(Buildings.Media.Air.setState_pTX(101325.0, bui.terUniHea.T_aLoaHea_nominal, global(Buildings.Media.Air.reference_X[1:2]))) "Load side fluid specific heat capacity at nominal conditions in heating mode";
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniHea.cpLoaCoo_nominal = Buildings.Media.Air.specificHeatCapacityCp(Buildings.Media.Air.setState_pTX(101325.0, bui.terUniHea.T_aLoaCoo_nominal, global(Buildings.Media.Air.reference_X[1:2]))) "Load side fluid specific heat capacity at nominal conditions in cooling mode";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sou_m_flow[1].m_flow_in_internal(final unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sou_m_flow[1].T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sou_m_flow[1].h_internal = Buildings.Media.Water.specificEnthalpy(Buildings.Media.Water.setState_pTX(bui.disFloHea.sou_m_flow[1].p_in_internal, bui.disFloHea.sou_m_flow[1].T_in_internal, bui.disFloHea.sou_m_flow[1].X_in_internal[1:1])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection bui.disFloHea.sou_m_flow[1].flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sou_m_flow[1].p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sou_m_flow[1].Xi_in_internal[0](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sou_m_flow[1].X_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sou_m_flow[1].C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 constant Boolean bui.disFloHea.sin.checkWaterPressure = true "Evaluates to true if the pressure should be checked";
 constant Boolean bui.disFloHea.sin.checkAirPressure = false "Evaluates to true if the pressure should be checked";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sin.T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sin.h_internal = Buildings.Media.Water.specificEnthalpy(Buildings.Media.Water.setState_pTX(bui.disFloHea.sin.p_in_internal, bui.disFloHea.sin.T_in_internal, bui.disFloHea.sin.X_in_internal[1:1])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection bui.disFloHea.sin.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sin.p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sin.Xi_in_internal[0](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sin.X_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.sin.C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.pipPre.m_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.pipPre.dp_internal(unit = "Pa") "Needed to connect to conditional connector";
 parameter Modelica.SIunits.ThermodynamicTemperature bui.disFloHea.heaCoo.preHea.T_ref = 293.15 "Reference temperature" /* 293.15 */;
 final parameter Modelica.SIunits.LinearTemperatureCoefficient bui.disFloHea.heaCoo.preHea.alpha = 0 "Temperature coefficient of heat flow rate" /* 0 */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.heaCoo.preHea.Q_flow(unit = "W");
 Modelica.SIunits.ThermodynamicTemperature bui.disFloHea.heaCoo.preHea.port.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.disFloHea.heaCoo.preHea.port.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 final parameter Real bui.disFloHea.heaCoo.gai.k = -1 "Gain value multiplied with input signal" /* -1 */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.heaCoo.gai.u "Input signal connector";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.gai.y "Output signal connector";
 eval parameter Boolean bui.disFloHea.heaCoo.vol.dynBal.initialize_p = false "= true to set up initial equations for pressure" /* false */;
 constant Boolean bui.disFloHea.heaCoo.vol.dynBal.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";
 eval parameter Integer bui.disFloHea.heaCoo.vol.dynBal.nPorts = 2 "Number of ports" /* 2 */;
 eval parameter Boolean bui.disFloHea.heaCoo.vol.dynBal.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean bui.disFloHea.heaCoo.vol.dynBal.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.heaCoo.vol.dynBal.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.dynBal.hOut(unit = "J/kg",start = bui.disFloHea.heaCoo.vol.dynBal.hStart) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.dynBal.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.dynBal.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.dynBal.UOut(unit = "J") "Internal energy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.dynBal.mXiOut[0](each min = 0,each unit = "kg") "Species mass of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.dynBal.mOut(min = 0,unit = "kg") "Mass of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.dynBal.mCOut[0](each min = 0,each unit = "kg") "Trace substance mass of the component";
 Buildings.Media.Water.MassFlowRate bui.disFloHea.heaCoo.vol.dynBal.ports[1].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.vol.dynBal.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.heaCoo.vol.dynBal.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.vol.dynBal.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.vol.dynBal.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloHea.heaCoo.vol.dynBal.ports[2].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.vol.dynBal.ports[2].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloHea.heaCoo.vol.dynBal.ports[2].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.vol.dynBal.ports[2].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.vol.dynBal.ports[2].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.Temperature bui.disFloHea.heaCoo.vol.dynBal.medium.T(start = bui.disFloHea.heaCoo.vol.dynBal.T_start,stateSelect = StateSelect.default) "Temperature of medium";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol.dynBal.medium.InputAbsolutePressure bui.disFloHea.heaCoo.vol.dynBal.medium.p(start = bui.disFloHea.heaCoo.vol.dynBal.p_start) "Absolute pressure of medium";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol.dynBal.medium.InputMassFraction bui.disFloHea.heaCoo.vol.dynBal.medium.Xi[0](start = bui.disFloHea.heaCoo.vol.dynBal.X_start[1:0]) = fill(0, 0) "Structurally independent mass fractions";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol.dynBal.medium.InputSpecificEnthalpy bui.disFloHea.heaCoo.vol.dynBal.medium.h(start = bui.disFloHea.heaCoo.vol.dynBal.hStart) "Specific enthalpy of medium";
 Modelica.SIunits.SpecificEnergy bui.disFloHea.heaCoo.vol.dynBal.medium.u "Specific internal energy of medium";
 Modelica.SIunits.Density bui.disFloHea.heaCoo.vol.dynBal.medium.d(start = bui.disFloHea.heaCoo.vol.dynBal.rho_start) = 995.586 "Density of medium";
 Modelica.SIunits.MassFraction bui.disFloHea.heaCoo.vol.dynBal.medium.X[1](start = bui.disFloHea.heaCoo.vol.dynBal.X_start[1:1]) = {1} "Mass fractions (= (component mass)/total mass  m_i/m)";
 Modelica.SIunits.SpecificHeatCapacity bui.disFloHea.heaCoo.vol.dynBal.medium.R = 0 "Gas constant (of mixture if applicable)";
 Modelica.SIunits.MolarMass bui.disFloHea.heaCoo.vol.dynBal.medium.MM = 0.018015268 "Molar mass (of mixture or single fluid)";
 Buildings.Media.Water.ThermodynamicState bui.disFloHea.heaCoo.vol.dynBal.medium.state(p(start = 300000.0),T(start = 293.15)) "Thermodynamic state record for optional functions";
 eval parameter Boolean bui.disFloHea.heaCoo.vol.dynBal.medium.preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium" /* false */;
 final parameter Boolean bui.disFloHea.heaCoo.vol.dynBal.medium.standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones" /* true */;
 Modelica.SIunits.Conversions.NonSIunits.Temperature_degC bui.disFloHea.heaCoo.vol.dynBal.medium.T_degC = Modelica.SIunits.Conversions.to_degC(bui.disFloHea.heaCoo.vol.dynBal.medium.T) "Temperature of medium in [degC]";
 Modelica.SIunits.Conversions.NonSIunits.Pressure_bar bui.disFloHea.heaCoo.vol.dynBal.medium.p_bar = Modelica.SIunits.Conversions.to_bar(bui.disFloHea.heaCoo.vol.dynBal.medium.p) "Absolute pressure of medium in [bar]";
 Modelica.SIunits.Energy bui.disFloHea.heaCoo.vol.dynBal.U(start = bui.disFloHea.heaCoo.vol.dynBal.fluidVolume * bui.disFloHea.heaCoo.vol.dynBal.rho_start * Buildings.Media.Water.specificInternalEnergy(Buildings.Media.Water.setState_pTX(bui.disFloHea.heaCoo.vol.dynBal.p_start, bui.disFloHea.heaCoo.vol.dynBal.T_start, bui.disFloHea.heaCoo.vol.dynBal.X_start[1:0])) + (bui.disFloHea.heaCoo.vol.dynBal.T_start - 273.15) * bui.disFloHea.heaCoo.vol.dynBal.CSen,nominal = 100000.0) "Internal energy of fluid";
 Modelica.SIunits.Mass bui.disFloHea.heaCoo.vol.dynBal.m(start = bui.disFloHea.heaCoo.vol.V * bui.disFloHea.heaCoo.vol.rho_start,stateSelect = StateSelect.prefer) "Mass of fluid";
 Modelica.SIunits.Mass bui.disFloHea.heaCoo.vol.dynBal.mXi[0](start = bui.disFloHea.heaCoo.vol.dynBal.fluidVolume * bui.disFloHea.heaCoo.vol.dynBal.rho_start * bui.disFloHea.heaCoo.vol.dynBal.X_start[1:0]) "Masses of independent components in the fluid";
 Modelica.SIunits.Mass bui.disFloHea.heaCoo.vol.dynBal.mC[0](start = bui.disFloHea.heaCoo.vol.dynBal.fluidVolume * bui.disFloHea.heaCoo.vol.dynBal.rho_start * bui.disFloHea.heaCoo.vol.dynBal.C_start[1:0]) "Masses of trace substances in the fluid";
 Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.vol.dynBal.C[0](nominal = bui.disFloHea.heaCoo.vol.dynBal.C_nominal[1:0]) "Trace substance mixture content";
 Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.vol.dynBal.mb_flow "Mass flows across boundaries";
 Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.vol.dynBal.mbXi_flow[0] "Substance mass flows across boundaries";
 Buildings.Media.Water.ExtraPropertyFlowRate bui.disFloHea.heaCoo.vol.dynBal.mbC_flow[0] "Trace substance mass flows across boundaries";
 Modelica.SIunits.EnthalpyFlowRate bui.disFloHea.heaCoo.vol.dynBal.Hb_flow "Enthalpy flow across boundaries or energy source/sink";
 parameter Modelica.SIunits.Volume bui.disFloHea.heaCoo.vol.dynBal.fluidVolume = bui.disFloHea.heaCoo.vol.V "Volume";
 parameter Modelica.SIunits.HeatCapacity bui.disFloHea.heaCoo.vol.dynBal.CSen = (1.0 - 1) * bui.disFloHea.heaCoo.vol.dynBal.rho_default * bui.disFloHea.heaCoo.vol.dynBal.cp_default * bui.disFloHea.heaCoo.vol.dynBal.fluidVolume "Aditional heat capacity for implementing mFactor";
 Buildings.Media.Water.EnthalpyFlowRate bui.disFloHea.heaCoo.vol.dynBal.ports_H_flow[2];
 Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.vol.dynBal.ports_mXi_flow[2,0];
 Buildings.Media.Water.ExtraPropertyFlowRate bui.disFloHea.heaCoo.vol.dynBal.ports_mC_flow[2,0];
 parameter Modelica.SIunits.SpecificHeatCapacity bui.disFloHea.heaCoo.vol.dynBal.cp_default = Buildings.Media.Water.specificHeatCapacityCp(bui.disFloHea.heaCoo.vol.dynBal.state_default) "Heat capacity, to compute additional dry mass";
 parameter Modelica.SIunits.Density bui.disFloHea.heaCoo.vol.dynBal.rho_start = Buildings.Media.Water.density(Buildings.Media.Water.setState_pTX(bui.disFloHea.heaCoo.vol.dynBal.p_start, bui.disFloHea.heaCoo.vol.dynBal.T_start, bui.disFloHea.heaCoo.vol.dynBal.X_start[1:0])) "Density, used to compute fluid mass";
 eval parameter Boolean bui.disFloHea.heaCoo.vol.dynBal.computeCSen = false /* false */;
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloHea.heaCoo.vol.dynBal.state_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Medium state at default values";
 parameter Modelica.SIunits.Density bui.disFloHea.heaCoo.vol.dynBal.rho_default = Buildings.Media.Water.density(bui.disFloHea.heaCoo.vol.dynBal.state_default) "Density, used to compute fluid mass";
 final parameter Real bui.disFloHea.heaCoo.vol.dynBal.s[0] = {} "Vector with zero everywhere except where species is" /* (zero-size array) */;
 parameter Modelica.SIunits.SpecificEnergy bui.disFloHea.heaCoo.vol.dynBal.hStart = Buildings.Media.Water.specificEnthalpy_pTX(bui.disFloHea.heaCoo.vol.dynBal.p_start, bui.disFloHea.heaCoo.vol.dynBal.T_start, bui.disFloHea.heaCoo.vol.dynBal.X_start[1:1]) "Start value for specific enthalpy";
 constant Boolean bui.disFloHea.heaCoo.vol.dynBal._simplify_mWat_flow = false "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.heaCoo.vol.dynBal.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.heaCoo.vol.dynBal.C_flow_internal[0] "Needed to connect to conditional connector";
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.heaCoo.vol.dynBal.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.heaCoo.vol.dynBal.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.heaCoo.vol.dynBal.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloHea.heaCoo.vol.dynBal.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Water.AbsolutePressure bui.disFloHea.heaCoo.vol.dynBal.p_start(start = 300000.0) = bui.disFloHea.heaCoo.vol.p_start "Start value of pressure";
 parameter Buildings.Media.Water.Temperature bui.disFloHea.heaCoo.vol.dynBal.T_start(start = 293.15) = bui.disFloHea.heaCoo.vol.T_start "Start value of temperature";
 parameter Buildings.Media.Water.MassFraction bui.disFloHea.heaCoo.vol.dynBal.X_start[1](quantity = {"SimpleLiquidWater"}) = bui.disFloHea.heaCoo.vol.X_start[1:1] "Start value of mass fractions m_i/m";
 parameter Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.vol.dynBal.C_start[0](quantity = fill("", 0)) = bui.disFloHea.heaCoo.vol.C_start[1:0] "Start value of trace substances";
 parameter Buildings.Media.Water.ExtraProperty bui.disFloHea.heaCoo.vol.dynBal.C_nominal[0](quantity = fill("", 0)) = bui.disFloHea.heaCoo.vol.C_nominal[1:0] "Nominal value of trace substances. (Set to typical order of magnitude.)";
 structural parameter Real bui.disFloHea.heaCoo.vol.dynBal.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 parameter Modelica.SIunits.Density bui.disFloHea.heaCoo.vol.rho_start = Buildings.Media.Water.density(bui.disFloHea.heaCoo.vol.state_start) "Density, used to compute start and guess values";
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloHea.heaCoo.vol.state_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Medium state at default values";
 parameter Modelica.SIunits.Density bui.disFloHea.heaCoo.vol.rho_default = Buildings.Media.Water.density(bui.disFloHea.heaCoo.vol.state_default) "Density, used to compute fluid mass";
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloHea.heaCoo.vol.state_start(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(bui.disFloHea.heaCoo.vol.p_start, bui.disFloHea.heaCoo.vol.T_start, bui.disFloHea.heaCoo.vol.X_start[1:0]) "Medium state at start values";
 eval parameter Boolean bui.disFloHea.heaCoo.vol.useSteadyStateTwoPort = false "Flag, true if the model has two ports only and uses a steady state balance" /* false */;
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.hOut_internal(unit = "J/kg") "Internal connector for leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.XiOut_internal[0](each unit = "1") "Internal connector for leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.COut_internal[0](each unit = "1") "Internal connector for leaving trace substances of the component";
 Modelica.SIunits.ThermodynamicTemperature bui.disFloHea.heaCoo.vol.preTem.port.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.disFloHea.heaCoo.vol.preTem.port.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.Blocks.Interfaces.RealInput bui.disFloHea.heaCoo.vol.preTem.T;
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.portT.y = bui.disFloHea.heaCoo.vol.T "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloHea.heaCoo.vol.heaFloSen.Q_flow(unit = "W") "Heat flow from port_a to port_b as output signal";
 Modelica.SIunits.ThermodynamicTemperature bui.disFloHea.heaCoo.vol.heaFloSen.port_a.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.disFloHea.heaCoo.vol.heaFloSen.port_a.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.SIunits.ThermodynamicTemperature bui.disFloHea.heaCoo.vol.heaFloSen.port_b.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.disFloHea.heaCoo.vol.heaFloSen.port_b.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 eval parameter Boolean bui.disFloHea.heaCoo.preDro.computeFlowResistance = false "Flag to enable/disable computation of flow resistance" /* false */;
 final parameter Real bui.disFloHea.heaCoo.preDro.coeff = 0 "Precomputed coefficient to avoid division by parameter" /* 0 */;
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloHea.heaCoo.preDro.sta_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0});
 parameter Modelica.SIunits.DynamicViscosity bui.disFloHea.heaCoo.preDro.eta_default = Buildings.Media.Water.dynamicViscosity(bui.disFloHea.heaCoo.preDro.sta_default) "Dynamic viscosity, used to compute transition to turbulent flow regime";
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.preDro.m_flow_nominal_pos = 8.015774378585085 "Absolute value of nominal flow rate" /* 8.015774378585085 */;
 structural parameter Modelica.SIunits.Pressure bui.disFloHea.heaCoo.preDro.dp_nominal_pos = 0.0 "Absolute value of nominal pressure difference" /* 0.0 */;
 final parameter Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo.preDro._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.disFloHea.heaCoo.preDro._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloHea.heaCoo.sta_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0});
 parameter Modelica.SIunits.Density bui.disFloHea.heaCoo.rho_default = Buildings.Media.Water.density(bui.disFloHea.heaCoo.sta_default) "Density, used to compute fluid volume";
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloHea.heaCoo.sta_start(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(bui.disFloHea.heaCoo.p_start, bui.disFloHea.heaCoo.T_start, bui.disFloHea.heaCoo.X_start[1:1]);
 parameter Modelica.SIunits.SpecificEnergy bui.disFloHea.heaCoo.h_outflow_start = Buildings.Media.Water.specificEnthalpy(bui.disFloHea.heaCoo.sta_start) "Start value for outflowing enthalpy";
 final parameter Modelica.SIunits.MassFlowRate bui.disFloHea.heaCoo._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.disFloHea.heaCoo._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloHea.mDis_flow_nominal[1] = {8.015774378585085} "Distribution flow rate between each connected unit at nominal conditions" /* { 8.015774378585085 } */;
 structural parameter Real bui.disFloHea.kDis[1] = {0.050696208492699374} "Flow coefficient between each connected unit at nominal conditions" /* { 0.050696208492699374 } */;
 Modelica.SIunits.MassFlowRate bui.disFloHea.mDis_flow[1] = {sum(bui.disFloHea.mReq_flow[1:1])} "Distribution flow rate between each connected unit";
 Modelica.SIunits.Pressure bui.disFloHea.dpDis[1] = (bui.disFloHea.mDis_flow[1:1] ./ {0.050696208492699374}) .^ 2 "Pressure drop between each connected unit (supply line)";
 Modelica.SIunits.Pressure bui.disFloHea.dpPum(displayUnit = "Pa") = 100000.0 "Pump head";
 Modelica.SIunits.MassFlowRate bui.disFloHea.mPum_flow = sum(bui.disFloHea.mReq_flow[1:1]) "Pump mass flow rate";
 structural parameter Buildings.Media.Water.ThermodynamicState bui.disFloHea.sta_default = Buildings.Media.Water.ThermodynamicState(300000, 293.15) /* Buildings.Media.Water.ThermodynamicState(300000, 293.15) */;
 structural parameter Modelica.SIunits.Density bui.disFloHea.rho_default = 995.586 "Density, used to compute fluid volume" /* 995.586 */;
 final parameter Modelica.SIunits.MassFlowRate bui.disFloHea._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.disFloHea._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sou_m_flow[1].m_flow_in_internal(final unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sou_m_flow[1].T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sou_m_flow[1].h_internal = Buildings.Media.Water.specificEnthalpy(Buildings.Media.Water.setState_pTX(bui.disFloCoo.sou_m_flow[1].p_in_internal, bui.disFloCoo.sou_m_flow[1].T_in_internal, bui.disFloCoo.sou_m_flow[1].X_in_internal[1:1])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection bui.disFloCoo.sou_m_flow[1].flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sou_m_flow[1].p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sou_m_flow[1].Xi_in_internal[0](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sou_m_flow[1].X_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sou_m_flow[1].C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 constant Boolean bui.disFloCoo.sin.checkWaterPressure = true "Evaluates to true if the pressure should be checked";
 constant Boolean bui.disFloCoo.sin.checkAirPressure = false "Evaluates to true if the pressure should be checked";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sin.T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sin.h_internal = Buildings.Media.Water.specificEnthalpy(Buildings.Media.Water.setState_pTX(bui.disFloCoo.sin.p_in_internal, bui.disFloCoo.sin.T_in_internal, bui.disFloCoo.sin.X_in_internal[1:1])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection bui.disFloCoo.sin.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sin.p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sin.Xi_in_internal[0](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sin.X_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.sin.C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.pipPre.m_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.pipPre.dp_internal(unit = "Pa") "Needed to connect to conditional connector";
 parameter Modelica.SIunits.ThermodynamicTemperature bui.disFloCoo.heaCoo.preHea.T_ref = 293.15 "Reference temperature" /* 293.15 */;
 final parameter Modelica.SIunits.LinearTemperatureCoefficient bui.disFloCoo.heaCoo.preHea.alpha = 0 "Temperature coefficient of heat flow rate" /* 0 */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.heaCoo.preHea.Q_flow(unit = "W");
 Modelica.SIunits.ThermodynamicTemperature bui.disFloCoo.heaCoo.preHea.port.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.disFloCoo.heaCoo.preHea.port.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 final parameter Real bui.disFloCoo.heaCoo.gai.k = -1 "Gain value multiplied with input signal" /* -1 */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.heaCoo.gai.u "Input signal connector";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.gai.y "Output signal connector";
 eval parameter Boolean bui.disFloCoo.heaCoo.vol.dynBal.initialize_p = false "= true to set up initial equations for pressure" /* false */;
 constant Boolean bui.disFloCoo.heaCoo.vol.dynBal.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";
 eval parameter Integer bui.disFloCoo.heaCoo.vol.dynBal.nPorts = 2 "Number of ports" /* 2 */;
 eval parameter Boolean bui.disFloCoo.heaCoo.vol.dynBal.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean bui.disFloCoo.heaCoo.vol.dynBal.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.heaCoo.vol.dynBal.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.dynBal.hOut(unit = "J/kg",start = bui.disFloCoo.heaCoo.vol.dynBal.hStart) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.dynBal.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.dynBal.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.dynBal.UOut(unit = "J") "Internal energy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.dynBal.mXiOut[0](each min = 0,each unit = "kg") "Species mass of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.dynBal.mOut(min = 0,unit = "kg") "Mass of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.dynBal.mCOut[0](each min = 0,each unit = "kg") "Trace substance mass of the component";
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.heaCoo.vol.dynBal.ports[1].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.vol.dynBal.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.heaCoo.vol.dynBal.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.vol.dynBal.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.vol.dynBal.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.disFloCoo.heaCoo.vol.dynBal.ports[2].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.vol.dynBal.ports[2].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.disFloCoo.heaCoo.vol.dynBal.ports[2].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.vol.dynBal.ports[2].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.vol.dynBal.ports[2].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.Temperature bui.disFloCoo.heaCoo.vol.dynBal.medium.T(start = bui.disFloCoo.heaCoo.vol.dynBal.T_start,stateSelect = StateSelect.default) "Temperature of medium";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol.dynBal.medium.InputAbsolutePressure bui.disFloCoo.heaCoo.vol.dynBal.medium.p(start = bui.disFloCoo.heaCoo.vol.dynBal.p_start) "Absolute pressure of medium";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol.dynBal.medium.InputMassFraction bui.disFloCoo.heaCoo.vol.dynBal.medium.Xi[0](start = bui.disFloCoo.heaCoo.vol.dynBal.X_start[1:0]) = fill(0, 0) "Structurally independent mass fractions";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol.dynBal.medium.InputSpecificEnthalpy bui.disFloCoo.heaCoo.vol.dynBal.medium.h(start = bui.disFloCoo.heaCoo.vol.dynBal.hStart) "Specific enthalpy of medium";
 Modelica.SIunits.SpecificEnergy bui.disFloCoo.heaCoo.vol.dynBal.medium.u "Specific internal energy of medium";
 Modelica.SIunits.Density bui.disFloCoo.heaCoo.vol.dynBal.medium.d(start = bui.disFloCoo.heaCoo.vol.dynBal.rho_start) = 995.586 "Density of medium";
 Modelica.SIunits.MassFraction bui.disFloCoo.heaCoo.vol.dynBal.medium.X[1](start = bui.disFloCoo.heaCoo.vol.dynBal.X_start[1:1]) = {1} "Mass fractions (= (component mass)/total mass  m_i/m)";
 Modelica.SIunits.SpecificHeatCapacity bui.disFloCoo.heaCoo.vol.dynBal.medium.R = 0 "Gas constant (of mixture if applicable)";
 Modelica.SIunits.MolarMass bui.disFloCoo.heaCoo.vol.dynBal.medium.MM = 0.018015268 "Molar mass (of mixture or single fluid)";
 Buildings.Media.Water.ThermodynamicState bui.disFloCoo.heaCoo.vol.dynBal.medium.state(p(start = 300000.0),T(start = 293.15)) "Thermodynamic state record for optional functions";
 eval parameter Boolean bui.disFloCoo.heaCoo.vol.dynBal.medium.preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium" /* false */;
 final parameter Boolean bui.disFloCoo.heaCoo.vol.dynBal.medium.standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones" /* true */;
 Modelica.SIunits.Conversions.NonSIunits.Temperature_degC bui.disFloCoo.heaCoo.vol.dynBal.medium.T_degC = Modelica.SIunits.Conversions.to_degC(bui.disFloCoo.heaCoo.vol.dynBal.medium.T) "Temperature of medium in [degC]";
 Modelica.SIunits.Conversions.NonSIunits.Pressure_bar bui.disFloCoo.heaCoo.vol.dynBal.medium.p_bar = Modelica.SIunits.Conversions.to_bar(bui.disFloCoo.heaCoo.vol.dynBal.medium.p) "Absolute pressure of medium in [bar]";
 Modelica.SIunits.Energy bui.disFloCoo.heaCoo.vol.dynBal.U(start = bui.disFloCoo.heaCoo.vol.dynBal.fluidVolume * bui.disFloCoo.heaCoo.vol.dynBal.rho_start * Buildings.Media.Water.specificInternalEnergy(Buildings.Media.Water.setState_pTX(bui.disFloCoo.heaCoo.vol.dynBal.p_start, bui.disFloCoo.heaCoo.vol.dynBal.T_start, bui.disFloCoo.heaCoo.vol.dynBal.X_start[1:0])) + (bui.disFloCoo.heaCoo.vol.dynBal.T_start - 273.15) * bui.disFloCoo.heaCoo.vol.dynBal.CSen,nominal = 100000.0) "Internal energy of fluid";
 Modelica.SIunits.Mass bui.disFloCoo.heaCoo.vol.dynBal.m(start = bui.disFloCoo.heaCoo.vol.V * bui.disFloCoo.heaCoo.vol.rho_start,stateSelect = StateSelect.prefer) "Mass of fluid";
 Modelica.SIunits.Mass bui.disFloCoo.heaCoo.vol.dynBal.mXi[0](start = bui.disFloCoo.heaCoo.vol.dynBal.fluidVolume * bui.disFloCoo.heaCoo.vol.dynBal.rho_start * bui.disFloCoo.heaCoo.vol.dynBal.X_start[1:0]) "Masses of independent components in the fluid";
 Modelica.SIunits.Mass bui.disFloCoo.heaCoo.vol.dynBal.mC[0](start = bui.disFloCoo.heaCoo.vol.dynBal.fluidVolume * bui.disFloCoo.heaCoo.vol.dynBal.rho_start * bui.disFloCoo.heaCoo.vol.dynBal.C_start[1:0]) "Masses of trace substances in the fluid";
 Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.vol.dynBal.C[0](nominal = bui.disFloCoo.heaCoo.vol.dynBal.C_nominal[1:0]) "Trace substance mixture content";
 Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.vol.dynBal.mb_flow "Mass flows across boundaries";
 Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.vol.dynBal.mbXi_flow[0] "Substance mass flows across boundaries";
 Buildings.Media.Water.ExtraPropertyFlowRate bui.disFloCoo.heaCoo.vol.dynBal.mbC_flow[0] "Trace substance mass flows across boundaries";
 Modelica.SIunits.EnthalpyFlowRate bui.disFloCoo.heaCoo.vol.dynBal.Hb_flow "Enthalpy flow across boundaries or energy source/sink";
 parameter Modelica.SIunits.Volume bui.disFloCoo.heaCoo.vol.dynBal.fluidVolume = bui.disFloCoo.heaCoo.vol.V "Volume";
 parameter Modelica.SIunits.HeatCapacity bui.disFloCoo.heaCoo.vol.dynBal.CSen = (1.0 - 1) * bui.disFloCoo.heaCoo.vol.dynBal.rho_default * bui.disFloCoo.heaCoo.vol.dynBal.cp_default * bui.disFloCoo.heaCoo.vol.dynBal.fluidVolume "Aditional heat capacity for implementing mFactor";
 Buildings.Media.Water.EnthalpyFlowRate bui.disFloCoo.heaCoo.vol.dynBal.ports_H_flow[2];
 Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.vol.dynBal.ports_mXi_flow[2,0];
 Buildings.Media.Water.ExtraPropertyFlowRate bui.disFloCoo.heaCoo.vol.dynBal.ports_mC_flow[2,0];
 parameter Modelica.SIunits.SpecificHeatCapacity bui.disFloCoo.heaCoo.vol.dynBal.cp_default = Buildings.Media.Water.specificHeatCapacityCp(bui.disFloCoo.heaCoo.vol.dynBal.state_default) "Heat capacity, to compute additional dry mass";
 parameter Modelica.SIunits.Density bui.disFloCoo.heaCoo.vol.dynBal.rho_start = Buildings.Media.Water.density(Buildings.Media.Water.setState_pTX(bui.disFloCoo.heaCoo.vol.dynBal.p_start, bui.disFloCoo.heaCoo.vol.dynBal.T_start, bui.disFloCoo.heaCoo.vol.dynBal.X_start[1:0])) "Density, used to compute fluid mass";
 eval parameter Boolean bui.disFloCoo.heaCoo.vol.dynBal.computeCSen = false /* false */;
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloCoo.heaCoo.vol.dynBal.state_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Medium state at default values";
 parameter Modelica.SIunits.Density bui.disFloCoo.heaCoo.vol.dynBal.rho_default = Buildings.Media.Water.density(bui.disFloCoo.heaCoo.vol.dynBal.state_default) "Density, used to compute fluid mass";
 final parameter Real bui.disFloCoo.heaCoo.vol.dynBal.s[0] = {} "Vector with zero everywhere except where species is" /* (zero-size array) */;
 parameter Modelica.SIunits.SpecificEnergy bui.disFloCoo.heaCoo.vol.dynBal.hStart = Buildings.Media.Water.specificEnthalpy_pTX(bui.disFloCoo.heaCoo.vol.dynBal.p_start, bui.disFloCoo.heaCoo.vol.dynBal.T_start, bui.disFloCoo.heaCoo.vol.dynBal.X_start[1:1]) "Start value for specific enthalpy";
 constant Boolean bui.disFloCoo.heaCoo.vol.dynBal._simplify_mWat_flow = false "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.heaCoo.vol.dynBal.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.heaCoo.vol.dynBal.C_flow_internal[0] "Needed to connect to conditional connector";
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.heaCoo.vol.dynBal.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.heaCoo.vol.dynBal.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.heaCoo.vol.dynBal.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.disFloCoo.heaCoo.vol.dynBal.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Water.AbsolutePressure bui.disFloCoo.heaCoo.vol.dynBal.p_start(start = 300000.0) = bui.disFloCoo.heaCoo.vol.p_start "Start value of pressure";
 parameter Buildings.Media.Water.Temperature bui.disFloCoo.heaCoo.vol.dynBal.T_start(start = 293.15) = bui.disFloCoo.heaCoo.vol.T_start "Start value of temperature";
 parameter Buildings.Media.Water.MassFraction bui.disFloCoo.heaCoo.vol.dynBal.X_start[1](quantity = {"SimpleLiquidWater"}) = bui.disFloCoo.heaCoo.vol.X_start[1:1] "Start value of mass fractions m_i/m";
 parameter Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.vol.dynBal.C_start[0](quantity = fill("", 0)) = bui.disFloCoo.heaCoo.vol.C_start[1:0] "Start value of trace substances";
 parameter Buildings.Media.Water.ExtraProperty bui.disFloCoo.heaCoo.vol.dynBal.C_nominal[0](quantity = fill("", 0)) = bui.disFloCoo.heaCoo.vol.C_nominal[1:0] "Nominal value of trace substances. (Set to typical order of magnitude.)";
 structural parameter Real bui.disFloCoo.heaCoo.vol.dynBal.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 parameter Modelica.SIunits.Density bui.disFloCoo.heaCoo.vol.rho_start = Buildings.Media.Water.density(bui.disFloCoo.heaCoo.vol.state_start) "Density, used to compute start and guess values";
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloCoo.heaCoo.vol.state_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Medium state at default values";
 parameter Modelica.SIunits.Density bui.disFloCoo.heaCoo.vol.rho_default = Buildings.Media.Water.density(bui.disFloCoo.heaCoo.vol.state_default) "Density, used to compute fluid mass";
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloCoo.heaCoo.vol.state_start(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(bui.disFloCoo.heaCoo.vol.p_start, bui.disFloCoo.heaCoo.vol.T_start, bui.disFloCoo.heaCoo.vol.X_start[1:0]) "Medium state at start values";
 eval parameter Boolean bui.disFloCoo.heaCoo.vol.useSteadyStateTwoPort = false "Flag, true if the model has two ports only and uses a steady state balance" /* false */;
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.hOut_internal(unit = "J/kg") "Internal connector for leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.XiOut_internal[0](each unit = "1") "Internal connector for leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.COut_internal[0](each unit = "1") "Internal connector for leaving trace substances of the component";
 Modelica.SIunits.ThermodynamicTemperature bui.disFloCoo.heaCoo.vol.preTem.port.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.disFloCoo.heaCoo.vol.preTem.port.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.Blocks.Interfaces.RealInput bui.disFloCoo.heaCoo.vol.preTem.T;
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.portT.y = bui.disFloCoo.heaCoo.vol.T "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.disFloCoo.heaCoo.vol.heaFloSen.Q_flow(unit = "W") "Heat flow from port_a to port_b as output signal";
 Modelica.SIunits.ThermodynamicTemperature bui.disFloCoo.heaCoo.vol.heaFloSen.port_a.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.disFloCoo.heaCoo.vol.heaFloSen.port_a.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.SIunits.ThermodynamicTemperature bui.disFloCoo.heaCoo.vol.heaFloSen.port_b.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.disFloCoo.heaCoo.vol.heaFloSen.port_b.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 eval parameter Boolean bui.disFloCoo.heaCoo.preDro.computeFlowResistance = false "Flag to enable/disable computation of flow resistance" /* false */;
 final parameter Real bui.disFloCoo.heaCoo.preDro.coeff = 0 "Precomputed coefficient to avoid division by parameter" /* 0 */;
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloCoo.heaCoo.preDro.sta_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0});
 parameter Modelica.SIunits.DynamicViscosity bui.disFloCoo.heaCoo.preDro.eta_default = Buildings.Media.Water.dynamicViscosity(bui.disFloCoo.heaCoo.preDro.sta_default) "Dynamic viscosity, used to compute transition to turbulent flow regime";
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.preDro.m_flow_nominal_pos = 7.024856596558317 "Absolute value of nominal flow rate" /* 7.024856596558317 */;
 structural parameter Modelica.SIunits.Pressure bui.disFloCoo.heaCoo.preDro.dp_nominal_pos = 0.0 "Absolute value of nominal pressure difference" /* 0.0 */;
 final parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo.preDro._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.disFloCoo.heaCoo.preDro._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloCoo.heaCoo.sta_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0});
 parameter Modelica.SIunits.Density bui.disFloCoo.heaCoo.rho_default = Buildings.Media.Water.density(bui.disFloCoo.heaCoo.sta_default) "Density, used to compute fluid volume";
 parameter Buildings.Media.Water.ThermodynamicState bui.disFloCoo.heaCoo.sta_start(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(bui.disFloCoo.heaCoo.p_start, bui.disFloCoo.heaCoo.T_start, bui.disFloCoo.heaCoo.X_start[1:1]);
 parameter Modelica.SIunits.SpecificEnergy bui.disFloCoo.heaCoo.h_outflow_start = Buildings.Media.Water.specificEnthalpy(bui.disFloCoo.heaCoo.sta_start) "Start value for outflowing enthalpy";
 final parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.heaCoo._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.disFloCoo.heaCoo._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.disFloCoo.mDis_flow_nominal[1] = {7.024856596558317} "Distribution flow rate between each connected unit at nominal conditions" /* { 7.024856596558317 } */;
 structural parameter Real bui.disFloCoo.kDis[1] = {0.04442909416236568} "Flow coefficient between each connected unit at nominal conditions" /* { 0.04442909416236568 } */;
 Modelica.SIunits.MassFlowRate bui.disFloCoo.mDis_flow[1] = {sum(bui.disFloCoo.mReq_flow[1:1])} "Distribution flow rate between each connected unit";
 Modelica.SIunits.Pressure bui.disFloCoo.dpDis[1] = (bui.disFloCoo.mDis_flow[1:1] ./ {0.04442909416236568}) .^ 2 "Pressure drop between each connected unit (supply line)";
 Modelica.SIunits.Pressure bui.disFloCoo.dpPum(displayUnit = "Pa") = 100000.0 "Pump head";
 Modelica.SIunits.MassFlowRate bui.disFloCoo.mPum_flow = sum(bui.disFloCoo.mReq_flow[1:1]) "Pump mass flow rate";
 structural parameter Buildings.Media.Water.ThermodynamicState bui.disFloCoo.sta_default = Buildings.Media.Water.ThermodynamicState(300000, 293.15) /* Buildings.Media.Water.ThermodynamicState(300000, 293.15) */;
 structural parameter Modelica.SIunits.Density bui.disFloCoo.rho_default = 995.586 "Density, used to compute fluid volume" /* 995.586 */;
 final parameter Modelica.SIunits.MassFlowRate bui.disFloCoo._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.disFloCoo._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.I.y_reset_internal "Internal connector for integrator reset";
 discrete Buildings.Controls.OBC.CDL.Interfaces.BooleanInput bui.terUniCoo.con.I.trigger_internal "Needed to use conditional connector trigger";
 parameter Real bui.terUniCoo.con.revAct = if bui.terUniCoo.con.reverseAction then -1 else 1 "Switch for sign for reverse action";
 eval parameter Boolean bui.terUniCoo.con.with_I = true "Boolean flag to enable integral action" /* true */;
 eval parameter Boolean bui.terUniCoo.con.with_D = false "Boolean flag to enable derivative action" /* false */;
 final parameter Real bui.terUniCoo.con.Dzero.k = 0 "Constant output value" /* 0 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.Dzero.y "Connector of Real output signal";
 parameter Real bui.terUniCoo.con.uS_revAct.k = bui.terUniCoo.con.revAct "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.uS_revAct.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.uS_revAct.y "Output signal connector";
 parameter Real bui.terUniCoo.con.uSetWp.k = bui.terUniCoo.con.wp "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.uSetWp.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.uSetWp.y "Output signal connector";
 parameter Real bui.terUniCoo.con.uMea_revAct.k = bui.terUniCoo.con.revAct "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.uMea_revAct.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.uMea_revAct.y "Output signal connector";
 final parameter Real bui.terUniCoo.con.addPD.k1 = 1 "Gain for input u1" /* 1 */;
 final parameter Real bui.terUniCoo.con.addPD.k2 = 1 "Gain for input u2" /* 1 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.addPD.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.addPD.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.addPD.y "Connector of Real output signal";
 parameter Real bui.terUniCoo.con.gainPID.k = bui.terUniCoo.con.k "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.gainPID.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.gainPID.y "Output signal connector";
 final parameter Real bui.terUniCoo.con.addPID.k1 = 1 "Gain for input u1" /* 1 */;
 final parameter Real bui.terUniCoo.con.addPID.k2 = 1 "Gain for input u2" /* 1 */;
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.addPID.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.addPID.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.addPID.y "Connector of Real output signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.antWinErr.u1 "Connector of Real input signal 1";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.antWinErr.u2 "Connector of Real input signal 2";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.antWinErr.y "Connector of Real output signal";
 parameter Real bui.terUniCoo.con.antWinGai.k = 1 / (bui.terUniCoo.con.k * bui.terUniCoo.con.Ni) "Gain value multiplied with input signal";
 Buildings.Controls.OBC.CDL.Interfaces.RealInput bui.terUniCoo.con.antWinGai.u "Input signal connector";
 Buildings.Controls.OBC.CDL.Interfaces.RealOutput bui.terUniCoo.con.antWinGai.y "Output signal connector";
 parameter Boolean bui.terUniCoo.con.cheYMinMax.k = bui.terUniCoo.con.yMin < bui.terUniCoo.con.yMax "Constant output value";
 discrete Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput bui.terUniCoo.con.cheYMinMax.y "Connector of Boolean output signal";
 parameter String bui.terUniCoo.con.assMesYMinMax.message = "LimPID: Limits must be yMin < yMax" "Message written when u becomes false" /* "LimPID: Limits must be yMin < yMax" */;
 discrete Buildings.Controls.OBC.CDL.Interfaces.BooleanInput bui.terUniCoo.con.assMesYMinMax.u "Boolean input that triggers assert when it becomes false";
 final parameter Modelica.SIunits.VolumeFlowRate bui.terUniCoo.fan._VMachine_flow = 0 "Start value for VMachine_flow, used to avoid a warning if not specified" /* 0 */;
 structural parameter Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable bui.terUniCoo.fan.preVar = Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate "Type of prescribed variable" /* Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate */;
 structural parameter Boolean bui.terUniCoo.fan.speedIsInput = false "Parameter that is true if speed is the controlled variables" /* false */;
 eval parameter Integer bui.terUniCoo.fan.nOri = 2 "Number of data points for pressure curve" /* 2 */;
 structural parameter Boolean bui.terUniCoo.fan.haveVMax = true "Flag, true if user specified data that contain V_flow_max" /* true */;
 structural parameter Modelica.SIunits.VolumeFlowRate bui.terUniCoo.fan.V_flow_max = 12.07115211491579 "Maximum volume flow rate, used for smoothing" /* 12.07115211491579 */;
 structural parameter Modelica.SIunits.Density bui.terUniCoo.fan.rho_default = 1.2 "Default medium density" /* 1.2 */;
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniCoo.fan.sta_start(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(bui.terUniCoo.fan.p_start, bui.terUniCoo.fan.T_start, bui.terUniCoo.fan.X_start[1:2]) "Medium state at start values";
 parameter Modelica.SIunits.SpecificEnergy bui.terUniCoo.fan.h_outflow_start = Buildings.Media.Air.specificEnthalpy(bui.terUniCoo.fan.sta_start) "Start value for outflowing enthalpy";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.inputSwitch.u "Connector of Real input signal";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.inputSwitch.y "Connector of Real output signal";
 parameter Modelica.SIunits.Time bui.terUniCoo.fan.vol.tau = bui.terUniCoo.fan.tau "Time constant at nominal flow";
 parameter Modelica.SIunits.Volume bui.terUniCoo.fan.vol.V_nominal = 14.485382537898948 * bui.terUniCoo.fan.vol.tau / bui.terUniCoo.fan.vol.rho_default "Volume of delay element";
 eval parameter Boolean bui.terUniCoo.fan.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.fan.vol.heatPort.T(start = bui.terUniCoo.fan.vol.T_start) "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniCoo.fan.vol.heatPort.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 eval parameter Boolean bui.terUniCoo.fan.vol.initialize_p = true "= true to set up initial equations for pressure" /* true */;
 constant Boolean bui.terUniCoo.fan.vol.prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
 constant Boolean bui.terUniCoo.fan.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.vol.m_flow_nominal = 14.485382537898948 "Nominal mass flow rate" /* 14.485382537898948 */;
 eval parameter Integer bui.terUniCoo.fan.vol.nPorts = 2 "Number of ports" /* 2 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.vol.m_flow_small = 0.0014485382537898948 "Small mass flow rate for regularization of zero flow" /* 0.0014485382537898948 */;
 eval parameter Boolean bui.terUniCoo.fan.vol.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports." /* true */;
 parameter Modelica.SIunits.Volume bui.terUniCoo.fan.vol.V = bui.terUniCoo.fan.vol.V_nominal "Volume";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.vol.ports[1].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.vol.ports[1].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.vol.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.vol.ports[1].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.vol.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.vol.ports[2].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.vol.ports[2].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.vol.ports[2].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.vol.ports[2].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.vol.ports[2].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.Temperature bui.terUniCoo.fan.vol.T(start = 293.15) = Buildings.Media.Air.temperature_phX(bui.terUniCoo.fan.vol.p, bui.terUniCoo.fan.vol.hOut_internal, cat(1, bui.terUniCoo.fan.vol.Xi[1:1], {1 - sum(bui.terUniCoo.fan.vol.Xi[1:1])})) "Temperature of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.U(unit = "J") "Internal energy of the component";
 Modelica.SIunits.Pressure bui.terUniCoo.fan.vol.p = bui.terUniCoo.fan.vol.ports[1].p "Pressure of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.m(unit = "kg") "Mass of the component";
 Modelica.SIunits.MassFraction bui.terUniCoo.fan.vol.Xi[1] = bui.terUniCoo.fan.vol.XiOut_internal[1:1] "Species concentration of the fluid";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.mXi[1](each unit = "kg") "Species mass of the component";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.vol.C[0](nominal = bui.terUniCoo.fan.vol.C_nominal[1:0]) = bui.terUniCoo.fan.vol.COut_internal[1:0] "Trace substance mixture content";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.mC[0](each unit = "kg") "Trace substance mass of the component";
 eval parameter Boolean bui.terUniCoo.fan.vol.dynBal.initialize_p = true "= true to set up initial equations for pressure" /* true */;
 constant Boolean bui.terUniCoo.fan.vol.dynBal.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";
 eval parameter Integer bui.terUniCoo.fan.vol.dynBal.nPorts = 2 "Number of ports" /* 2 */;
 eval parameter Boolean bui.terUniCoo.fan.vol.dynBal.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean bui.terUniCoo.fan.vol.dynBal.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.vol.dynBal.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.dynBal.hOut(unit = "J/kg",start = bui.terUniCoo.fan.vol.dynBal.hStart) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.dynBal.XiOut[1](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.dynBal.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.dynBal.UOut(unit = "J") "Internal energy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.dynBal.mXiOut[1](each min = 0,each unit = "kg") "Species mass of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.dynBal.mOut(min = 0,unit = "kg") "Mass of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.dynBal.mCOut[0](each min = 0,each unit = "kg") "Trace substance mass of the component";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.vol.dynBal.ports[1].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.vol.dynBal.ports[1].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.vol.dynBal.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.vol.dynBal.ports[1].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.vol.dynBal.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.vol.dynBal.ports[2].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.vol.dynBal.ports[2].p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.vol.dynBal.ports[2].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.vol.dynBal.ports[2].Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.vol.dynBal.ports[2].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 constant Modelica.SIunits.MolarMass bui.terUniCoo.fan.vol.dynBal.medium.MMX[2] = {0.01801528, 0.0289651159} "Molar masses of components";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.vol.dynBal.medium.X_steam "Mass fraction of steam water";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.vol.dynBal.medium.X_air "Mass fraction of air";
 Modelica.SIunits.TemperatureDifference bui.terUniCoo.fan.vol.dynBal.medium.dT(start = 293.15 - 273.15) "Temperature difference used to compute enthalpy" annotation(absoluteValue = false);
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol.dynBal.medium.InputAbsolutePressure bui.terUniCoo.fan.vol.dynBal.medium.p(start = bui.terUniCoo.fan.vol.dynBal.p_start) "Absolute pressure of medium";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol.dynBal.medium.InputMassFraction bui.terUniCoo.fan.vol.dynBal.medium.Xi[1](start = bui.terUniCoo.fan.vol.dynBal.X_start[1:1],each stateSelect = StateSelect.default) "Structurally independent mass fractions";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol.dynBal.medium.InputSpecificEnthalpy bui.terUniCoo.fan.vol.dynBal.medium.h(start = bui.terUniCoo.fan.vol.dynBal.hStart) "Specific enthalpy of medium";
 Buildings.Media.Air.Density bui.terUniCoo.fan.vol.dynBal.medium.d(start = bui.terUniCoo.fan.vol.dynBal.rho_start) "Density of medium";
 Buildings.Media.Air.Temperature bui.terUniCoo.fan.vol.dynBal.medium.T(start = bui.terUniCoo.fan.vol.dynBal.T_start,stateSelect = StateSelect.default) "Temperature of medium";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.vol.dynBal.medium.X[2](start = bui.terUniCoo.fan.vol.dynBal.X_start[1:2]) "Mass fractions (= (component mass)/total mass  m_i/m)";
 Buildings.Media.Air.SpecificEnergy bui.terUniCoo.fan.vol.dynBal.medium.u "Specific internal energy of medium";
 Buildings.Media.Air.SpecificHeatCapacity bui.terUniCoo.fan.vol.dynBal.medium.R "Gas constant (of mixture if applicable)";
 Buildings.Media.Air.MolarMass bui.terUniCoo.fan.vol.dynBal.medium.MM "Molar mass (of mixture or single fluid)";
 Buildings.Media.Air.ThermodynamicState bui.terUniCoo.fan.vol.dynBal.medium.state(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) "Thermodynamic state record for optional functions";
 eval parameter Boolean bui.terUniCoo.fan.vol.dynBal.medium.preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium" /* false */;
 structural parameter Boolean bui.terUniCoo.fan.vol.dynBal.medium.standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones" /* true */;
 Modelica.SIunits.Conversions.NonSIunits.Temperature_degC bui.terUniCoo.fan.vol.dynBal.medium.T_degC = Modelica.SIunits.Conversions.to_degC(bui.terUniCoo.fan.vol.dynBal.medium.T) "Temperature of medium in [degC]";
 Modelica.SIunits.Conversions.NonSIunits.Pressure_bar bui.terUniCoo.fan.vol.dynBal.medium.p_bar = Modelica.SIunits.Conversions.to_bar(bui.terUniCoo.fan.vol.dynBal.medium.p) "Absolute pressure of medium in [bar]";
 Modelica.SIunits.Energy bui.terUniCoo.fan.vol.dynBal.U(start = bui.terUniCoo.fan.vol.dynBal.fluidVolume * bui.terUniCoo.fan.vol.dynBal.rho_start * Buildings.Media.Air.specificInternalEnergy(Buildings.Media.Air.setState_pTX(bui.terUniCoo.fan.vol.dynBal.p_start, bui.terUniCoo.fan.vol.dynBal.T_start, bui.terUniCoo.fan.vol.dynBal.X_start[1:1])) + (bui.terUniCoo.fan.vol.dynBal.T_start - 273.15) * bui.terUniCoo.fan.vol.dynBal.CSen,nominal = 100000.0) "Internal energy of fluid";
 Modelica.SIunits.Mass bui.terUniCoo.fan.vol.dynBal.m(start = bui.terUniCoo.fan.vol.V * bui.terUniCoo.fan.vol.rho_start,stateSelect = StateSelect.prefer) "Mass of fluid";
 Modelica.SIunits.Mass bui.terUniCoo.fan.vol.dynBal.mXi[1](start = bui.terUniCoo.fan.vol.dynBal.fluidVolume * bui.terUniCoo.fan.vol.dynBal.rho_start * bui.terUniCoo.fan.vol.dynBal.X_start[1:1]) "Masses of independent components in the fluid";
 Modelica.SIunits.Mass bui.terUniCoo.fan.vol.dynBal.mC[0](start = bui.terUniCoo.fan.vol.dynBal.fluidVolume * bui.terUniCoo.fan.vol.dynBal.rho_start * bui.terUniCoo.fan.vol.dynBal.C_start[1:0]) "Masses of trace substances in the fluid";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.vol.dynBal.C[0](nominal = bui.terUniCoo.fan.vol.dynBal.C_nominal[1:0]) "Trace substance mixture content";
 Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.vol.dynBal.mb_flow "Mass flows across boundaries";
 Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.vol.dynBal.mbXi_flow[1] "Substance mass flows across boundaries";
 Buildings.Media.Air.ExtraPropertyFlowRate bui.terUniCoo.fan.vol.dynBal.mbC_flow[0] "Trace substance mass flows across boundaries";
 Modelica.SIunits.EnthalpyFlowRate bui.terUniCoo.fan.vol.dynBal.Hb_flow "Enthalpy flow across boundaries or energy source/sink";
 parameter Modelica.SIunits.Volume bui.terUniCoo.fan.vol.dynBal.fluidVolume = bui.terUniCoo.fan.vol.V "Volume";
 parameter Modelica.SIunits.HeatCapacity bui.terUniCoo.fan.vol.dynBal.CSen = (1.0 - 1) * bui.terUniCoo.fan.vol.dynBal.rho_default * bui.terUniCoo.fan.vol.dynBal.cp_default * bui.terUniCoo.fan.vol.dynBal.fluidVolume "Aditional heat capacity for implementing mFactor";
 Buildings.Media.Air.EnthalpyFlowRate bui.terUniCoo.fan.vol.dynBal.ports_H_flow[2];
 Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.vol.dynBal.ports_mXi_flow[2,1];
 Buildings.Media.Air.ExtraPropertyFlowRate bui.terUniCoo.fan.vol.dynBal.ports_mC_flow[2,0];
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.fan.vol.dynBal.cp_default = Buildings.Media.Air.specificHeatCapacityCp(bui.terUniCoo.fan.vol.dynBal.state_default) "Heat capacity, to compute additional dry mass";
 parameter Modelica.SIunits.Density bui.terUniCoo.fan.vol.dynBal.rho_start = Buildings.Media.Air.density(Buildings.Media.Air.setState_pTX(bui.terUniCoo.fan.vol.dynBal.p_start, bui.terUniCoo.fan.vol.dynBal.T_start, bui.terUniCoo.fan.vol.dynBal.X_start[1:1])) "Density, used to compute fluid mass";
 eval parameter Boolean bui.terUniCoo.fan.vol.dynBal.computeCSen = false /* false */;
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniCoo.fan.vol.dynBal.state_default(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01}) "Medium state at default values";
 parameter Modelica.SIunits.Density bui.terUniCoo.fan.vol.dynBal.rho_default = Buildings.Media.Air.density(bui.terUniCoo.fan.vol.dynBal.state_default) "Density, used to compute fluid mass";
 final parameter Real bui.terUniCoo.fan.vol.dynBal.s[1] = {1} "Vector with zero everywhere except where species is" /* { 1 } */;
 parameter Modelica.SIunits.SpecificEnergy bui.terUniCoo.fan.vol.dynBal.hStart = Buildings.Media.Air.specificEnthalpy_pTX(bui.terUniCoo.fan.vol.dynBal.p_start, bui.terUniCoo.fan.vol.dynBal.T_start, bui.terUniCoo.fan.vol.dynBal.X_start[1:2]) "Start value for specific enthalpy";
 constant Boolean bui.terUniCoo.fan.vol.dynBal._simplify_mWat_flow = true "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.vol.dynBal.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.vol.dynBal.C_flow_internal[0] "Needed to connect to conditional connector";
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.vol.dynBal.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.vol.dynBal.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.vol.dynBal.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.vol.dynBal.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.vol.dynBal.p_start(start = 101325.0) = bui.terUniCoo.fan.vol.p_start "Start value of pressure";
 parameter Buildings.Media.Air.Temperature bui.terUniCoo.fan.vol.dynBal.T_start(start = 293.15) = bui.terUniCoo.fan.vol.T_start "Start value of temperature";
 parameter Buildings.Media.Air.MassFraction bui.terUniCoo.fan.vol.dynBal.X_start[2](quantity = {"water", "air"}) = bui.terUniCoo.fan.vol.X_start[1:2] "Start value of mass fractions m_i/m";
 parameter Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.vol.dynBal.C_start[0](quantity = fill("", 0)) = bui.terUniCoo.fan.vol.C_start[1:0] "Start value of trace substances";
 parameter Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.vol.dynBal.C_nominal[0](quantity = fill("", 0)) = bui.terUniCoo.fan.vol.C_nominal[1:0] "Nominal value of trace substances. (Set to typical order of magnitude.)";
 structural parameter Real bui.terUniCoo.fan.vol.dynBal.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 parameter Modelica.SIunits.Density bui.terUniCoo.fan.vol.rho_start = Buildings.Media.Air.density(bui.terUniCoo.fan.vol.state_start) "Density, used to compute start and guess values";
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniCoo.fan.vol.state_default(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01}) "Medium state at default values";
 parameter Modelica.SIunits.Density bui.terUniCoo.fan.vol.rho_default = Buildings.Media.Air.density(bui.terUniCoo.fan.vol.state_default) "Density, used to compute fluid mass";
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniCoo.fan.vol.state_start(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(bui.terUniCoo.fan.vol.p_start, bui.terUniCoo.fan.vol.T_start, bui.terUniCoo.fan.vol.X_start[1:1]) "Medium state at start values";
 eval parameter Boolean bui.terUniCoo.fan.vol.useSteadyStateTwoPort = false "Flag, true if the model has two ports only and uses a steady state balance" /* false */;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.hOut_internal(unit = "J/kg") "Internal connector for leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.XiOut_internal[1](each unit = "1") "Internal connector for leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.COut_internal[0](each unit = "1") "Internal connector for leaving trace substances of the component";
 Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.fan.vol.preTem.port.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniCoo.fan.vol.preTem.port.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.vol.preTem.T;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.portT.y = bui.terUniCoo.fan.vol.T "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.vol.heaFloSen.Q_flow(unit = "W") "Heat flow from port_a to port_b as output signal";
 Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.fan.vol.heaFloSen.port_a.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniCoo.fan.vol.heaFloSen.port_a.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.fan.vol.heaFloSen.port_b.T "Port temperature";
 Modelica.SIunits.HeatFlowRate bui.terUniCoo.fan.vol.heaFloSen.port_b.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.vol.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.vol.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.vol.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics bui.terUniCoo.fan.vol.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.vol.p_start(start = 101325.0) = bui.terUniCoo.fan.p_start "Start value of pressure";
 parameter Buildings.Media.Air.Temperature bui.terUniCoo.fan.vol.T_start(start = 293.15) = bui.terUniCoo.fan.T_start "Start value of temperature";
 parameter Buildings.Media.Air.MassFraction bui.terUniCoo.fan.vol.X_start[2](quantity = {"water", "air"}) = bui.terUniCoo.fan.X_start[1:2] "Start value of mass fractions m_i/m";
 parameter Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.vol.C_start[0](quantity = fill("", 0)) = bui.terUniCoo.fan.C_start[1:0] "Start value of trace substances";
 parameter Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.vol.C_nominal[0](quantity = fill("", 0)) = fill(0.01, 0) "Nominal value of trace substances. (Set to typical order of magnitude.)" /* (zero-size array) */;
 structural parameter Real bui.terUniCoo.fan.vol.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 structural parameter Modelica.Blocks.Types.AnalogFilter bui.terUniCoo.fan.filter.analogFilter = Modelica.Blocks.Types.AnalogFilter.CriticalDamping "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI)" /* Modelica.Blocks.Types.AnalogFilter.CriticalDamping */;
 structural parameter Modelica.Blocks.Types.FilterType bui.terUniCoo.fan.filter.filterType = Modelica.Blocks.Types.FilterType.LowPass "Type of filter (LowPass/HighPass/BandPass/BandStop)" /* Modelica.Blocks.Types.FilterType.LowPass */;
 structural parameter Integer bui.terUniCoo.fan.filter.order = 2 "Order of filter" /* 2 */;
 parameter Modelica.SIunits.Frequency bui.terUniCoo.fan.filter.f_cut = 5 / (2 * 3.141592653589793 * bui.terUniCoo.fan.riseTime) "Cut-off frequency";
 parameter Real bui.terUniCoo.fan.filter.gain = 1.0 "Gain (= amplitude of frequency response at zero frequency)" /* 1.0 */;
 parameter Real bui.terUniCoo.fan.filter.A_ripple(unit = "dB") = 0.5 "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required" /* 0.5 */;
 parameter Modelica.SIunits.Frequency bui.terUniCoo.fan.filter.f_min = 0 "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain)" /* 0 */;
 parameter Boolean bui.terUniCoo.fan.filter.normalized = true "= true, if amplitude at f_cut = -3db, otherwise unmodified filter" /* true */;
 eval parameter Modelica.Blocks.Types.Init bui.terUniCoo.fan.filter.init = Modelica.Blocks.Types.Init.InitialOutput "Type of initialization (no init/steady state/initial state/initial output)" /* Modelica.Blocks.Types.Init.InitialOutput */;
 structural parameter Integer bui.terUniCoo.fan.filter.nx = 2 /* 2 */;
 parameter Real bui.terUniCoo.fan.filter.x_start[2] = zeros(2) "Initial or guess values of states" /* { 0, 0 } */;
 parameter Real bui.terUniCoo.fan.filter.y_start = bui.terUniCoo.fan.m_flow_start "Initial value of output";
 structural parameter Real bui.terUniCoo.fan.filter.u_nominal = 14.485382537898948 "Nominal value of input (used for scaling the states)" /* 14.485382537898948 */;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.filter.x[2](each stateSelect = StateSelect.always) "Filter states";
 structural parameter Integer bui.terUniCoo.fan.filter.ncr = 2 /* 2 */;
 structural parameter Integer bui.terUniCoo.fan.filter.nc0 = 0 /* 0 */;
 structural parameter Integer bui.terUniCoo.fan.filter.na = 0 /* 0 */;
 structural parameter Integer bui.terUniCoo.fan.filter.nr = 2 /* 2 */;
 initial parameter Real bui.terUniCoo.fan.filter.cr[2](each fixed = false);
 parameter Real bui.terUniCoo.fan.filter.c0[0](each fixed = false);
 parameter Real bui.terUniCoo.fan.filter.c1[0](each fixed = false);
 initial parameter Real bui.terUniCoo.fan.filter.r[2](each fixed = false);
 parameter Real bui.terUniCoo.fan.filter.a[0](each fixed = false);
 parameter Real bui.terUniCoo.fan.filter.b[0](each fixed = false);
 parameter Real bui.terUniCoo.fan.filter.ku[0](each fixed = false);
 parameter Real bui.terUniCoo.fan.filter.k1[0](each fixed = false);
 parameter Real bui.terUniCoo.fan.filter.k2[0](each fixed = false);
 Real bui.terUniCoo.fan.filter.uu[3];
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.filter.u(final unit = "kg/s") "Connector of Real input signal";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.filter.y(final unit = "kg/s") "Connector of Real output signal";
 eval parameter Boolean bui.terUniCoo.fan.preSou.control_m_flow = true "if true, then the mass flow rate is equal to the value of m_flow_in" /* true */;
 eval parameter Boolean bui.terUniCoo.fan.preSou.control_dp = false "if true, then the head is equal to the value of dp_in" /* false */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.preSou.m_flow_in(unit = "kg/s") "Prescribed mass flow rate";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.preSou.m_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.preSou.dp_internal(unit = "Pa") "Needed to connect to conditional connector";
 parameter Modelica.SIunits.Pressure bui.terUniCoo.fan.preSou.dp_start(displayUnit = "Pa") = 0 "Guess value of dp = port_a.p - port_b.p" /* 0 */;
 parameter Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.preSou.m_flow_start = bui.terUniCoo.fan.m_flow_start "Guess value of m_flow = port_a.m_flow";
 structural parameter Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.preSou.m_flow_small = 0.0014485382537898948 "Small mass flow rate for regularization of zero flow" /* 0.0014485382537898948 */;
 structural parameter Boolean bui.terUniCoo.fan.preSou.show_T = false "= true, if temperatures at port_a and port_b are computed" /* false */;
 structural parameter Boolean bui.terUniCoo.fan.preSou.show_V_flow = true "= true, if volume flow rate at inflowing port is computed" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.preSou.m_flow(min = -1.0E60,start = bui.terUniCoo.fan.preSou.m_flow_start) "Mass flow rate in design flow direction";
 Modelica.SIunits.Pressure bui.terUniCoo.fan.preSou.dp(start = bui.terUniCoo.fan.preSou.dp_start,displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
 Modelica.SIunits.VolumeFlowRate bui.terUniCoo.fan.preSou.V_flow = bui.terUniCoo.fan.preSou.m_flow / Modelica.Fluid.Utilities.regStep(bui.terUniCoo.fan.preSou.m_flow, Buildings.Media.Air.density(Buildings.Media.Air.setState_phX(bui.terUniCoo.fan.preSou.port_a.p, inStream(bui.terUniCoo.fan.preSou.port_a.h_outflow), inStream(bui.terUniCoo.fan.preSou.port_a.Xi_outflow[1:1]))), Buildings.Media.Air.density(Buildings.Media.Air.setState_phX(bui.terUniCoo.fan.preSou.port_b.p, inStream(bui.terUniCoo.fan.preSou.port_b.h_outflow), inStream(bui.terUniCoo.fan.preSou.port_b.Xi_outflow[1:1]))), 0.0014485382537898948) "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
 eval parameter Boolean bui.terUniCoo.fan.preSou.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.preSou.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.preSou.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.preSou.port_a.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.preSou.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.preSou.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.preSou.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.preSou.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.preSou.port_b.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.preSou.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.preSou.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.rho_inlet.y = Buildings.Media.Air.density(Buildings.Media.Air.setState_phX(bui.terUniCoo.fan.port_a.p, inStream(bui.terUniCoo.fan.port_a.h_outflow), inStream(bui.terUniCoo.fan.port_a.Xi_outflow[1:1]))) "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.senMasFlo.m_flow(quantity = "MassFlowRate",final unit = "kg/s") "Mass flow rate from port_a to port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.senMasFlo.m_flow_nominal = 0 "Nominal mass flow rate, used for regularization near zero flow" /* 0 */;
 final parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.fan.senMasFlo.m_flow_small = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)" /* 0 */;
 eval parameter Boolean bui.terUniCoo.fan.senMasFlo.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.senMasFlo.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.senMasFlo.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.senMasFlo.port_a.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.senMasFlo.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.senMasFlo.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.senMasFlo.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.senMasFlo.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.senMasFlo.port_b.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.senMasFlo.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.senMasFlo.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.senRelPre.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.senRelPre.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.senRelPre.port_a.h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.senRelPre.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.senRelPre.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.fan.senRelPre.port_b.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.fan.senRelPre.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.fan.senRelPre.port_b.h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.fan.senRelPre.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.fan.senRelPre.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.senRelPre.p_rel(final quantity = "PressureDifference",final unit = "Pa",displayUnit = "Pa") "Relative pressure of port_a minus port_b";
 constant Boolean bui.terUniCoo.fan.eff.homotopyInitialization = true "= true, use homotopy method";
 parameter Buildings.Fluid.Movers.Data.Generic bui.terUniCoo.fan.eff.per(pressure(V_flow(size() = {2}),dp(size() = {2})) = Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters({0, 24.14230422983158}, {400.0, 0}),use_powerCharacteristic = false,hydraulicEfficiency(V_flow(size() = {1},each min = 0),eta(size() = {1},each max = 1)) = bui.terUniCoo.fan.per.hydraulicEfficiency,motorEfficiency(V_flow(size() = {1},each min = 0),eta(size() = {1},each max = 1)) = bui.terUniCoo.fan.per.motorEfficiency,power(V_flow(size() = {1},each min = 0),P(size() = {1},each min = 0)) = bui.terUniCoo.fan.per.power,motorCooledByFluid = bui.terUniCoo.fan.per.motorCooledByFluid,speed_nominal = 0,constantSpeed = 0,speeds(size() = {1}) = {0},speed_rpm_nominal = 1500,constantSpeed_rpm = bui.terUniCoo.fan.eff.per.speed_rpm_nominal,speeds_rpm(size() = {1}) = {bui.terUniCoo.fan.eff.per.speed_rpm_nominal},havePressureCurve = true) "Record with performance data";
 structural parameter Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable bui.terUniCoo.fan.eff.preVar = Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate "Type of prescribed variable" /* Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate */;
 structural parameter Boolean bui.terUniCoo.fan.eff.computePowerUsingSimilarityLaws = false "= true, compute power exactly, using similarity laws. Otherwise approximate." /* false */;
 structural parameter Modelica.SIunits.VolumeFlowRate bui.terUniCoo.fan.eff.V_flow_nominal = 24.14230422983158 "Nominal volume flow rate, used for homotopy" /* 24.14230422983158 */;
 structural parameter Modelica.SIunits.Density bui.terUniCoo.fan.eff.rho_default = 1.2 "Fluid density at medium default state" /* 1.2 */;
 structural parameter Boolean bui.terUniCoo.fan.eff.haveVMax = true "Flag, true if user specified data that contain V_flow_max" /* true */;
 structural parameter Modelica.SIunits.VolumeFlowRate bui.terUniCoo.fan.eff.V_flow_max = 12.07115211491579 "Maximum volume flow rate, used for smoothing" /* 12.07115211491579 */;
 eval parameter Integer bui.terUniCoo.fan.eff.nOri = 2 "Number of data points for pressure curve" /* 2 */;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.eff.y_out(final unit = "1") "Mover speed (prescribed or computed)";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.eff.m_flow(final quantity = "MassFlowRate",final unit = "kg/s") "Mass flow rate";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.eff.rho(final quantity = "Density",final unit = "kg/m3",min = 0.0) "Medium density";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.eff.V_flow(quantity = "VolumeFlowRate",final unit = "m3/s") "Volume flow rate";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.fan.eff.dp_in(quantity = "PressureDifference",final unit = "Pa") "Prescribed pressure increase";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.eff.WFlo(quantity = "Power",final unit = "W") "Flow work";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.eff.PEle(quantity = "Power",final unit = "W") "Electrical power consumed";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.eff.eta(final quantity = "Efficiency",final unit = "1") "Overall efficiency";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.eff.etaHyd(final quantity = "Efficiency",final unit = "1") "Hydraulic efficiency";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.eff.etaMot(final quantity = "Efficiency",final unit = "1") "Motor efficiency";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.eff.r_N(start = bui.terUniCoo.fan.y_start,unit = "1") "Ratio N_actual/N_nominal";
 Real bui.terUniCoo.fan.eff.r_V(start = 14.485382537898948 / 1.2,unit = "1") "Ratio V_flow/V_flow_max";
 structural parameter Boolean bui.terUniCoo.fan.eff.preSpe = false "True if speed is a prescribed variable of this block" /* false */;
 structural parameter Boolean bui.terUniCoo.fan.eff.prePre = true "True if pressure head is a prescribed variable of this block" /* true */;
 initial parameter Real bui.terUniCoo.fan.eff.motDer[1](each fixed = false) "Coefficients for polynomial of motor efficiency vs. volume flow rate";
 initial parameter Real bui.terUniCoo.fan.eff.hydDer[1](each fixed = false) "Coefficients for polynomial of hydraulic efficiency vs. volume flow rate";
 structural parameter Modelica.SIunits.Pressure bui.terUniCoo.fan.eff.dpMax = 400.0 "Maximum head" /* 400.0 */;
 structural parameter Real bui.terUniCoo.fan.eff.delta = 0.05 "Small value used to for regularization and to approximate an internal flow resistance of the fan" /* 0.05 */;
 structural parameter Real bui.terUniCoo.fan.eff.kRes = 0.008284213391399023 "Coefficient for internal pressure drop of fan or pump" /* 0.008284213391399023 */;
 structural parameter Integer bui.terUniCoo.fan.eff.curve = 1 "Flag, used to pick the right representatio of the fan or pump pressure curve" /* 1 */;
 parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal bui.terUniCoo.fan.eff.pCur1(n = 2,V_flow(size() = {2}) = {0, 24.14230422983158},dp(size() = {2},each min = 0,each displayUnit = "Pa") = {400.0, 24.14230422983158 * 0.008284213391399023}) "Volume flow rate vs. total pressure rise with correction for pump resistance added";
 parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal bui.terUniCoo.fan.eff.pCur2(n = 3,V_flow(size() = {3},each min = 0) = zeros(2 + 1),dp(size() = {3},each min = 0,each displayUnit = "Pa") = zeros(2 + 1)) "Volume flow rate vs. total pressure rise with correction for pump resistance added";
 parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal bui.terUniCoo.fan.eff.pCur3(n = 4,V_flow(size() = {4},each min = 0) = zeros(2 + 2),dp(size() = {4},each min = 0,each displayUnit = "Pa") = zeros(2 + 2)) "Volume flow rate vs. total pressure rise with correction for pump resistance added";
 initial parameter Real bui.terUniCoo.fan.eff.preDer1[2](each fixed = false) "Derivatives of flow rate vs. pressure at the support points";
 initial parameter Real bui.terUniCoo.fan.eff.preDer2[3](each fixed = false) "Derivatives of flow rate vs. pressure at the support points";
 initial parameter Real bui.terUniCoo.fan.eff.preDer3[4](each fixed = false) "Derivatives of flow rate vs. pressure at the support points";
 parameter Real bui.terUniCoo.fan.eff.powDer[1] = if false then Buildings.Utilities.Math.Functions.splineDerivatives(bui.terUniCoo.fan.eff.per.power.V_flow[1:1], bui.terUniCoo.fan.eff.per.power.P[1:1], Buildings.Utilities.Math.Functions.isMonotonic(bui.terUniCoo.fan.eff.per.power.P[1:1], false)) else zeros(size(bui.terUniCoo.fan.eff.per.power.V_flow[1:1], 1)) "Coefficients for polynomial of power vs. flow rate";
 structural parameter Boolean bui.terUniCoo.fan.eff.haveMinimumDecrease = true "Flag used for reporting" /* true */;
 structural parameter Boolean bui.terUniCoo.fan.eff.haveDPMax = true "Flag, true if user specified data that contain dpMax" /* true */;
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.fan.eff.dp_internal "If dp is prescribed, use dp_in and solve for r_N, otherwise compute dp using r_N";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.fan._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniCoo.fan._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 Real bui.terUniCoo.hex.hA.x_a(min = 0) "Factor for air side temperature dependent variation of heat transfer coefficient";
 Real bui.terUniCoo.hex.hA.x_w(min = 0) "Factor for water side temperature dependent variation of heat transfer coefficient";
 initial parameter Real bui.terUniCoo.hex.hA.s_w(min = 0,fixed = false) "Coefficient for temperature dependence of water side heat transfer coefficient";
 Real bui.terUniCoo.hex.hA.fm_w "Fraction of actual to nominal mass flow rate";
 Real bui.terUniCoo.hex.hA.fm_a "Fraction of actual to nominal mass flow rate";
 parameter Buildings.Media.Water.ThermodynamicState bui.terUniCoo.hex.sta1_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Default state for medium 1";
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniCoo.hex.sta2_default(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01}) "Default state for medium 2";
 initial parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.hex.cp1_nominal(fixed = false) "Specific heat capacity of medium 1 at nominal condition";
 initial parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.hex.cp2_nominal(fixed = false) "Specific heat capacity of medium 2 at nominal condition";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.C1_flow_nominal(fixed = false) "Nominal capacity flow rate of Medium 1";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.C2_flow_nominal(fixed = false) "Nominal capacity flow rate of Medium 2";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.CMin_flow_nominal(fixed = false) "Minimal capacity flow rate at nominal condition";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.CMax_flow_nominal(fixed = false) "Maximum capacity flow rate at nominal condition";
 initial parameter Real bui.terUniCoo.hex.Z_nominal(min = 0,max = 1,fixed = false) "Ratio of capacity flow rate at nominal condition";
 initial parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.hex.T_b1_nominal(fixed = false) "Nominal temperature at port b1";
 initial parameter Modelica.SIunits.ThermodynamicTemperature bui.terUniCoo.hex.T_b2_nominal(fixed = false) "Nominal temperature at port b2";
 initial parameter Buildings.Fluid.Types.HeatExchangerFlowRegime bui.terUniCoo.hex.flowRegime_nominal(fixed = false) "Heat exchanger flow regime at nominal flow rates";
 discrete Buildings.Fluid.Types.HeatExchangerFlowRegime bui.terUniCoo.hex.flowRegime(fixed = false,start = bui.terUniCoo.hex.flowRegime_nominal) "Heat exchanger flow regime";
 parameter Real bui.terUniCoo.hex.delta = 0.001 "Parameter used for smoothing" /* 0.001 */;
 initial parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.hex.cp1_default(fixed = false) "Specific heat capacity of medium 1 at default medium state";
 initial parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.hex.cp2_default(fixed = false) "Specific heat capacity of medium 2 at default medium state";
 initial parameter Modelica.SIunits.ThermalConductance bui.terUniCoo.hex.CMin_flow_small(fixed = false) "Small value for smoothing of minimum heat capacity flow rate";
 Real bui.terUniCoo.hex.fra_a1(min = 0,max = 1) = 1 "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
 Real bui.terUniCoo.hex.fra_b1(min = 0,max = 1) = 0 "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
 Real bui.terUniCoo.hex.fra_a2(min = 0,max = 1) = 1 "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
 Real bui.terUniCoo.hex.fra_b2(min = 0,max = 1) = 0 "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
 constant Boolean bui.terUniCoo.hex.bal1.sensibleOnly = true "Set to true if sensible exchange only";
 constant Boolean bui.terUniCoo.hex.bal1.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of the component temperature";
 constant Boolean bui.terUniCoo.hex.bal1.homotopyInitialization = true "= true, use homotopy method";
 Modelica.SIunits.HeatFlowRate bui.terUniCoo.hex.bal1.Q_flow = bui.terUniCoo.hex.Q1_flow "Heat transferred into the medium";
 Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.mWat_flow = bui.terUniCoo.hex.mWat1_flow "Moisture mass flow rate added to the medium";
 constant Boolean bui.terUniCoo.hex.bal1.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 constant Boolean bui.terUniCoo.hex.bal1.vol.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";
 eval parameter Boolean bui.terUniCoo.hex.bal1.vol.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean bui.terUniCoo.hex.bal1.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.hex.bal1.vol.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal1.vol.hOut(unit = "J/kg",start = Buildings.Media.Water.specificEnthalpy_pTX(300000.0, 293.15, {1.0})) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal1.vol.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal1.vol.COut[0](each min = 0) "Leaving trace substances of the component";
 eval parameter Boolean bui.terUniCoo.hex.bal1.vol.use_m_flowInv = true "Flag, true if m_flowInv is used in the model" /* true */;
 final parameter Real bui.terUniCoo.hex.bal1.vol.s[0] = {} "Vector with zero everywhere except where species is" /* (zero-size array) */;
 Real bui.terUniCoo.hex.bal1.vol.m_flowInv(unit = "s/kg") "Regularization of 1/m_flow of port_a";
 Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.vol.mXi_flow[0] "Mass flow rates of independent substances added to the medium";
 parameter Real bui.terUniCoo.hex.bal1.vol.deltaReg = bui.terUniCoo.hex.bal1.vol.m_flow_small / 1000.0 "Smoothing region for inverseXRegularized";
 parameter Real bui.terUniCoo.hex.bal1.vol.deltaInvReg = 1 / bui.terUniCoo.hex.bal1.vol.deltaReg "Inverse value of delta for inverseXRegularized";
 parameter Real bui.terUniCoo.hex.bal1.vol.aReg = -15 * bui.terUniCoo.hex.bal1.vol.deltaInvReg "Polynomial coefficient for inverseXRegularized";
 parameter Real bui.terUniCoo.hex.bal1.vol.bReg = 119 * bui.terUniCoo.hex.bal1.vol.deltaInvReg ^ 2 "Polynomial coefficient for inverseXRegularized";
 parameter Real bui.terUniCoo.hex.bal1.vol.cReg = -361 * bui.terUniCoo.hex.bal1.vol.deltaInvReg ^ 3 "Polynomial coefficient for inverseXRegularized";
 parameter Real bui.terUniCoo.hex.bal1.vol.dReg = 534 * bui.terUniCoo.hex.bal1.vol.deltaInvReg ^ 4 "Polynomial coefficient for inverseXRegularized";
 parameter Real bui.terUniCoo.hex.bal1.vol.eReg = -380 * bui.terUniCoo.hex.bal1.vol.deltaInvReg ^ 5 "Polynomial coefficient for inverseXRegularized";
 parameter Real bui.terUniCoo.hex.bal1.vol.fReg = 104 * bui.terUniCoo.hex.bal1.vol.deltaInvReg ^ 6 "Polynomial coefficient for inverseXRegularized";
 parameter Buildings.Media.Water.ThermodynamicState bui.terUniCoo.hex.bal1.vol.state_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Medium state at default values";
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.hex.bal1.vol.cp_default = Buildings.Media.Water.specificHeatCapacityCp(bui.terUniCoo.hex.bal1.vol.state_default) "Specific heat capacity, used to verify energy conservation";
 constant Modelica.SIunits.TemperatureDifference bui.terUniCoo.hex.bal1.vol.dTMax = 200 "Maximum temperature difference across the StaticTwoPortConservationEquation" annotation(absoluteValue = false);
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.hex.bal1.vol.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.hex.bal1.vol.C_flow_internal[0] "Needed to connect to conditional connector";
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.vol.m_flow_nominal = bui.terUniCoo.hex.bal1.m_flow_nominal "Nominal mass flow rate";
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.vol.m_flow_small(min = 0) = bui.terUniCoo.hex.bal1.m_flow_small "Small mass flow rate for regularization of zero flow";
 structural parameter Boolean bui.terUniCoo.hex.bal1.vol.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.vol.m_flow(start = 0.0) = bui.terUniCoo.hex.bal1.vol.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniCoo.hex.bal1.vol.dp(start = 0.0,displayUnit = "Pa") = bui.terUniCoo.hex.bal1.vol.port_a.p - bui.terUniCoo.hex.bal1.vol.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.vol._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal1.vol._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniCoo.hex.bal1.vol.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.bal1.vol.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.hex.bal1.vol.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.hex.bal1.vol.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.hex.bal1.vol.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.hex.bal1.vol.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.bal1.vol.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.hex.bal1.vol.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.hex.bal1.vol.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.hex.bal1.vol.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.hex.bal1.vol.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Real bui.terUniCoo.hex.bal1.preDro.deltaM = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs" /* 0.1 */;
 parameter Real bui.terUniCoo.hex.bal1.preDro.k = 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)" /* 0 */;
 eval parameter Boolean bui.terUniCoo.hex.bal1.preDro.computeFlowResistance = false "Flag to enable/disable computation of flow resistance" /* false */;
 parameter Real bui.terUniCoo.hex.bal1.preDro.coeff = 0 "Precomputed coefficient to avoid division by parameter" /* 0 */;
 constant Boolean bui.terUniCoo.hex.bal1.preDro.homotopyInitialization = true "= true, use homotopy method";
 eval parameter Boolean bui.terUniCoo.hex.bal1.preDro.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal1.preDro.dp_nominal = 0 "Pressure drop at nominal mass flow rate" /* 0 */;
 eval parameter Boolean bui.terUniCoo.hex.bal1.preDro.linearized = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.preDro.m_flow_turbulent(min = 0) = 0 "Turbulent flow if |m_flow| >= m_flow_turbulent" /* 0 */;
 parameter Buildings.Media.Water.ThermodynamicState bui.terUniCoo.hex.bal1.preDro.sta_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0});
 parameter Modelica.SIunits.DynamicViscosity bui.terUniCoo.hex.bal1.preDro.eta_default = Buildings.Media.Water.dynamicViscosity(bui.terUniCoo.hex.bal1.preDro.sta_default) "Dynamic viscosity, used to compute transition to turbulent flow regime";
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.preDro.m_flow_nominal_pos = abs(bui.terUniCoo.hex.bal1.preDro.m_flow_nominal) "Absolute value of nominal flow rate";
 structural parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal1.preDro.dp_nominal_pos = 0.0 "Absolute value of nominal pressure difference" /* 0.0 */;
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.preDro.m_flow_nominal = bui.terUniCoo.hex.bal1.m_flow_nominal "Nominal mass flow rate";
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.preDro.m_flow_small(min = 0) = 1.0E-4 * abs(bui.terUniCoo.hex.bal1.preDro.m_flow_nominal) "Small mass flow rate for regularization of zero flow";
 structural parameter Boolean bui.terUniCoo.hex.bal1.preDro.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.preDro.m_flow(nominal = if bui.terUniCoo.hex.bal1.preDro.m_flow_nominal_pos > 1.0E-15 then bui.terUniCoo.hex.bal1.preDro.m_flow_nominal_pos else 1,start = 0.0) = bui.terUniCoo.hex.bal1.preDro.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniCoo.hex.bal1.preDro.dp(nominal = 1,start = 0.0,displayUnit = "Pa") = bui.terUniCoo.hex.bal1.preDro.port_a.p - bui.terUniCoo.hex.bal1.preDro.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.preDro._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal1.preDro._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniCoo.hex.bal1.preDro.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.bal1.preDro.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.hex.bal1.preDro.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.hex.bal1.preDro.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.hex.bal1.preDro.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.hex.bal1.preDro.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.bal1.preDro.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.hex.bal1.preDro.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.hex.bal1.preDro.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.hex.bal1.preDro.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.hex.bal1.preDro.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal1.hOut(unit = "J/kg") "Leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal1.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal1.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal1.heaInp.y = bui.terUniCoo.hex.bal1.Q_flow "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal1.masExc.y = bui.terUniCoo.hex.bal1.mWat_flow "Value of Real output";
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.m_flow_nominal = bui.terUniCoo.hex.m1_flow_nominal "Nominal mass flow rate";
 parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.m_flow_small(min = 0) = bui.terUniCoo.hex.m1_flow_small "Small mass flow rate for regularization of zero flow";
 structural parameter Boolean bui.terUniCoo.hex.bal1.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1.m_flow(start = 0.0) = bui.terUniCoo.hex.bal1.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniCoo.hex.bal1.dp(start = 0.0,displayUnit = "Pa") = bui.terUniCoo.hex.bal1.port_a.p - bui.terUniCoo.hex.bal1.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal1._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal1._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniCoo.hex.bal1.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.bal1.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.hex.bal1.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.hex.bal1.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.hex.bal1.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.hex.bal1.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate bui.terUniCoo.hex.bal1.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure bui.terUniCoo.hex.bal1.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy bui.terUniCoo.hex.bal1.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction bui.terUniCoo.hex.bal1.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty bui.terUniCoo.hex.bal1.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.terUniCoo.hex.bal1.computeFlowResistance = false "=true, compute flow resistance. Set to false to assume no friction" /* false */;
 eval parameter Boolean bui.terUniCoo.hex.bal1.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal1.dp_nominal = 0 "Pressure difference" /* 0 */;
 structural parameter Boolean bui.terUniCoo.hex.bal1.linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real bui.terUniCoo.hex.bal1.deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 constant Boolean bui.terUniCoo.hex.bal2.sensibleOnly = true "Set to true if sensible exchange only";
 constant Boolean bui.terUniCoo.hex.bal2.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of the component temperature";
 constant Boolean bui.terUniCoo.hex.bal2.homotopyInitialization = true "= true, use homotopy method";
 Modelica.SIunits.HeatFlowRate bui.terUniCoo.hex.bal2.Q_flow = bui.terUniCoo.hex.Q2_flow "Heat transferred into the medium";
 Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.mWat_flow = bui.terUniCoo.hex.mWat2_flow "Moisture mass flow rate added to the medium";
 constant Boolean bui.terUniCoo.hex.bal2.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 constant Boolean bui.terUniCoo.hex.bal2.vol.prescribedHeatFlowRate = true "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";
 eval parameter Boolean bui.terUniCoo.hex.bal2.vol.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean bui.terUniCoo.hex.bal2.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.hex.bal2.vol.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal2.vol.hOut(unit = "J/kg",start = Buildings.Media.Air.specificEnthalpy_pTX(101325.0, 293.15, {0.01, 0.99})) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal2.vol.XiOut[1](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal2.vol.COut[0](each min = 0) "Leaving trace substances of the component";
 eval parameter Boolean bui.terUniCoo.hex.bal2.vol.use_m_flowInv = true "Flag, true if m_flowInv is used in the model" /* true */;
 final parameter Real bui.terUniCoo.hex.bal2.vol.s[1] = {1} "Vector with zero everywhere except where species is" /* { 1 } */;
 Real bui.terUniCoo.hex.bal2.vol.m_flowInv(unit = "s/kg") "Regularization of 1/m_flow of port_a";
 Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.vol.mXi_flow[1] "Mass flow rates of independent substances added to the medium";
 structural parameter Real bui.terUniCoo.hex.bal2.vol.deltaReg = 1.4485382537898948E-6 "Smoothing region for inverseXRegularized" /* 1.4485382537898948E-6 */;
 structural parameter Real bui.terUniCoo.hex.bal2.vol.deltaInvReg = 690351.1159499184 "Inverse value of delta for inverseXRegularized" /* 690351.1159499184 */;
 structural parameter Real bui.terUniCoo.hex.bal2.vol.aReg = -1.0355266739248777E7 "Polynomial coefficient for inverseXRegularized" /* -1.0355266739248777E7 */;
 structural parameter Real bui.terUniCoo.hex.bal2.vol.bReg = 5.671357493190242E13 "Polynomial coefficient for inverseXRegularized" /* 5.671357493190242E13 */;
 structural parameter Real bui.terUniCoo.hex.bal2.vol.cReg = -1.1877288224784105E20 "Polynomial coefficient for inverseXRegularized" /* -1.1877288224784105E20 */;
 structural parameter Real bui.terUniCoo.hex.bal2.vol.dReg = 1.2128899064693008E26 "Polynomial coefficient for inverseXRegularized" /* 1.2128899064693008E26 */;
 structural parameter Real bui.terUniCoo.hex.bal2.vol.eReg = -5.958456220469665E31 "Polynomial coefficient for inverseXRegularized" /* -5.958456220469665E31 */;
 structural parameter Real bui.terUniCoo.hex.bal2.vol.fReg = 1.1257799939962011E37 "Polynomial coefficient for inverseXRegularized" /* 1.1257799939962011E37 */;
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniCoo.hex.bal2.vol.state_default(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01}) "Medium state at default values";
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.hex.bal2.vol.cp_default = Buildings.Media.Air.specificHeatCapacityCp(bui.terUniCoo.hex.bal2.vol.state_default) "Specific heat capacity, used to verify energy conservation";
 constant Modelica.SIunits.TemperatureDifference bui.terUniCoo.hex.bal2.vol.dTMax = 200 "Maximum temperature difference across the StaticTwoPortConservationEquation" annotation(absoluteValue = false);
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.hex.bal2.vol.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.hex.bal2.vol.C_flow_internal[0] "Needed to connect to conditional connector";
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.vol.m_flow_nominal = 14.485382537898948 "Nominal mass flow rate" /* 14.485382537898948 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.vol.m_flow_small = 0.0014485382537898948 "Small mass flow rate for regularization of zero flow" /* 0.0014485382537898948 */;
 structural parameter Boolean bui.terUniCoo.hex.bal2.vol.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.vol.m_flow(start = 0.0) = bui.terUniCoo.hex.bal2.vol.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniCoo.hex.bal2.vol.dp(start = 0.0,displayUnit = "Pa") = bui.terUniCoo.hex.bal2.vol.port_a.p - bui.terUniCoo.hex.bal2.vol.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.vol._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal2.vol._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniCoo.hex.bal2.vol.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.bal2.vol.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.hex.bal2.vol.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.hex.bal2.vol.port_a.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.hex.bal2.vol.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.hex.bal2.vol.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.bal2.vol.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.hex.bal2.vol.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.hex.bal2.vol.port_b.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.hex.bal2.vol.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.hex.bal2.vol.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Real bui.terUniCoo.hex.bal2.preDro.deltaM = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs" /* 0.1 */;
 parameter Real bui.terUniCoo.hex.bal2.preDro.k = if 200.0 > 1.0E-15 then 14.485382537898948 / sqrt(200.0) else 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)" /* 1.0242712220629548 */;
 eval parameter Boolean bui.terUniCoo.hex.bal2.preDro.computeFlowResistance = true "Flag to enable/disable computation of flow resistance" /* true */;
 parameter Real bui.terUniCoo.hex.bal2.preDro.coeff = 0 "Precomputed coefficient to avoid division by parameter" /* 0 */;
 constant Boolean bui.terUniCoo.hex.bal2.preDro.homotopyInitialization = true "= true, use homotopy method";
 eval parameter Boolean bui.terUniCoo.hex.bal2.preDro.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal2.preDro.dp_nominal = 200 "Pressure drop at nominal mass flow rate" /* 200 */;
 eval parameter Boolean bui.terUniCoo.hex.bal2.preDro.linearized = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.preDro.m_flow_turbulent = 1.448538253789895 "Turbulent flow if |m_flow| >= m_flow_turbulent" /* 1.448538253789895 */;
 parameter Buildings.Media.Air.ThermodynamicState bui.terUniCoo.hex.bal2.preDro.sta_default(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01, 0.99});
 parameter Modelica.SIunits.DynamicViscosity bui.terUniCoo.hex.bal2.preDro.eta_default = Buildings.Media.Air.dynamicViscosity(bui.terUniCoo.hex.bal2.preDro.sta_default) "Dynamic viscosity, used to compute transition to turbulent flow regime";
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.preDro.m_flow_nominal_pos = 14.485382537898948 "Absolute value of nominal flow rate" /* 14.485382537898948 */;
 structural parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal2.preDro.dp_nominal_pos = 200.0 "Absolute value of nominal pressure difference" /* 200.0 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.preDro.m_flow_nominal = 14.485382537898948 "Nominal mass flow rate" /* 14.485382537898948 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.preDro.m_flow_small = 0.0014485382537898948 "Small mass flow rate for regularization of zero flow" /* 0.0014485382537898948 */;
 structural parameter Boolean bui.terUniCoo.hex.bal2.preDro.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.preDro.m_flow(nominal = 14.485382537898948,start = 0.0) = bui.terUniCoo.hex.bal2.preDro.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniCoo.hex.bal2.preDro.dp(nominal = 200.0,start = 0.0,displayUnit = "Pa") = bui.terUniCoo.hex.bal2.preDro.port_a.p - bui.terUniCoo.hex.bal2.preDro.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.preDro._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal2.preDro._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniCoo.hex.bal2.preDro.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.bal2.preDro.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.hex.bal2.preDro.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.hex.bal2.preDro.port_a.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.hex.bal2.preDro.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.hex.bal2.preDro.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.bal2.preDro.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.hex.bal2.preDro.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.hex.bal2.preDro.port_b.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.hex.bal2.preDro.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.hex.bal2.preDro.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal2.hOut(unit = "J/kg") "Leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal2.XiOut[1](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal2.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal2.heaInp.y = bui.terUniCoo.hex.bal2.Q_flow "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput bui.terUniCoo.hex.bal2.masExc.y = bui.terUniCoo.hex.bal2.mWat_flow "Value of Real output";
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.m_flow_nominal = 14.485382537898948 "Nominal mass flow rate" /* 14.485382537898948 */;
 structural parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.m_flow_small = 0.0014485382537898948 "Small mass flow rate for regularization of zero flow" /* 0.0014485382537898948 */;
 structural parameter Boolean bui.terUniCoo.hex.bal2.show_T = false "= true, if actual temperature at port is computed" /* false */;
 Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2.m_flow(start = 0.0) = bui.terUniCoo.hex.bal2.port_a.m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
 Modelica.SIunits.Pressure bui.terUniCoo.hex.bal2.dp(start = 0.0,displayUnit = "Pa") = bui.terUniCoo.hex.bal2.port_a.p - bui.terUniCoo.hex.bal2.port_b.p "Pressure difference between port_a and port_b";
 final parameter Modelica.SIunits.MassFlowRate bui.terUniCoo.hex.bal2._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal2._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 eval parameter Boolean bui.terUniCoo.hex.bal2.allowFlowReversal = false "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* false */;
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.bal2.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.hex.bal2.port_a.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.hex.bal2.port_a.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.hex.bal2.port_a.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.hex.bal2.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFlowRate bui.terUniCoo.hex.bal2.port_b.m_flow(max = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Air.AbsolutePressure bui.terUniCoo.hex.bal2.port_b.p(start = 101325.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Air.SpecificEnthalpy bui.terUniCoo.hex.bal2.port_b.h_outflow(start = 45300.945,nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Air.MassFraction bui.terUniCoo.hex.bal2.port_b.Xi_outflow[1] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Air.ExtraProperty bui.terUniCoo.hex.bal2.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 eval parameter Boolean bui.terUniCoo.hex.bal2.computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction" /* true */;
 eval parameter Boolean bui.terUniCoo.hex.bal2.from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)" /* false */;
 structural parameter Modelica.SIunits.Pressure bui.terUniCoo.hex.bal2.dp_nominal = 200 "Pressure difference" /* 200 */;
 structural parameter Boolean bui.terUniCoo.hex.bal2.linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate" /* false */;
 structural parameter Real bui.terUniCoo.hex.bal2.deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar" /* 0.1 */;
 Buildings.Media.Water.ThermodynamicState bui.terUniCoo.hex.state_a1_inflow(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(bui.terUniCoo.hex.port_a1.p, inStream(bui.terUniCoo.hex.port_a1.h_outflow), inStream(bui.terUniCoo.hex.port_a1.Xi_outflow[1:0])) "state for medium inflowing through port_a1";
 Buildings.Media.Water.ThermodynamicState bui.terUniCoo.hex.state_b1_inflow(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_phX(bui.terUniCoo.hex.port_b1.p, inStream(bui.terUniCoo.hex.port_b1.h_outflow), inStream(bui.terUniCoo.hex.port_b1.Xi_outflow[1:0])) "state for medium inflowing through port_b1";
 Buildings.Media.Air.ThermodynamicState bui.terUniCoo.hex.state_a2_inflow(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_phX(bui.terUniCoo.hex.port_a2.p, inStream(bui.terUniCoo.hex.port_a2.h_outflow), inStream(bui.terUniCoo.hex.port_a2.Xi_outflow[1:1])) "state for medium inflowing through port_a2";
 Buildings.Media.Air.ThermodynamicState bui.terUniCoo.hex.state_b2_inflow(p(start = 101325.0),T(start = 293.15),X(size() = {2},start = {0.01, 0.99})) = Buildings.Media.Air.setState_phX(bui.terUniCoo.hex.port_b2.p, inStream(bui.terUniCoo.hex.port_b2.h_outflow), inStream(bui.terUniCoo.hex.port_b2.Xi_outflow[1:1])) "state for medium inflowing through port_b2";
 constant Boolean bui.terUniCoo.sinAir.checkWaterPressure = false "Evaluates to true if the pressure should be checked";
 constant Boolean bui.terUniCoo.sinAir.checkAirPressure = true "Evaluates to true if the pressure should be checked";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.sinAir.T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.sinAir.h_internal = Buildings.Media.Air.specificEnthalpy(Buildings.Media.Air.setState_pTX(bui.terUniCoo.sinAir.p_in_internal, bui.terUniCoo.sinAir.T_in_internal, bui.terUniCoo.sinAir.X_in_internal[1:2])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection bui.terUniCoo.sinAir.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.sinAir.p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.sinAir.Xi_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.sinAir.X_in_internal[2](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.sinAir.C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 constant Boolean bui.terUniCoo.retAir.checkWaterPressure = false "Evaluates to true if the pressure should be checked";
 constant Boolean bui.terUniCoo.retAir.checkAirPressure = true "Evaluates to true if the pressure should be checked";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.retAir.T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.retAir.h_internal = Buildings.Media.Air.specificEnthalpy(Buildings.Media.Air.setState_pTX(bui.terUniCoo.retAir.p_in_internal, bui.terUniCoo.retAir.T_in_internal, bui.terUniCoo.retAir.X_in_internal[1:2])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection bui.terUniCoo.retAir.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.retAir.p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.retAir.Xi_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.retAir.X_in_internal[2](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput bui.terUniCoo.retAir.C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 parameter Modelica.SIunits.ThermalConductance bui.terUniCoo.TLoaODE.G = -167690.0 / (bui.terUniCoo.TLoaODE.TOutHea_nominal - bui.terUniCoo.TLoaODE.TIndHea_nominal) "Lumped thermal conductance representing all temperature dependent heat transfer mechanisms";
 structural parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.cpHeaWat_nominal = 4184 "Heating water specific heat capacity at nominal conditions" /* 4184 */;
 structural parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.cpChiWat_nominal = 4184 "Chilled water specific heat capacity at nominal conditions" /* 4184 */;
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.cpLoaHea_nominal = Buildings.Media.Air.specificHeatCapacityCp(Buildings.Media.Air.setState_pTX(101325.0, bui.terUniCoo.T_aLoaHea_nominal, global(Buildings.Media.Air.reference_X[1:2]))) "Load side fluid specific heat capacity at nominal conditions in heating mode";
 parameter Modelica.SIunits.SpecificHeatCapacity bui.terUniCoo.cpLoaCoo_nominal = Buildings.Media.Air.specificHeatCapacityCp(Buildings.Media.Air.setState_pTX(101325.0, bui.terUniCoo.T_aLoaCoo_nominal, global(Buildings.Media.Air.reference_X[1:2]))) "Load side fluid specific heat capacity at nominal conditions in cooling mode";
 Modelica.Blocks.Interfaces.RealInput supChiWat.m_flow_in_internal(final unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supChiWat.T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supChiWat.h_internal = Buildings.Media.Water.specificEnthalpy(Buildings.Media.Water.setState_pTX(supChiWat.p_in_internal, supChiWat.T_in_internal, supChiWat.X_in_internal[1:1])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection supChiWat.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput supChiWat.p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supChiWat.Xi_in_internal[0](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supChiWat.X_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supChiWat.C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supHeaWat.m_flow_in_internal(final unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supHeaWat.T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supHeaWat.h_internal = Buildings.Media.Water.specificEnthalpy(Buildings.Media.Water.setState_pTX(supHeaWat.p_in_internal, supHeaWat.T_in_internal, supHeaWat.X_in_internal[1:1])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection supHeaWat.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput supHeaWat.p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supHeaWat.Xi_in_internal[0](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supHeaWat.X_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput supHeaWat.C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 constant Boolean sinChiWat.checkWaterPressure = true "Evaluates to true if the pressure should be checked";
 constant Boolean sinChiWat.checkAirPressure = false "Evaluates to true if the pressure should be checked";
 Modelica.Blocks.Interfaces.RealInput sinChiWat.T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput sinChiWat.h_internal = Buildings.Media.Water.specificEnthalpy(Buildings.Media.Water.setState_pTX(sinChiWat.p_in_internal, sinChiWat.T_in_internal, sinChiWat.X_in_internal[1:1])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection sinChiWat.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput sinChiWat.p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput sinChiWat.Xi_in_internal[0](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput sinChiWat.X_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput sinChiWat.C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 constant Boolean sinHeaWat.checkWaterPressure = true "Evaluates to true if the pressure should be checked";
 constant Boolean sinHeaWat.checkAirPressure = false "Evaluates to true if the pressure should be checked";
 Modelica.Blocks.Interfaces.RealInput sinHeaWat.T_in_internal(final unit = "K",displayUnit = "degC") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput sinHeaWat.h_internal = Buildings.Media.Water.specificEnthalpy(Buildings.Media.Water.setState_pTX(sinHeaWat.p_in_internal, sinHeaWat.T_in_internal, sinHeaWat.X_in_internal[1:1])) "Internal connector for enthalpy";
 eval parameter Modelica.Fluid.Types.PortFlowDirection sinHeaWat.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
 Modelica.Blocks.Interfaces.RealInput sinHeaWat.p_in_internal(final unit = "Pa") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput sinHeaWat.Xi_in_internal[0](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput sinHeaWat.X_in_internal[1](each final unit = "kg/kg") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput sinHeaWat.C_in_internal[0](final quantity = fill("", 0)) "Needed to connect to conditional connector";
 final parameter Modelica.SIunits.VolumeFlowRate pumBui._VMachine_flow = 0 "Start value for VMachine_flow, used to avoid a warning if not specified" /* 0 */;
 structural parameter Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable pumBui.preVar = Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate "Type of prescribed variable" /* Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate */;
 structural parameter Boolean pumBui.speedIsInput = false "Parameter that is true if speed is the controlled variables" /* false */;
 eval parameter Integer pumBui.nOri = 2 "Number of data points for pressure curve" /* 2 */;
 structural parameter Boolean pumBui.haveVMax = true "Flag, true if user specified data that contain V_flow_max" /* true */;
 structural parameter Modelica.SIunits.VolumeFlowRate pumBui.V_flow_max = 0.007056001788452546 "Maximum volume flow rate, used for smoothing" /* 0.007056001788452546 */;
 structural parameter Modelica.SIunits.Density pumBui.rho_default = 995.586 "Default medium density" /* 995.586 */;
 parameter Buildings.Media.Water.ThermodynamicState pumBui.sta_start(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(pumBui.p_start, pumBui.T_start, pumBui.X_start[1:1]) "Medium state at start values";
 parameter Modelica.SIunits.SpecificEnergy pumBui.h_outflow_start = Buildings.Media.Water.specificEnthalpy(pumBui.sta_start) "Start value for outflowing enthalpy";
 Modelica.Blocks.Interfaces.RealInput pumBui.inputSwitch.u "Connector of Real input signal";
 Modelica.Blocks.Interfaces.RealOutput pumBui.inputSwitch.y "Connector of Real output signal";
 parameter Modelica.SIunits.Time pumBui.vol.tau = pumBui.tau "Time constant at nominal flow";
 parameter Modelica.SIunits.Volume pumBui.vol.V_nominal = 7.024856596558317 * pumBui.vol.tau / pumBui.vol.rho_default "Volume of delay element";
 eval parameter Boolean pumBui.vol.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.SIunits.ThermodynamicTemperature pumBui.vol.heatPort.T(start = pumBui.vol.T_start) "Port temperature";
 Modelica.SIunits.HeatFlowRate pumBui.vol.heatPort.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 eval parameter Boolean pumBui.vol.initialize_p = false "= true to set up initial equations for pressure" /* false */;
 constant Boolean pumBui.vol.prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
 constant Boolean pumBui.vol.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
 structural parameter Modelica.SIunits.MassFlowRate pumBui.vol.m_flow_nominal = 7.024856596558317 "Nominal mass flow rate" /* 7.024856596558317 */;
 eval parameter Integer pumBui.vol.nPorts = 2 "Number of ports" /* 2 */;
 structural parameter Modelica.SIunits.MassFlowRate pumBui.vol.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 eval parameter Boolean pumBui.vol.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports." /* true */;
 parameter Modelica.SIunits.Volume pumBui.vol.V = pumBui.vol.V_nominal "Volume";
 Buildings.Media.Water.MassFlowRate pumBui.vol.ports[1].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.vol.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.vol.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.vol.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.vol.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate pumBui.vol.ports[2].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.vol.ports[2].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.vol.ports[2].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.vol.ports[2].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.vol.ports[2].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.Temperature pumBui.vol.T(start = 293.15) = Buildings.Media.Water.temperature_phX(pumBui.vol.p, pumBui.vol.hOut_internal, cat(1, pumBui.vol.Xi[1:0], {1 - sum(pumBui.vol.Xi[1:0])})) "Temperature of the fluid";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.U(unit = "J") "Internal energy of the component";
 Modelica.SIunits.Pressure pumBui.vol.p = pumBui.vol.ports[1].p "Pressure of the fluid";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.m(unit = "kg") "Mass of the component";
 Modelica.SIunits.MassFraction pumBui.vol.Xi[0] = pumBui.vol.XiOut_internal[1:0] "Species concentration of the fluid";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.mXi[0](each unit = "kg") "Species mass of the component";
 Buildings.Media.Water.ExtraProperty pumBui.vol.C[0](nominal = pumBui.vol.C_nominal[1:0]) = pumBui.vol.COut_internal[1:0] "Trace substance mixture content";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.mC[0](each unit = "kg") "Trace substance mass of the component";
 eval parameter Boolean pumBui.vol.dynBal.initialize_p = false "= true to set up initial equations for pressure" /* false */;
 constant Boolean pumBui.vol.dynBal.simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";
 eval parameter Integer pumBui.vol.dynBal.nPorts = 2 "Number of ports" /* 2 */;
 eval parameter Boolean pumBui.vol.dynBal.use_mWat_flow = false "Set to true to enable input connector for moisture mass flow rate" /* false */;
 eval parameter Boolean pumBui.vol.dynBal.use_C_flow = false "Set to true to enable input connector for trace substance" /* false */;
 Modelica.Blocks.Interfaces.RealInput pumBui.vol.dynBal.Q_flow(unit = "W") "Sensible plus latent heat flow rate transferred into the medium";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.dynBal.hOut(unit = "J/kg",start = pumBui.vol.dynBal.hStart) "Leaving specific enthalpy of the component";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.dynBal.XiOut[0](each unit = "1",each min = 0,each max = 1) "Leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.dynBal.COut[0](each min = 0) "Leaving trace substances of the component";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.dynBal.UOut(unit = "J") "Internal energy of the component";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.dynBal.mXiOut[0](each min = 0,each unit = "kg") "Species mass of the component";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.dynBal.mOut(min = 0,unit = "kg") "Mass of the component";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.dynBal.mCOut[0](each min = 0,each unit = "kg") "Trace substance mass of the component";
 Buildings.Media.Water.MassFlowRate pumBui.vol.dynBal.ports[1].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.vol.dynBal.ports[1].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.vol.dynBal.ports[1].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.vol.dynBal.ports[1].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.vol.dynBal.ports[1].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate pumBui.vol.dynBal.ports[2].m_flow "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.vol.dynBal.ports[2].p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.vol.dynBal.ports[2].h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.vol.dynBal.ports[2].Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.vol.dynBal.ports[2].C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.Temperature pumBui.vol.dynBal.medium.T(start = pumBui.vol.dynBal.T_start,stateSelect = StateSelect.default) "Temperature of medium";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.vol.dynBal.medium.InputAbsolutePressure pumBui.vol.dynBal.medium.p(start = pumBui.vol.dynBal.p_start) "Absolute pressure of medium";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.vol.dynBal.medium.InputMassFraction pumBui.vol.dynBal.medium.Xi[0](start = pumBui.vol.dynBal.X_start[1:0]) = fill(0, 0) "Structurally independent mass fractions";
 Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.vol.dynBal.medium.InputSpecificEnthalpy pumBui.vol.dynBal.medium.h(start = pumBui.vol.dynBal.hStart) "Specific enthalpy of medium";
 Modelica.SIunits.SpecificEnergy pumBui.vol.dynBal.medium.u "Specific internal energy of medium";
 Modelica.SIunits.Density pumBui.vol.dynBal.medium.d(start = pumBui.vol.dynBal.rho_start) = 995.586 "Density of medium";
 Modelica.SIunits.MassFraction pumBui.vol.dynBal.medium.X[1](start = pumBui.vol.dynBal.X_start[1:1]) = {1} "Mass fractions (= (component mass)/total mass  m_i/m)";
 Modelica.SIunits.SpecificHeatCapacity pumBui.vol.dynBal.medium.R = 0 "Gas constant (of mixture if applicable)";
 Modelica.SIunits.MolarMass pumBui.vol.dynBal.medium.MM = 0.018015268 "Molar mass (of mixture or single fluid)";
 Buildings.Media.Water.ThermodynamicState pumBui.vol.dynBal.medium.state(p(start = 300000.0),T(start = 293.15)) "Thermodynamic state record for optional functions";
 eval parameter Boolean pumBui.vol.dynBal.medium.preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium" /* false */;
 final parameter Boolean pumBui.vol.dynBal.medium.standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones" /* true */;
 Modelica.SIunits.Conversions.NonSIunits.Temperature_degC pumBui.vol.dynBal.medium.T_degC = Modelica.SIunits.Conversions.to_degC(pumBui.vol.dynBal.medium.T) "Temperature of medium in [degC]";
 Modelica.SIunits.Conversions.NonSIunits.Pressure_bar pumBui.vol.dynBal.medium.p_bar = Modelica.SIunits.Conversions.to_bar(pumBui.vol.dynBal.medium.p) "Absolute pressure of medium in [bar]";
 Modelica.SIunits.Energy pumBui.vol.dynBal.U(start = pumBui.vol.dynBal.fluidVolume * pumBui.vol.dynBal.rho_start * Buildings.Media.Water.specificInternalEnergy(Buildings.Media.Water.setState_pTX(pumBui.vol.dynBal.p_start, pumBui.vol.dynBal.T_start, pumBui.vol.dynBal.X_start[1:0])) + (pumBui.vol.dynBal.T_start - 273.15) * pumBui.vol.dynBal.CSen,nominal = 100000.0) "Internal energy of fluid";
 Modelica.SIunits.Mass pumBui.vol.dynBal.m(start = pumBui.vol.V * pumBui.vol.rho_start,stateSelect = StateSelect.prefer) "Mass of fluid";
 Modelica.SIunits.Mass pumBui.vol.dynBal.mXi[0](start = pumBui.vol.dynBal.fluidVolume * pumBui.vol.dynBal.rho_start * pumBui.vol.dynBal.X_start[1:0]) "Masses of independent components in the fluid";
 Modelica.SIunits.Mass pumBui.vol.dynBal.mC[0](start = pumBui.vol.dynBal.fluidVolume * pumBui.vol.dynBal.rho_start * pumBui.vol.dynBal.C_start[1:0]) "Masses of trace substances in the fluid";
 Buildings.Media.Water.ExtraProperty pumBui.vol.dynBal.C[0](nominal = pumBui.vol.dynBal.C_nominal[1:0]) "Trace substance mixture content";
 Modelica.SIunits.MassFlowRate pumBui.vol.dynBal.mb_flow "Mass flows across boundaries";
 Modelica.SIunits.MassFlowRate pumBui.vol.dynBal.mbXi_flow[0] "Substance mass flows across boundaries";
 Buildings.Media.Water.ExtraPropertyFlowRate pumBui.vol.dynBal.mbC_flow[0] "Trace substance mass flows across boundaries";
 Modelica.SIunits.EnthalpyFlowRate pumBui.vol.dynBal.Hb_flow "Enthalpy flow across boundaries or energy source/sink";
 parameter Modelica.SIunits.Volume pumBui.vol.dynBal.fluidVolume = pumBui.vol.V "Volume";
 parameter Modelica.SIunits.HeatCapacity pumBui.vol.dynBal.CSen = (1.0 - 1) * pumBui.vol.dynBal.rho_default * pumBui.vol.dynBal.cp_default * pumBui.vol.dynBal.fluidVolume "Aditional heat capacity for implementing mFactor";
 Buildings.Media.Water.EnthalpyFlowRate pumBui.vol.dynBal.ports_H_flow[2];
 Modelica.SIunits.MassFlowRate pumBui.vol.dynBal.ports_mXi_flow[2,0];
 Buildings.Media.Water.ExtraPropertyFlowRate pumBui.vol.dynBal.ports_mC_flow[2,0];
 parameter Modelica.SIunits.SpecificHeatCapacity pumBui.vol.dynBal.cp_default = Buildings.Media.Water.specificHeatCapacityCp(pumBui.vol.dynBal.state_default) "Heat capacity, to compute additional dry mass";
 parameter Modelica.SIunits.Density pumBui.vol.dynBal.rho_start = Buildings.Media.Water.density(Buildings.Media.Water.setState_pTX(pumBui.vol.dynBal.p_start, pumBui.vol.dynBal.T_start, pumBui.vol.dynBal.X_start[1:0])) "Density, used to compute fluid mass";
 eval parameter Boolean pumBui.vol.dynBal.computeCSen = false /* false */;
 parameter Buildings.Media.Water.ThermodynamicState pumBui.vol.dynBal.state_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Medium state at default values";
 parameter Modelica.SIunits.Density pumBui.vol.dynBal.rho_default = Buildings.Media.Water.density(pumBui.vol.dynBal.state_default) "Density, used to compute fluid mass";
 final parameter Real pumBui.vol.dynBal.s[0] = {} "Vector with zero everywhere except where species is" /* (zero-size array) */;
 parameter Modelica.SIunits.SpecificEnergy pumBui.vol.dynBal.hStart = Buildings.Media.Water.specificEnthalpy_pTX(pumBui.vol.dynBal.p_start, pumBui.vol.dynBal.T_start, pumBui.vol.dynBal.X_start[1:1]) "Start value for specific enthalpy";
 constant Boolean pumBui.vol.dynBal._simplify_mWat_flow = false "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";
 Modelica.Blocks.Interfaces.RealInput pumBui.vol.dynBal.mWat_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput pumBui.vol.dynBal.C_flow_internal[0] "Needed to connect to conditional connector";
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.vol.dynBal.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.vol.dynBal.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.vol.dynBal.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.vol.dynBal.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Water.AbsolutePressure pumBui.vol.dynBal.p_start(start = 300000.0) = pumBui.vol.p_start "Start value of pressure";
 parameter Buildings.Media.Water.Temperature pumBui.vol.dynBal.T_start(start = 293.15) = pumBui.vol.T_start "Start value of temperature";
 parameter Buildings.Media.Water.MassFraction pumBui.vol.dynBal.X_start[1](quantity = {"SimpleLiquidWater"}) = pumBui.vol.X_start[1:1] "Start value of mass fractions m_i/m";
 parameter Buildings.Media.Water.ExtraProperty pumBui.vol.dynBal.C_start[0](quantity = fill("", 0)) = pumBui.vol.C_start[1:0] "Start value of trace substances";
 parameter Buildings.Media.Water.ExtraProperty pumBui.vol.dynBal.C_nominal[0](quantity = fill("", 0)) = pumBui.vol.C_nominal[1:0] "Nominal value of trace substances. (Set to typical order of magnitude.)";
 structural parameter Real pumBui.vol.dynBal.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 parameter Modelica.SIunits.Density pumBui.vol.rho_start = Buildings.Media.Water.density(pumBui.vol.state_start) "Density, used to compute start and guess values";
 parameter Buildings.Media.Water.ThermodynamicState pumBui.vol.state_default(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(300000.0, 293.15, fill(0.0, 0)) "Medium state at default values";
 parameter Modelica.SIunits.Density pumBui.vol.rho_default = Buildings.Media.Water.density(pumBui.vol.state_default) "Density, used to compute fluid mass";
 parameter Buildings.Media.Water.ThermodynamicState pumBui.vol.state_start(p(start = 300000.0),T(start = 293.15)) = Buildings.Media.Water.setState_pTX(pumBui.vol.p_start, pumBui.vol.T_start, pumBui.vol.X_start[1:0]) "Medium state at start values";
 eval parameter Boolean pumBui.vol.useSteadyStateTwoPort = false "Flag, true if the model has two ports only and uses a steady state balance" /* false */;
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.hOut_internal(unit = "J/kg") "Internal connector for leaving temperature of the component";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.XiOut_internal[0](each unit = "1") "Internal connector for leaving species concentration of the component";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.COut_internal[0](each unit = "1") "Internal connector for leaving trace substances of the component";
 Modelica.SIunits.ThermodynamicTemperature pumBui.vol.preTem.port.T "Port temperature";
 Modelica.SIunits.HeatFlowRate pumBui.vol.preTem.port.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.Blocks.Interfaces.RealInput pumBui.vol.preTem.T;
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.portT.y = pumBui.vol.T "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput pumBui.vol.heaFloSen.Q_flow(unit = "W") "Heat flow from port_a to port_b as output signal";
 Modelica.SIunits.ThermodynamicTemperature pumBui.vol.heaFloSen.port_a.T "Port temperature";
 Modelica.SIunits.HeatFlowRate pumBui.vol.heaFloSen.port_a.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.SIunits.ThermodynamicTemperature pumBui.vol.heaFloSen.port_b.T "Port temperature";
 Modelica.SIunits.HeatFlowRate pumBui.vol.heaFloSen.port_b.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.vol.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.vol.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of mass balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.vol.substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 eval parameter Modelica.Fluid.Types.Dynamics pumBui.vol.traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state" /* Modelica.Fluid.Types.Dynamics.FixedInitial */;
 parameter Buildings.Media.Water.AbsolutePressure pumBui.vol.p_start(start = 300000.0) = pumBui.p_start "Start value of pressure";
 parameter Buildings.Media.Water.Temperature pumBui.vol.T_start(start = 293.15) = pumBui.T_start "Start value of temperature";
 parameter Buildings.Media.Water.MassFraction pumBui.vol.X_start[1](quantity = {"SimpleLiquidWater"}) = pumBui.X_start[1:1] "Start value of mass fractions m_i/m";
 parameter Buildings.Media.Water.ExtraProperty pumBui.vol.C_start[0](quantity = fill("", 0)) = pumBui.C_start[1:0] "Start value of trace substances";
 parameter Buildings.Media.Water.ExtraProperty pumBui.vol.C_nominal[0](quantity = fill("", 0)) = fill(0.01, 0) "Nominal value of trace substances. (Set to typical order of magnitude.)" /* (zero-size array) */;
 structural parameter Real pumBui.vol.mSenFac = 1 "Factor for scaling the sensible thermal mass of the volume" /* 1 */;
 eval parameter Boolean pumBui.preSou.control_m_flow = true "if true, then the mass flow rate is equal to the value of m_flow_in" /* true */;
 eval parameter Boolean pumBui.preSou.control_dp = false "if true, then the head is equal to the value of dp_in" /* false */;
 Modelica.Blocks.Interfaces.RealInput pumBui.preSou.m_flow_in(unit = "kg/s") "Prescribed mass flow rate";
 Modelica.Blocks.Interfaces.RealInput pumBui.preSou.m_flow_internal(unit = "kg/s") "Needed to connect to conditional connector";
 Modelica.Blocks.Interfaces.RealInput pumBui.preSou.dp_internal(unit = "Pa") "Needed to connect to conditional connector";
 parameter Modelica.SIunits.Pressure pumBui.preSou.dp_start(displayUnit = "Pa") = 0 "Guess value of dp = port_a.p - port_b.p" /* 0 */;
 parameter Buildings.Media.Water.MassFlowRate pumBui.preSou.m_flow_start = pumBui.m_flow_start "Guess value of m_flow = port_a.m_flow";
 structural parameter Buildings.Media.Water.MassFlowRate pumBui.preSou.m_flow_small = 7.024856596558318E-4 "Small mass flow rate for regularization of zero flow" /* 7.024856596558318E-4 */;
 structural parameter Boolean pumBui.preSou.show_T = false "= true, if temperatures at port_a and port_b are computed" /* false */;
 structural parameter Boolean pumBui.preSou.show_V_flow = true "= true, if volume flow rate at inflowing port is computed" /* true */;
 Buildings.Media.Water.MassFlowRate pumBui.preSou.m_flow(min = -1.0E60,start = pumBui.preSou.m_flow_start) "Mass flow rate in design flow direction";
 Modelica.SIunits.Pressure pumBui.preSou.dp(start = pumBui.preSou.dp_start,displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
 Modelica.SIunits.VolumeFlowRate pumBui.preSou.V_flow = pumBui.preSou.m_flow / Modelica.Fluid.Utilities.regStep(pumBui.preSou.m_flow, Buildings.Media.Water.density(Buildings.Media.Water.setState_phX(pumBui.preSou.port_a.p, inStream(pumBui.preSou.port_a.h_outflow), inStream(pumBui.preSou.port_a.Xi_outflow[1:0]))), Buildings.Media.Water.density(Buildings.Media.Water.setState_phX(pumBui.preSou.port_b.p, inStream(pumBui.preSou.port_b.h_outflow), inStream(pumBui.preSou.port_b.Xi_outflow[1:0]))), 7.024856596558318E-4) "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
 eval parameter Boolean pumBui.preSou.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate pumBui.preSou.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.preSou.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.preSou.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.preSou.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.preSou.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate pumBui.preSou.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.preSou.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.preSou.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.preSou.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.preSou.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 constant Boolean pumBui.heaDis.homotopyInitialization = true "= true, use homotopy method";
 parameter Boolean pumBui.heaDis.motorCooledByFluid = pumBui.per.motorCooledByFluid "Flag, true if the motor is cooled by the fluid stream";
 structural parameter Modelica.SIunits.VolumeFlowRate pumBui.heaDis.delta_V_flow = 7.056001788452547E-6 "Factor used for setting heat input into medium to zero at very small flows" /* 7.056001788452547E-6 */;
 Modelica.Blocks.Interfaces.RealInput pumBui.heaDis.etaHyd(final quantity = "Efficiency",final unit = "1") "Hydraulic efficiency";
 Modelica.Blocks.Interfaces.RealInput pumBui.heaDis.V_flow(final quantity = "VolumeFlowRate",final unit = "m3/s") "Volume flow rate";
 Modelica.Blocks.Interfaces.RealInput pumBui.heaDis.WFlo(final quantity = "Power",final unit = "W") "Flow work";
 Modelica.Blocks.Interfaces.RealInput pumBui.heaDis.PEle(final quantity = "Power",final unit = "W") "Electrical power consumed";
 Modelica.Blocks.Interfaces.RealOutput pumBui.heaDis.Q_flow(quantity = "Power",final unit = "W") "Heat input from fan or pump to medium";
 Modelica.SIunits.Power pumBui.heaDis.WHyd "Hydraulic power input (converted to flow work and heat)";
 Modelica.SIunits.HeatFlowRate pumBui.heaDis.QThe_flow "Heat input from fan or pump to medium";
 final parameter Real pumBui.PToMed.k1 = 1 "Gain of upper input" /* 1 */;
 final parameter Real pumBui.PToMed.k2 = 1 "Gain of lower input" /* 1 */;
 Modelica.Blocks.Interfaces.RealInput pumBui.PToMed.u1 "Connector of Real input signal 1";
 Modelica.Blocks.Interfaces.RealInput pumBui.PToMed.u2 "Connector of Real input signal 2";
 Modelica.Blocks.Interfaces.RealOutput pumBui.PToMed.y "Connector of Real output signal";
 parameter Modelica.SIunits.ThermodynamicTemperature pumBui.prePow.T_ref = 293.15 "Reference temperature" /* 293.15 */;
 final parameter Modelica.SIunits.LinearTemperatureCoefficient pumBui.prePow.alpha = 0 "Temperature coefficient of heat flow rate" /* 0 */;
 Modelica.Blocks.Interfaces.RealInput pumBui.prePow.Q_flow(unit = "W");
 Modelica.SIunits.ThermodynamicTemperature pumBui.prePow.port.T "Port temperature";
 Modelica.SIunits.HeatFlowRate pumBui.prePow.port.Q_flow "Heat flow rate (positive if flowing from outside into the component)";
 Modelica.Blocks.Interfaces.RealOutput pumBui.rho_inlet.y = Buildings.Media.Water.density(Buildings.Media.Water.setState_phX(pumBui.port_a.p, inStream(pumBui.port_a.h_outflow), inStream(pumBui.port_a.Xi_outflow[1:0]))) "Value of Real output";
 Modelica.Blocks.Interfaces.RealOutput pumBui.senMasFlo.m_flow(quantity = "MassFlowRate",final unit = "kg/s") "Mass flow rate from port_a to port_b";
 final parameter Modelica.SIunits.MassFlowRate pumBui.senMasFlo.m_flow_nominal = 0 "Nominal mass flow rate, used for regularization near zero flow" /* 0 */;
 final parameter Modelica.SIunits.MassFlowRate pumBui.senMasFlo.m_flow_small = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)" /* 0 */;
 eval parameter Boolean pumBui.senMasFlo.allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal" /* true */;
 Buildings.Media.Water.MassFlowRate pumBui.senMasFlo.port_a.m_flow(min = -1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.senMasFlo.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.senMasFlo.port_a.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.senMasFlo.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.senMasFlo.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate pumBui.senMasFlo.port_b.m_flow(max = 1.0E60) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.senMasFlo.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.senMasFlo.port_b.h_outflow(start = 83680.0,nominal = 83680.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.senMasFlo.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.senMasFlo.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate pumBui.senRelPre.port_a.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.senRelPre.port_a.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.senRelPre.port_a.h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.senRelPre.port_a.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.senRelPre.port_a.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFlowRate pumBui.senRelPre.port_b.m_flow(min = 0) "Mass flow rate from the connection point into the component";
 Buildings.Media.Water.AbsolutePressure pumBui.senRelPre.port_b.p(start = 300000.0) "Thermodynamic pressure in the connection point";
 Buildings.Media.Water.SpecificEnthalpy pumBui.senRelPre.port_b.h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
 Buildings.Media.Water.MassFraction pumBui.senRelPre.port_b.Xi_outflow[0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
 Buildings.Media.Water.ExtraProperty pumBui.senRelPre.port_b.C_outflow[0] "Properties c_i/m close to the connection point if m_flow < 0";
 Modelica.Blocks.Interfaces.RealOutput pumBui.senRelPre.p_rel(final quantity = "PressureDifference",final unit = "Pa",displayUnit = "Pa") "Relative pressure of port_a minus port_b";
 constant Boolean pumBui.eff.homotopyInitialization = true "= true, use homotopy method";
 parameter Buildings.Fluid.Movers.Data.Generic pumBui.eff.per(pressure(V_flow(size() = {2}),dp(size() = {2})) = Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters({0, 0.014112003576905093}, {300000.0, 0}),use_powerCharacteristic = false,hydraulicEfficiency(V_flow(size() = {1},each min = 0),eta(size() = {1},each max = 1)) = pumBui.per.hydraulicEfficiency,motorEfficiency(V_flow(size() = {1},each min = 0),eta(size() = {1},each max = 1)) = pumBui.per.motorEfficiency,power(V_flow(size() = {1},each min = 0),P(size() = {1},each min = 0)) = pumBui.per.power,motorCooledByFluid = pumBui.per.motorCooledByFluid,speed_nominal = 0,constantSpeed = 0,speeds(size() = {1}) = {0},speed_rpm_nominal = 1500,constantSpeed_rpm = pumBui.eff.per.speed_rpm_nominal,speeds_rpm(size() = {1}) = {pumBui.eff.per.speed_rpm_nominal},havePressureCurve = true) "Record with performance data";
 structural parameter Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable pumBui.eff.preVar = Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate "Type of prescribed variable" /* Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate */;
 structural parameter Boolean pumBui.eff.computePowerUsingSimilarityLaws = false "= true, compute power exactly, using similarity laws. Otherwise approximate." /* false */;
 structural parameter Modelica.SIunits.VolumeFlowRate pumBui.eff.V_flow_nominal = 0.014112003576905093 "Nominal volume flow rate, used for homotopy" /* 0.014112003576905093 */;
 structural parameter Modelica.SIunits.Density pumBui.eff.rho_default = 995.586 "Fluid density at medium default state" /* 995.586 */;
 structural parameter Boolean pumBui.eff.haveVMax = true "Flag, true if user specified data that contain V_flow_max" /* true */;
 structural parameter Modelica.SIunits.VolumeFlowRate pumBui.eff.V_flow_max = 0.007056001788452546 "Maximum volume flow rate, used for smoothing" /* 0.007056001788452546 */;
 eval parameter Integer pumBui.eff.nOri = 2 "Number of data points for pressure curve" /* 2 */;
 Modelica.Blocks.Interfaces.RealOutput pumBui.eff.y_out(final unit = "1") "Mover speed (prescribed or computed)";
 Modelica.Blocks.Interfaces.RealInput pumBui.eff.m_flow(final quantity = "MassFlowRate",final unit = "kg/s") "Mass flow rate";
 Modelica.Blocks.Interfaces.RealInput pumBui.eff.rho(final quantity = "Density",final unit = "kg/m3",min = 0.0) "Medium density";
 Modelica.Blocks.Interfaces.RealOutput pumBui.eff.V_flow(quantity = "VolumeFlowRate",final unit = "m3/s") "Volume flow rate";
 Modelica.Blocks.Interfaces.RealInput pumBui.eff.dp_in(quantity = "PressureDifference",final unit = "Pa") "Prescribed pressure increase";
 Modelica.Blocks.Interfaces.RealOutput pumBui.eff.WFlo(quantity = "Power",final unit = "W") "Flow work";
 Modelica.Blocks.Interfaces.RealOutput pumBui.eff.PEle(quantity = "Power",final unit = "W") "Electrical power consumed";
 Modelica.Blocks.Interfaces.RealOutput pumBui.eff.eta(final quantity = "Efficiency",final unit = "1") "Overall efficiency";
 Modelica.Blocks.Interfaces.RealOutput pumBui.eff.etaHyd(final quantity = "Efficiency",final unit = "1") "Hydraulic efficiency";
 Modelica.Blocks.Interfaces.RealOutput pumBui.eff.etaMot(final quantity = "Efficiency",final unit = "1") "Motor efficiency";
 Modelica.Blocks.Interfaces.RealOutput pumBui.eff.r_N(start = pumBui.y_start,unit = "1") "Ratio N_actual/N_nominal";
 Real pumBui.eff.r_V(start = 7.024856596558317 / 995.586,unit = "1") "Ratio V_flow/V_flow_max";
 structural parameter Boolean pumBui.eff.preSpe = false "True if speed is a prescribed variable of this block" /* false */;
 structural parameter Boolean pumBui.eff.prePre = true "True if pressure head is a prescribed variable of this block" /* true */;
 initial parameter Real pumBui.eff.motDer[1](each fixed = false) "Coefficients for polynomial of motor efficiency vs. volume flow rate";
 initial parameter Real pumBui.eff.hydDer[1](each fixed = false) "Coefficients for polynomial of hydraulic efficiency vs. volume flow rate";
 structural parameter Modelica.SIunits.Pressure pumBui.eff.dpMax = 300000.0 "Maximum head" /* 300000.0 */;
 structural parameter Real pumBui.eff.delta = 0.05 "Small value used to for regularization and to approximate an internal flow resistance of the fan" /* 0.05 */;
 structural parameter Real pumBui.eff.kRes = 10629.249006532391 "Coefficient for internal pressure drop of fan or pump" /* 10629.249006532391 */;
 structural parameter Integer pumBui.eff.curve = 1 "Flag, used to pick the right representatio of the fan or pump pressure curve" /* 1 */;
 parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pumBui.eff.pCur1(n = 2,V_flow(size() = {2}) = {0, 0.014112003576905093},dp(size() = {2},each min = 0,each displayUnit = "Pa") = {300000.0, 0.014112003576905093 * 10629.249006532391}) "Volume flow rate vs. total pressure rise with correction for pump resistance added";
 parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pumBui.eff.pCur2(n = 3,V_flow(size() = {3}) = {0, 0, 0},dp(size() = {3},each min = 0,each displayUnit = "Pa") = zeros(2 + 1)) "Volume flow rate vs. total pressure rise with correction for pump resistance added";
 parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pumBui.eff.pCur3(n = 4,V_flow(size() = {4}) = {0, 0, 0, 0},dp(size() = {4},each min = 0,each displayUnit = "Pa") = zeros(2 + 2)) "Volume flow rate vs. total pressure rise with correction for pump resistance added";
 initial parameter Real pumBui.eff.preDer1[2](each fixed = false) "Derivatives of flow rate vs. pressure at the support points";
 initial parameter Real pumBui.eff.preDer2[3](each fixed = false) "Derivatives of flow rate vs. pressure at the support points";
 initial parameter Real pumBui.eff.preDer3[4](each fixed = false) "Derivatives of flow rate vs. pressure at the support points";
 parameter Real pumBui.eff.powDer[1] = if false then Buildings.Utilities.Math.Functions.splineDerivatives(pumBui.eff.per.power.V_flow[1:1], pumBui.eff.per.power.P[1:1], Buildings.Utilities.Math.Functions.isMonotonic(pumBui.eff.per.power.P[1:1], false)) else zeros(size(pumBui.eff.per.power.V_flow[1:1], 1)) "Coefficients for polynomial of power vs. flow rate";
 structural parameter Boolean pumBui.eff.haveMinimumDecrease = true "Flag used for reporting" /* true */;
 structural parameter Boolean pumBui.eff.haveDPMax = true "Flag, true if user specified data that contain dpMax" /* true */;
 Modelica.Blocks.Interfaces.RealOutput pumBui.eff.dp_internal "If dp is prescribed, use dp_in and solve for r_N, otherwise compute dp using r_N";
 final parameter Modelica.SIunits.MassFlowRate pumBui._m_flow_start = 0 "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window" /* 0 */;
 final parameter Modelica.SIunits.Pressure pumBui._dp_start = 0 "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window" /* 0 */;
 Buildings.Media.Water.ThermodynamicState pre.state(p(start = 300000.0),T(start = 293.15));
 eval parameter Modelica.Fluid.Types.PortFlowDirection pre.flowDirection = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction" /* Modelica.Fluid.Types.PortFlowDirection.Bidirectional */;
global variables
 constant Buildings.Media.Water.MassFraction Buildings.Media.Water.reference_X[1] = {1} "Default mass fractions of medium";
 constant Buildings.Media.Air.MassFraction Buildings.Media.Air.reference_X[2] = {0.01, 0.99} "Default mass fractions of medium";
initial equation
 assert(coo.hex.m1_flow_nominal > 0, "m1_flow_nominal must be positive, m1_flow_nominal = " + String(coo.hex.m1_flow_nominal));
 assert(7.024856596558317 > 0, "m2_flow_nominal must be positive, m2_flow_nominal = " + String(7.024856596558317));
 coo.hex.cp1_nominal = Buildings.Media.Water.specificHeatCapacityCp(coo.hex.sta1_default);
 coo.hex.cp2_nominal = Buildings.Media.Water.specificHeatCapacityCp(coo.hex.sta2_default);
 coo.hex.C1_flow_nominal = coo.hex.m1_flow_nominal * coo.hex.cp1_nominal;
 coo.hex.C2_flow_nominal = 7.024856596558317 * coo.hex.cp2_nominal;
 coo.hex.CMin_flow_nominal = min(coo.hex.C1_flow_nominal, coo.hex.C2_flow_nominal);
 coo.hex.CMax_flow_nominal = max(coo.hex.C1_flow_nominal, coo.hex.C2_flow_nominal);
 coo.hex.Z_nominal = coo.hex.CMin_flow_nominal / coo.hex.CMax_flow_nominal;
 146960.0 = coo.hex.m1_flow_nominal * coo.hex.cp1_nominal * (coo.hex.T_a1_nominal - coo.hex.T_b1_nominal);
 if true then
  146960.0 = -7.024856596558317 * coo.hex.cp2_nominal * (coo.hex.T_a2_nominal - coo.hex.T_b2_nominal);
  coo.hex.eps_nominal = abs(146960.0 / ((coo.hex.T_a1_nominal - coo.hex.T_a2_nominal) * coo.hex.CMin_flow_nominal));
 else
  coo.hex.T_a1_nominal = 293.15;
  coo.hex.T_a2_nominal = 293.15;
  coo.hex.T_b1_nominal = 293.15;
  coo.hex.T_b2_nominal = 293.15;
 end if;
 assert(coo.hex.eps_nominal > 0 and coo.hex.eps_nominal < 1, "eps_nominal out of bounds, eps_nominal = " + String(coo.hex.eps_nominal) + "\n  To achieve the required heat transfer rate at epsilon=0.8, set |T_a1_nominal-T_a2_nominal| = " + String(abs(146960.0 / 0.8 * coo.hex.CMin_flow_nominal)) + "\n  or increase flow rates. The current parameters result in " + "\n  CMin_flow_nominal = " + String(coo.hex.CMin_flow_nominal) + "\n  CMax_flow_nominal = " + String(coo.hex.CMax_flow_nominal));
 if Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1MixedStream2Unmixed then
  coo.hex.flowRegime_nominal = if coo.hex.C1_flow_nominal < coo.hex.C2_flow_nominal then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1UnmixedStream2Mixed then
  coo.hex.flowRegime_nominal = if coo.hex.C1_flow_nominal < coo.hex.C2_flow_nominal then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.ParallelFlow then
  coo.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow then
  coo.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowUnmixed then
  coo.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed;
 else
  coo.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed;
  assert(Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow >= Buildings.Fluid.Types.HeatExchangerConfiguration.ParallelFlow and Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow <= Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1UnmixedStream2Mixed, "Invalid heat exchanger configuration.");
 end if;
 coo.hex.NTU_nominal = if coo.hex.eps_nominal > 0 and coo.hex.eps_nominal < 1 then Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(coo.hex.eps_nominal, coo.hex.Z_nominal, Integer(coo.hex.flowRegime_nominal)) else 0;
 coo.hex.UA_nominal = coo.hex.NTU_nominal * coo.hex.CMin_flow_nominal;
 coo.hex.cp1_default = Buildings.Media.Water.specificHeatCapacityCp(Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0}));
 coo.hex.cp2_default = Buildings.Media.Water.specificHeatCapacityCp(Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0}));
 coo.hex.CMin_flow_small = min(coo.hex.m1_flow_small * coo.hex.cp1_default, 7.024856596558318E-4 * coo.hex.cp2_default);
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal1" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(0 == 0 or abs(sum(fill(0.0, 0)) - 1) < 1.0E-5, "If Medium.nXi > 1, then substance 'water' must be present for one component.'" + "SimpleLiquidWater" + "'.\n" + "Check medium model.");
 if true then
  assert(coo.hex.bal1.preDro.m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
 end if;
 assert(coo.hex.bal1.preDro.m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal1.preDro" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal2" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(0 == 0 or abs(sum(fill(0.0, 0)) - 1) < 1.0E-5, "If Medium.nXi > 1, then substance 'water' must be present for one component.'" + "SimpleLiquidWater" + "'.\n" + "Check medium model.");
 if true then
  assert(0.7024856596558318 > 0, "m_flow_turbulent must be bigger than zero.");
 end if;
 assert(7.024856596558317 > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal2.preDro" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 if Modelica.Blocks.Types.InitPID.InitialOutput == Modelica.Blocks.Types.InitPID.InitialOutput then
  coo.con.gainPID.y = 0.0;
 end if;
 if Modelica.Blocks.Types.Init.NoInit == Modelica.Blocks.Types.Init.SteadyState then
  der(coo.con.I.y) = 0;
 elseif Modelica.Blocks.Types.Init.NoInit == Modelica.Blocks.Types.Init.InitialState or Modelica.Blocks.Types.Init.NoInit == Modelica.Blocks.Types.Init.InitialOutput then
  coo.con.I.y = coo.con.I.y_start;
 end if;
 if Modelica.Blocks.Types.Init.SteadyState == Modelica.Blocks.Types.Init.SteadyState then
  der(coo.con.D.x) = 0;
 elseif Modelica.Blocks.Types.Init.SteadyState == Modelica.Blocks.Types.Init.InitialState then
  coo.con.D.x = coo.con.D.x_start;
 elseif Modelica.Blocks.Types.Init.SteadyState == Modelica.Blocks.Types.Init.InitialOutput then
  if false then
   coo.con.D.x = coo.con.D.u;
  else
   coo.con.D.y = coo.con.D.y_start;
  end if;
 end if;
 if true then
  if Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.SteadyState then
   der(coo.senTDisSup.T) = 0;
  elseif Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.InitialState or Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.InitialOutput then
   coo.senTDisSup.T = coo.senTDisSup.T_start;
  end if;
 end if;
 if true then
  if Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.SteadyState then
   der(coo.senTDisRet.T) = 0;
  elseif Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.InitialState or Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.InitialOutput then
   coo.senTDisRet.T = coo.senTDisRet.T_start;
  end if;
 end if;
 if Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.SteadyState then
  der(coo.int.y) = 0;
 elseif Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.InitialState or Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.InitialOutput then
  coo.int.y = coo.int.y_start;
 end if;
 if true then
  if Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.SteadyState then
   der(coo.TBuiSup.T) = 0;
  elseif Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.InitialState or Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.InitialOutput then
   coo.TBuiSup.T = coo.TBuiSup.T_start;
  end if;
 end if;
 assert(coo.val.l > 0, "Valve leakage parameter l must be bigger than zero.");
 assert(0.0 > -1.0E-15, "In " + "CouplingETS_TimeSeriesBuilding.coo.val" + ": Model requires dpFixed_nominal >= 0 but received dpFixed_nominal = " + String(0.0) + " Pa.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.coo.val" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 if Buildings.Fluid.Types.CvTypes.OpPoint == Buildings.Fluid.Types.CvTypes.OpPoint then
  coo.val.Kv_SI = coo.val.m_flow_nominal / sqrt(coo.val.dpValve_nominal);
  coo.val.Kv = coo.val.Kv_SI / (coo.val.rhoStd / 3600 / sqrt(100000.0));
  coo.val.Cv = coo.val.Kv_SI / (coo.val.rhoStd * 0.0631 / 1000 / sqrt(6895));
  coo.val.Av = coo.val.Kv_SI / sqrt(coo.val.rhoStd);
 elseif Buildings.Fluid.Types.CvTypes.OpPoint == Buildings.Fluid.Types.CvTypes.Kv then
  coo.val.Kv_SI = coo.val.Kv * coo.val.rhoStd / 3600 / sqrt(100000.0);
  coo.val.Cv = coo.val.Kv_SI / (coo.val.rhoStd * 0.0631 / 1000 / sqrt(6895));
  coo.val.Av = coo.val.Kv_SI / sqrt(coo.val.rhoStd);
  coo.val.dpValve_nominal = (coo.val.m_flow_nominal / coo.val.Kv_SI) ^ 2;
 elseif Buildings.Fluid.Types.CvTypes.OpPoint == Buildings.Fluid.Types.CvTypes.Cv then
  coo.val.Kv_SI = coo.val.Cv * coo.val.rhoStd * 0.0631 / 1000 / sqrt(6895);
  coo.val.Kv = coo.val.Kv_SI / (coo.val.rhoStd / 3600 / sqrt(100000.0));
  coo.val.Av = coo.val.Kv_SI / sqrt(coo.val.rhoStd);
  coo.val.dpValve_nominal = (coo.val.m_flow_nominal / coo.val.Kv_SI) ^ 2;
 else
  assert(Buildings.Fluid.Types.CvTypes.OpPoint == Buildings.Fluid.Types.CvTypes.Av, "Invalid value for CvData.
Obtained CvData = " + String(Buildings.Fluid.Types.CvTypes.OpPoint) + ".");
  coo.val.Kv_SI = coo.val.Av * sqrt(coo.val.rhoStd);
  coo.val.Kv = coo.val.Kv_SI / (coo.val.rhoStd / 3600 / sqrt(100000.0));
  coo.val.Cv = coo.val.Kv_SI / (coo.val.rhoStd * 0.0631 / 1000 / sqrt(6895));
  coo.val.dpValve_nominal = (coo.val.m_flow_nominal / coo.val.Kv_SI) ^ 2;
 end if;
 if true then
  if Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.SteadyState then
   der(coo.TBuiRet.T) = 0;
  elseif Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.InitialState or Modelica.Blocks.Types.Init.InitialState == Modelica.Blocks.Types.Init.InitialOutput then
   coo.TBuiRet.T = coo.TBuiRet.T_start;
  end if;
 end if;
 algorithm
  bui.loa.tableOnFileRead := Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.readTableData(bui.loa.tableID, false, bui.loa.verboseRead);
  bui.loa.t_minScaled := Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableTimeTmin(bui.loa.tableID, bui.loa.tableOnFileRead);
  bui.loa.t_maxScaled := Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableTimeTmax(bui.loa.tableID, bui.loa.tableOnFileRead);
  bui.loa.t_min := bui.loa.t_minScaled;
  bui.loa.t_max := bui.loa.t_maxScaled;
;
 assert(16.528673093224516 >= 1.0E-60, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan" + ": The value of parameter m_flow_nominal should be greater or equal than " + String(1.0E-60) + " but it equals " + String(16.528673093224516));
 assert(bui.terUniHea.fan.nominalValuesDefineDefaultPressureCurve or false or Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed, "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve.
             This leads to approximate calculations of the electrical power
             consumption. Add the correct pressure curve in the record per
             to obtain an accurate computation.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.", AssertionLevel.warning);
 assert(bui.terUniHea.fan.nominalValuesDefineDefaultPressureCurve or (false or Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed) or false == false, "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve and you set use_powerCharacteristic = true.
             Since this can cause wrong power consumption, the model will overwrite
             this setting and use instead use_powerCharacteristic = false." + "Since this causes the efficiency curve to be used,
             make sure that the efficiency curves in the performance record per
             are correct or add the pressure curve of the mover.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.", AssertionLevel.warning);
 assert(1 == 0 or abs(sum({1.0}) - 1) < 1.0E-5, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol.dynBal" + ":
         If Medium.nXi > 1, then substance 'water' must be present for one component of '" + "Air" + "'.
         Check medium model.");
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  assert(Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol.dynBal" + ":
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.terUniHea.fan.vol.dynBal.medium.T = bui.terUniHea.fan.vol.dynBal.T_start;
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.terUniHea.fan.vol.dynBal.medium.T) = 0;
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  if true then
   bui.terUniHea.fan.vol.dynBal.medium.p = bui.terUniHea.fan.vol.dynBal.p_start;
  end if;
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   if true then
    der(bui.terUniHea.fan.vol.dynBal.medium.p) = 0;
   end if;
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.terUniHea.fan.vol.dynBal.medium.Xi[1:1] = bui.terUniHea.fan.vol.dynBal.X_start[1:1];
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.terUniHea.fan.vol.dynBal.medium.Xi[1:1]) = zeros(1);
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.terUniHea.fan.vol.dynBal.C[1:0] = bui.terUniHea.fan.vol.dynBal.C_start[1:0];
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.terUniHea.fan.vol.dynBal.C[1:0]) = zeros(0);
  end if;
 end if;
 if Modelica.Blocks.Types.AnalogFilter.CriticalDamping == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
  bui.terUniHea.fan.filter.cr[1:2] = Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, bui.terUniHea.fan.filter.normalized);
 elseif Modelica.Blocks.Types.AnalogFilter.CriticalDamping == Modelica.Blocks.Types.AnalogFilter.Bessel then
  (bui.terUniHea.fan.filter.cr[1:2], bui.terUniHea.fan.filter.c0[1:0], bui.terUniHea.fan.filter.c1[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.base.Bessel(2, bui.terUniHea.fan.filter.normalized);
 elseif Modelica.Blocks.Types.AnalogFilter.CriticalDamping == Modelica.Blocks.Types.AnalogFilter.Butterworth then
  (bui.terUniHea.fan.filter.cr[1:2], bui.terUniHea.fan.filter.c0[1:0], bui.terUniHea.fan.filter.c1[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.base.Butterworth(2, bui.terUniHea.fan.filter.normalized);
 elseif Modelica.Blocks.Types.AnalogFilter.CriticalDamping == Modelica.Blocks.Types.AnalogFilter.ChebyshevI then
  (bui.terUniHea.fan.filter.cr[1:2], bui.terUniHea.fan.filter.c0[1:0], bui.terUniHea.fan.filter.c1[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.base.ChebyshevI(2, bui.terUniHea.fan.filter.A_ripple, bui.terUniHea.fan.filter.normalized);
 end if;
 if Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.LowPass then
  (bui.terUniHea.fan.filter.r[1:2], bui.terUniHea.fan.filter.a[1:0], bui.terUniHea.fan.filter.b[1:0], bui.terUniHea.fan.filter.ku[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(bui.terUniHea.fan.filter.cr[1:2], bui.terUniHea.fan.filter.c0[1:0], bui.terUniHea.fan.filter.c1[1:0], bui.terUniHea.fan.filter.f_cut);
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.HighPass then
  (bui.terUniHea.fan.filter.r[1:2], bui.terUniHea.fan.filter.a[1:0], bui.terUniHea.fan.filter.b[1:0], bui.terUniHea.fan.filter.ku[1:0], bui.terUniHea.fan.filter.k1[1:0], bui.terUniHea.fan.filter.k2[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.roots.highPass(bui.terUniHea.fan.filter.cr[1:2], bui.terUniHea.fan.filter.c0[1:0], bui.terUniHea.fan.filter.c1[1:0], bui.terUniHea.fan.filter.f_cut);
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.BandPass then
  (bui.terUniHea.fan.filter.a[1:0], bui.terUniHea.fan.filter.b[1:0], bui.terUniHea.fan.filter.ku[1:0], bui.terUniHea.fan.filter.k1[1:0], bui.terUniHea.fan.filter.k2[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.roots.bandPass(bui.terUniHea.fan.filter.cr[1:2], bui.terUniHea.fan.filter.c0[1:0], bui.terUniHea.fan.filter.c1[1:0], bui.terUniHea.fan.filter.f_min, bui.terUniHea.fan.filter.f_cut);
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.BandStop then
  (bui.terUniHea.fan.filter.a[1:0], bui.terUniHea.fan.filter.b[1:0], bui.terUniHea.fan.filter.ku[1:0], bui.terUniHea.fan.filter.k1[1:0], bui.terUniHea.fan.filter.k2[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.roots.bandStop(bui.terUniHea.fan.filter.cr[1:2], bui.terUniHea.fan.filter.c0[1:0], bui.terUniHea.fan.filter.c1[1:0], bui.terUniHea.fan.filter.f_min, bui.terUniHea.fan.filter.f_cut);
 end if;
 if Modelica.Blocks.Types.Init.InitialOutput == Modelica.Blocks.Types.Init.InitialState then
  bui.terUniHea.fan.filter.x[1:2] = bui.terUniHea.fan.filter.x_start[1:2];
 elseif Modelica.Blocks.Types.Init.InitialOutput == Modelica.Blocks.Types.Init.SteadyState then
  der(bui.terUniHea.fan.filter.x[1:2]) = zeros(2);
 elseif Modelica.Blocks.Types.Init.InitialOutput == Modelica.Blocks.Types.Init.InitialOutput then
  bui.terUniHea.fan.filter.y = bui.terUniHea.fan.filter.y_start;
  if 2 > 1 then
   der(bui.terUniHea.fan.filter.x[1:2 - 1]) = zeros(2 - 1);
  end if;
 end if;
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.heaDis" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(2 > 1, "Must have at least two data points for pressure.V_flow.");
 assert(Buildings.Utilities.Math.Functions.isMonotonic({0.0, 27.54778848870753}, true) and 0.0 > -1.0E-15, "The fan pressure rise must be a strictly decreasing sequence with respect to the volume flow rate,
  with the first element for the fan pressure raise being non-zero.
The following performance data have been entered:
" + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.eff.getArrayAsString({0.0, 27.54778848870753}, "pressure.V_flow", 6, 6));
 if not true then
  assert(27.54778848870753 / -400.0 < 0, "The last two pressure points for the fan or pump performance curve must be decreasing.
    You need to set more reasonable parameters.
Received
" + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.eff.getArrayAsString({400.0, 0.0}, "dp", 6, 6));
 end if;
 if not true then
  Modelica.Utilities.Streams.print("
Warning:
========
It is recommended that the volume flow rate versus pressure relation
of the fan or pump satisfies the minimum decrease condition

        (per.pressure.dp[i+1]-per.pressure.dp[i])
d[i] = ------------------------------------------------- < " + String(-0.007260110918957602) + "
       (per.pressure.V_flow[i+1]-per.pressure.V_flow[i])

 is
" + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.eff.getArrayAsString({-400.0 / 27.54778848870753}, "d", 6, 6) + "
Otherwise, a solution to the equations may not exist if the fan or pump speed is reduced.
In this situation, the solver will fail due to non-convergence and
the simulation stops.", "");
 end if;
 if true and true or 2 == 2 then
  bui.terUniHea.fan.eff.preDer1[1:2] = Buildings.Utilities.Math.Functions.splineDerivatives({0.0, 27.54778848870753}, bui.terUniHea.fan.eff.pCur1.dp[1:2], Buildings.Utilities.Math.Functions.isMonotonic(bui.terUniHea.fan.eff.pCur1.dp[1:2], false));
  bui.terUniHea.fan.eff.preDer2[1:3] = zeros(2 + 1);
  bui.terUniHea.fan.eff.preDer3[1:4] = zeros(2 + 2);
 elseif true or true then
  bui.terUniHea.fan.eff.preDer1[1:2] = zeros(2);
  bui.terUniHea.fan.eff.preDer2[1:3] = Buildings.Utilities.Math.Functions.splineDerivatives(bui.terUniHea.fan.eff.pCur2.V_flow[1:3], bui.terUniHea.fan.eff.pCur2.dp[1:3], Buildings.Utilities.Math.Functions.isMonotonic(bui.terUniHea.fan.eff.pCur2.dp[1:3], false));
  bui.terUniHea.fan.eff.preDer3[1:4] = zeros(2 + 2);
 else
  bui.terUniHea.fan.eff.preDer1[1:2] = zeros(2);
  bui.terUniHea.fan.eff.preDer2[1:3] = zeros(2 + 1);
  bui.terUniHea.fan.eff.preDer3[1:4] = Buildings.Utilities.Math.Functions.splineDerivatives(bui.terUniHea.fan.eff.pCur3.V_flow[1:4], bui.terUniHea.fan.eff.pCur3.dp[1:4], Buildings.Utilities.Math.Functions.isMonotonic(bui.terUniHea.fan.eff.pCur3.dp[1:4], false));
 end if;
 bui.terUniHea.fan.eff.motDer[1:1] = if false then zeros(size(bui.terUniHea.fan.eff.per.motorEfficiency.V_flow[1:1], 1)) else {0};
 bui.terUniHea.fan.eff.hydDer[1:1] = if false then zeros(size(bui.terUniHea.fan.eff.per.hydraulicEfficiency.V_flow[1:1], 1)) else {0};
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.eff" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 bui.terUniHea.con.I.y = bui.terUniHea.con.I.y_start;
 assert(bui.terUniHea.con.lim.uMin < bui.terUniHea.con.lim.uMax, "uMin must be smaller than uMax. Check parameters.");
 bui.terUniHea.hex.hA.s_w = 1;
 assert(bui.terUniHea.hex.m1_flow_nominal > 0, "m1_flow_nominal must be positive, m1_flow_nominal = " + String(bui.terUniHea.hex.m1_flow_nominal));
 assert(16.528673093224516 > 0, "m2_flow_nominal must be positive, m2_flow_nominal = " + String(16.528673093224516));
 bui.terUniHea.hex.cp1_nominal = Buildings.Media.Water.specificHeatCapacityCp(bui.terUniHea.hex.sta1_default);
 bui.terUniHea.hex.cp2_nominal = Buildings.Media.Air.specificHeatCapacityCp(bui.terUniHea.hex.sta2_default);
 bui.terUniHea.hex.C1_flow_nominal = bui.terUniHea.hex.m1_flow_nominal * bui.terUniHea.hex.cp1_nominal;
 bui.terUniHea.hex.C2_flow_nominal = 16.528673093224516 * bui.terUniHea.hex.cp2_nominal;
 bui.terUniHea.hex.CMin_flow_nominal = min(bui.terUniHea.hex.C1_flow_nominal, bui.terUniHea.hex.C2_flow_nominal);
 bui.terUniHea.hex.CMax_flow_nominal = max(bui.terUniHea.hex.C1_flow_nominal, bui.terUniHea.hex.C2_flow_nominal);
 bui.terUniHea.hex.Z_nominal = bui.terUniHea.hex.CMin_flow_nominal / bui.terUniHea.hex.CMax_flow_nominal;
 167690.0 = bui.terUniHea.hex.m1_flow_nominal * bui.terUniHea.hex.cp1_nominal * (bui.terUniHea.hex.T_a1_nominal - bui.terUniHea.hex.T_b1_nominal);
 if true then
  167690.0 = -16.528673093224516 * bui.terUniHea.hex.cp2_nominal * (bui.terUniHea.hex.T_a2_nominal - bui.terUniHea.hex.T_b2_nominal);
  bui.terUniHea.hex.eps_nominal = abs(167690.0 / ((bui.terUniHea.hex.T_a1_nominal - bui.terUniHea.hex.T_a2_nominal) * bui.terUniHea.hex.CMin_flow_nominal));
 else
  bui.terUniHea.hex.T_a1_nominal = 293.15;
  bui.terUniHea.hex.T_a2_nominal = 293.15;
  bui.terUniHea.hex.T_b1_nominal = 293.15;
  bui.terUniHea.hex.T_b2_nominal = 293.15;
 end if;
 assert(bui.terUniHea.hex.eps_nominal > 0 and bui.terUniHea.hex.eps_nominal < 1, "eps_nominal out of bounds, eps_nominal = " + String(bui.terUniHea.hex.eps_nominal) + "\n  To achieve the required heat transfer rate at epsilon=0.8, set |T_a1_nominal-T_a2_nominal| = " + String(abs(167690.0 / 0.8 * bui.terUniHea.hex.CMin_flow_nominal)) + "\n  or increase flow rates. The current parameters result in " + "\n  CMin_flow_nominal = " + String(bui.terUniHea.hex.CMin_flow_nominal) + "\n  CMax_flow_nominal = " + String(bui.terUniHea.hex.CMax_flow_nominal));
 if Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1MixedStream2Unmixed then
  bui.terUniHea.hex.flowRegime_nominal = if bui.terUniHea.hex.C1_flow_nominal < bui.terUniHea.hex.C2_flow_nominal then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1UnmixedStream2Mixed then
  bui.terUniHea.hex.flowRegime_nominal = if bui.terUniHea.hex.C1_flow_nominal < bui.terUniHea.hex.C2_flow_nominal then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.ParallelFlow then
  bui.terUniHea.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow then
  bui.terUniHea.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowUnmixed then
  bui.terUniHea.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed;
 else
  bui.terUniHea.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed;
  assert(Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow >= Buildings.Fluid.Types.HeatExchangerConfiguration.ParallelFlow and Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow <= Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1UnmixedStream2Mixed, "Invalid heat exchanger configuration.");
 end if;
 bui.terUniHea.hex.NTU_nominal = if bui.terUniHea.hex.eps_nominal > 0 and bui.terUniHea.hex.eps_nominal < 1 then Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(bui.terUniHea.hex.eps_nominal, bui.terUniHea.hex.Z_nominal, Integer(bui.terUniHea.hex.flowRegime_nominal)) else 0;
 bui.terUniHea.hex.UA_nominal = bui.terUniHea.hex.NTU_nominal * bui.terUniHea.hex.CMin_flow_nominal;
 bui.terUniHea.hex.cp1_default = Buildings.Media.Water.specificHeatCapacityCp(Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0}));
 bui.terUniHea.hex.cp2_default = Buildings.Media.Air.specificHeatCapacityCp(Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01, 0.99}));
 bui.terUniHea.hex.CMin_flow_small = min(bui.terUniHea.hex.m1_flow_small * bui.terUniHea.hex.cp1_default, 0.0016528673093224517 * bui.terUniHea.hex.cp2_default);
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal1" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(0 == 0 or abs(sum(fill(0.0, 0)) - 1) < 1.0E-5, "If Medium.nXi > 1, then substance 'water' must be present for one component.'" + "SimpleLiquidWater" + "'.\n" + "Check medium model.");
 if false then
  assert(bui.terUniHea.hex.bal1.preDro.m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
 end if;
 assert(bui.terUniHea.hex.bal1.preDro.m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal1.preDro" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal2" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(1 == 0 or abs(sum({1.0}) - 1) < 1.0E-5, "If Medium.nXi > 1, then substance 'water' must be present for one component.'" + "Air" + "'.\n" + "Check medium model.");
 if true then
  assert(1.6528673093224517 > 0, "m_flow_turbulent must be bigger than zero.");
 end if;
 assert(16.528673093224516 > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal2.preDro" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 if not false then
  if false then
   assert(bui.terUniHea.sinAir.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.sinAir" + ": The parameter value p=" + String(bui.terUniHea.sinAir.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if true then
   assert(bui.terUniHea.sinAir.p_in_internal > 50000.0 and bui.terUniHea.sinAir.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.sinAir" + ": The parameter value p=" + String(bui.terUniHea.sinAir.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("Air", {"water", "air"}, false, true, bui.terUniHea.sinAir.X_in_internal[1:2], "Boundary_pT");
 end if;
 assert(cardinality(bui.terUniHea.sinAir.ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 if not false then
  if false then
   assert(bui.terUniHea.retAir.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.retAir" + ": The parameter value p=" + String(bui.terUniHea.retAir.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if true then
   assert(bui.terUniHea.retAir.p_in_internal > 50000.0 and bui.terUniHea.retAir.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.retAir" + ": The parameter value p=" + String(bui.terUniHea.retAir.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("Air", {"water", "air"}, false, true, bui.terUniHea.retAir.X_in_internal[1:2], "Boundary_pT");
 end if;
 assert(cardinality(bui.terUniHea.retAir.ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 if false then
  der(bui.terUniHea.TLoaODE.TAir) = 0;
 else
  bui.terUniHea.TLoaODE.TAir = bui.terUniHea.TLoaODE.TIndHea_nominal;
 end if;
 assert(bui.terUniHea.scaHeaWatFloInl.k > 1.0E-60 or - bui.terUniHea.scaHeaWatFloInl.k < -1.0E-60, "Gain must not be zero. Received k = " + String(bui.terUniHea.scaHeaWatFloInl.k));
 assert(bui.terUniHea.scaHeaWatFloOut.k > 1.0E-60 or - bui.terUniHea.scaHeaWatFloOut.k < -1.0E-60, "Gain must not be zero. Received k = " + String(bui.terUniHea.scaHeaWatFloOut.k));
 assert(1 == 1, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea" + ": The numbers of terminal units return ports (" + String(1) + ") and supply ports (" + String(1) + ") must be equal.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea" + ": The configuration where have_val is true and have_pum is false is not allowed.");
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, bui.disFloHea.sou_m_flow[1].X_in_internal[1:1], "Boundary_pT");
 end if;
 assert(cardinality(bui.disFloHea.sou_m_flow[1].ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 if not false then
  if true then
   assert(bui.disFloHea.sin.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.sin" + ": The parameter value p=" + String(bui.disFloHea.sin.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if false then
   assert(bui.disFloHea.sin.p_in_internal > 50000.0 and bui.disFloHea.sin.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.sin" + ": The parameter value p=" + String(bui.disFloHea.sin.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, bui.disFloHea.sin.X_in_internal[1:1], "Boundary_pT");
 end if;
 assert(cardinality(bui.disFloHea.sin.ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 algorithm
  assert(Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState or bui.disFloHea.heaCoo.tau > 1.0E-15, "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = " + String(bui.disFloHea.heaCoo.tau) + "\n");
  assert(Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState or bui.disFloHea.heaCoo.tau > 1.0E-15, "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = " + String(bui.disFloHea.heaCoo.tau) + "\n");
  assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
;
 assert(0 == 0 or abs(sum(fill(0.0, 0)) - 1) < 1.0E-5, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol.dynBal" + ":
         If Medium.nXi > 1, then substance 'water' must be present for one component of '" + "SimpleLiquidWater" + "'.
         Check medium model.");
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  assert(Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol.dynBal" + ":
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.disFloHea.heaCoo.vol.dynBal.medium.T = bui.disFloHea.heaCoo.vol.dynBal.T_start;
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.disFloHea.heaCoo.vol.dynBal.medium.T) = 0;
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  if false then
   bui.disFloHea.heaCoo.vol.dynBal.medium.p = bui.disFloHea.heaCoo.vol.dynBal.p_start;
  end if;
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   if false then
    der(bui.disFloHea.heaCoo.vol.dynBal.medium.p) = 0;
   end if;
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.disFloHea.heaCoo.vol.dynBal.medium.Xi[1:0] = bui.disFloHea.heaCoo.vol.dynBal.X_start[1:0];
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.disFloHea.heaCoo.vol.dynBal.medium.Xi[1:0]) = zeros(0);
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.disFloHea.heaCoo.vol.dynBal.C[1:0] = bui.disFloHea.heaCoo.vol.dynBal.C_start[1:0];
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.disFloHea.heaCoo.vol.dynBal.C[1:0]) = zeros(0);
  end if;
 end if;
 if false then
  assert(0.0 > 0, "m_flow_turbulent must be bigger than zero.");
 end if;
 assert(8.015774378585085 > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.preDro" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(1 == 1, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo" + ": The numbers of terminal units return ports (" + String(1) + ") and supply ports (" + String(1) + ") must be equal.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo" + ": The configuration where have_val is true and have_pum is false is not allowed.");
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, bui.disFloCoo.sou_m_flow[1].X_in_internal[1:1], "Boundary_pT");
 end if;
 assert(cardinality(bui.disFloCoo.sou_m_flow[1].ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 if not false then
  if true then
   assert(bui.disFloCoo.sin.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.sin" + ": The parameter value p=" + String(bui.disFloCoo.sin.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if false then
   assert(bui.disFloCoo.sin.p_in_internal > 50000.0 and bui.disFloCoo.sin.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.sin" + ": The parameter value p=" + String(bui.disFloCoo.sin.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, bui.disFloCoo.sin.X_in_internal[1:1], "Boundary_pT");
 end if;
 assert(cardinality(bui.disFloCoo.sin.ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 algorithm
  assert(Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState or bui.disFloCoo.heaCoo.tau > 1.0E-15, "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = " + String(bui.disFloCoo.heaCoo.tau) + "\n");
  assert(Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState or bui.disFloCoo.heaCoo.tau > 1.0E-15, "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = " + String(bui.disFloCoo.heaCoo.tau) + "\n");
  assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
;
 assert(0 == 0 or abs(sum(fill(0.0, 0)) - 1) < 1.0E-5, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol.dynBal" + ":
         If Medium.nXi > 1, then substance 'water' must be present for one component of '" + "SimpleLiquidWater" + "'.
         Check medium model.");
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  assert(Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol.dynBal" + ":
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.disFloCoo.heaCoo.vol.dynBal.medium.T = bui.disFloCoo.heaCoo.vol.dynBal.T_start;
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.disFloCoo.heaCoo.vol.dynBal.medium.T) = 0;
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  if false then
   bui.disFloCoo.heaCoo.vol.dynBal.medium.p = bui.disFloCoo.heaCoo.vol.dynBal.p_start;
  end if;
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   if false then
    der(bui.disFloCoo.heaCoo.vol.dynBal.medium.p) = 0;
   end if;
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.disFloCoo.heaCoo.vol.dynBal.medium.Xi[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.X_start[1:0];
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.disFloCoo.heaCoo.vol.dynBal.medium.Xi[1:0]) = zeros(0);
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.disFloCoo.heaCoo.vol.dynBal.C[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.C_start[1:0];
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.disFloCoo.heaCoo.vol.dynBal.C[1:0]) = zeros(0);
  end if;
 end if;
 if false then
  assert(0.0 > 0, "m_flow_turbulent must be bigger than zero.");
 end if;
 assert(7.024856596558317 > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.preDro" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 bui.terUniCoo.con.I.y = bui.terUniCoo.con.I.y_start;
 assert(bui.terUniCoo.con.lim.uMin < bui.terUniCoo.con.lim.uMax, "uMin must be smaller than uMax. Check parameters.");
 assert(14.485382537898948 >= 1.0E-60, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan" + ": The value of parameter m_flow_nominal should be greater or equal than " + String(1.0E-60) + " but it equals " + String(14.485382537898948));
 assert(bui.terUniCoo.fan.nominalValuesDefineDefaultPressureCurve or false or Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed, "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve.
             This leads to approximate calculations of the electrical power
             consumption. Add the correct pressure curve in the record per
             to obtain an accurate computation.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.", AssertionLevel.warning);
 assert(bui.terUniCoo.fan.nominalValuesDefineDefaultPressureCurve or (false or Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed) or false == false, "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve and you set use_powerCharacteristic = true.
             Since this can cause wrong power consumption, the model will overwrite
             this setting and use instead use_powerCharacteristic = false." + "Since this causes the efficiency curve to be used,
             make sure that the efficiency curves in the performance record per
             are correct or add the pressure curve of the mover.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.", AssertionLevel.warning);
 assert(1 == 0 or abs(sum({1.0}) - 1) < 1.0E-5, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol.dynBal" + ":
         If Medium.nXi > 1, then substance 'water' must be present for one component of '" + "Air" + "'.
         Check medium model.");
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  assert(Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol.dynBal" + ":
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.terUniCoo.fan.vol.dynBal.medium.T = bui.terUniCoo.fan.vol.dynBal.T_start;
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.terUniCoo.fan.vol.dynBal.medium.T) = 0;
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  if true then
   bui.terUniCoo.fan.vol.dynBal.medium.p = bui.terUniCoo.fan.vol.dynBal.p_start;
  end if;
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   if true then
    der(bui.terUniCoo.fan.vol.dynBal.medium.p) = 0;
   end if;
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.terUniCoo.fan.vol.dynBal.medium.Xi[1:1] = bui.terUniCoo.fan.vol.dynBal.X_start[1:1];
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.terUniCoo.fan.vol.dynBal.medium.Xi[1:1]) = zeros(1);
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  bui.terUniCoo.fan.vol.dynBal.C[1:0] = bui.terUniCoo.fan.vol.dynBal.C_start[1:0];
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(bui.terUniCoo.fan.vol.dynBal.C[1:0]) = zeros(0);
  end if;
 end if;
 if Modelica.Blocks.Types.AnalogFilter.CriticalDamping == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
  bui.terUniCoo.fan.filter.cr[1:2] = Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, bui.terUniCoo.fan.filter.normalized);
 elseif Modelica.Blocks.Types.AnalogFilter.CriticalDamping == Modelica.Blocks.Types.AnalogFilter.Bessel then
  (bui.terUniCoo.fan.filter.cr[1:2], bui.terUniCoo.fan.filter.c0[1:0], bui.terUniCoo.fan.filter.c1[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.base.Bessel(2, bui.terUniCoo.fan.filter.normalized);
 elseif Modelica.Blocks.Types.AnalogFilter.CriticalDamping == Modelica.Blocks.Types.AnalogFilter.Butterworth then
  (bui.terUniCoo.fan.filter.cr[1:2], bui.terUniCoo.fan.filter.c0[1:0], bui.terUniCoo.fan.filter.c1[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.base.Butterworth(2, bui.terUniCoo.fan.filter.normalized);
 elseif Modelica.Blocks.Types.AnalogFilter.CriticalDamping == Modelica.Blocks.Types.AnalogFilter.ChebyshevI then
  (bui.terUniCoo.fan.filter.cr[1:2], bui.terUniCoo.fan.filter.c0[1:0], bui.terUniCoo.fan.filter.c1[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.base.ChebyshevI(2, bui.terUniCoo.fan.filter.A_ripple, bui.terUniCoo.fan.filter.normalized);
 end if;
 if Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.LowPass then
  (bui.terUniCoo.fan.filter.r[1:2], bui.terUniCoo.fan.filter.a[1:0], bui.terUniCoo.fan.filter.b[1:0], bui.terUniCoo.fan.filter.ku[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(bui.terUniCoo.fan.filter.cr[1:2], bui.terUniCoo.fan.filter.c0[1:0], bui.terUniCoo.fan.filter.c1[1:0], bui.terUniCoo.fan.filter.f_cut);
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.HighPass then
  (bui.terUniCoo.fan.filter.r[1:2], bui.terUniCoo.fan.filter.a[1:0], bui.terUniCoo.fan.filter.b[1:0], bui.terUniCoo.fan.filter.ku[1:0], bui.terUniCoo.fan.filter.k1[1:0], bui.terUniCoo.fan.filter.k2[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.roots.highPass(bui.terUniCoo.fan.filter.cr[1:2], bui.terUniCoo.fan.filter.c0[1:0], bui.terUniCoo.fan.filter.c1[1:0], bui.terUniCoo.fan.filter.f_cut);
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.BandPass then
  (bui.terUniCoo.fan.filter.a[1:0], bui.terUniCoo.fan.filter.b[1:0], bui.terUniCoo.fan.filter.ku[1:0], bui.terUniCoo.fan.filter.k1[1:0], bui.terUniCoo.fan.filter.k2[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.roots.bandPass(bui.terUniCoo.fan.filter.cr[1:2], bui.terUniCoo.fan.filter.c0[1:0], bui.terUniCoo.fan.filter.c1[1:0], bui.terUniCoo.fan.filter.f_min, bui.terUniCoo.fan.filter.f_cut);
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.BandStop then
  (bui.terUniCoo.fan.filter.a[1:0], bui.terUniCoo.fan.filter.b[1:0], bui.terUniCoo.fan.filter.ku[1:0], bui.terUniCoo.fan.filter.k1[1:0], bui.terUniCoo.fan.filter.k2[1:0]) = Modelica.Blocks.Continuous.Internal.Filter.roots.bandStop(bui.terUniCoo.fan.filter.cr[1:2], bui.terUniCoo.fan.filter.c0[1:0], bui.terUniCoo.fan.filter.c1[1:0], bui.terUniCoo.fan.filter.f_min, bui.terUniCoo.fan.filter.f_cut);
 end if;
 if Modelica.Blocks.Types.Init.InitialOutput == Modelica.Blocks.Types.Init.InitialState then
  bui.terUniCoo.fan.filter.x[1:2] = bui.terUniCoo.fan.filter.x_start[1:2];
 elseif Modelica.Blocks.Types.Init.InitialOutput == Modelica.Blocks.Types.Init.SteadyState then
  der(bui.terUniCoo.fan.filter.x[1:2]) = zeros(2);
 elseif Modelica.Blocks.Types.Init.InitialOutput == Modelica.Blocks.Types.Init.InitialOutput then
  bui.terUniCoo.fan.filter.y = bui.terUniCoo.fan.filter.y_start;
  if 2 > 1 then
   der(bui.terUniCoo.fan.filter.x[1:2 - 1]) = zeros(2 - 1);
  end if;
 end if;
 assert(2 > 1, "Must have at least two data points for pressure.V_flow.");
 assert(Buildings.Utilities.Math.Functions.isMonotonic({0.0, 24.14230422983158}, true) and 0.0 > -1.0E-15, "The fan pressure rise must be a strictly decreasing sequence with respect to the volume flow rate,
  with the first element for the fan pressure raise being non-zero.
The following performance data have been entered:
" + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.eff.getArrayAsString({0.0, 24.14230422983158}, "pressure.V_flow", 6, 6));
 if not true then
  assert(24.14230422983158 / -400.0 < 0, "The last two pressure points for the fan or pump performance curve must be decreasing.
    You need to set more reasonable parameters.
Received
" + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.eff.getArrayAsString({400.0, 0.0}, "dp", 6, 6));
 end if;
 if not true then
  Modelica.Utilities.Streams.print("
Warning:
========
It is recommended that the volume flow rate versus pressure relation
of the fan or pump satisfies the minimum decrease condition

        (per.pressure.dp[i+1]-per.pressure.dp[i])
d[i] = ------------------------------------------------- < " + String(-0.008284213391399023) + "
       (per.pressure.V_flow[i+1]-per.pressure.V_flow[i])

 is
" + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.eff.getArrayAsString({-400.0 / 24.14230422983158}, "d", 6, 6) + "
Otherwise, a solution to the equations may not exist if the fan or pump speed is reduced.
In this situation, the solver will fail due to non-convergence and
the simulation stops.", "");
 end if;
 if true and true or 2 == 2 then
  bui.terUniCoo.fan.eff.preDer1[1:2] = Buildings.Utilities.Math.Functions.splineDerivatives({0.0, 24.14230422983158}, bui.terUniCoo.fan.eff.pCur1.dp[1:2], Buildings.Utilities.Math.Functions.isMonotonic(bui.terUniCoo.fan.eff.pCur1.dp[1:2], false));
  bui.terUniCoo.fan.eff.preDer2[1:3] = zeros(2 + 1);
  bui.terUniCoo.fan.eff.preDer3[1:4] = zeros(2 + 2);
 elseif true or true then
  bui.terUniCoo.fan.eff.preDer1[1:2] = zeros(2);
  bui.terUniCoo.fan.eff.preDer2[1:3] = Buildings.Utilities.Math.Functions.splineDerivatives(bui.terUniCoo.fan.eff.pCur2.V_flow[1:3], bui.terUniCoo.fan.eff.pCur2.dp[1:3], Buildings.Utilities.Math.Functions.isMonotonic(bui.terUniCoo.fan.eff.pCur2.dp[1:3], false));
  bui.terUniCoo.fan.eff.preDer3[1:4] = zeros(2 + 2);
 else
  bui.terUniCoo.fan.eff.preDer1[1:2] = zeros(2);
  bui.terUniCoo.fan.eff.preDer2[1:3] = zeros(2 + 1);
  bui.terUniCoo.fan.eff.preDer3[1:4] = Buildings.Utilities.Math.Functions.splineDerivatives(bui.terUniCoo.fan.eff.pCur3.V_flow[1:4], bui.terUniCoo.fan.eff.pCur3.dp[1:4], Buildings.Utilities.Math.Functions.isMonotonic(bui.terUniCoo.fan.eff.pCur3.dp[1:4], false));
 end if;
 bui.terUniCoo.fan.eff.motDer[1:1] = if false then zeros(size(bui.terUniCoo.fan.eff.per.motorEfficiency.V_flow[1:1], 1)) else {0};
 bui.terUniCoo.fan.eff.hydDer[1:1] = if false then zeros(size(bui.terUniCoo.fan.eff.per.hydraulicEfficiency.V_flow[1:1], 1)) else {0};
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.eff" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 bui.terUniCoo.hex.hA.s_w = 1;
 assert(bui.terUniCoo.hex.m1_flow_nominal > 0, "m1_flow_nominal must be positive, m1_flow_nominal = " + String(bui.terUniCoo.hex.m1_flow_nominal));
 assert(14.485382537898948 > 0, "m2_flow_nominal must be positive, m2_flow_nominal = " + String(14.485382537898948));
 bui.terUniCoo.hex.cp1_nominal = Buildings.Media.Water.specificHeatCapacityCp(bui.terUniCoo.hex.sta1_default);
 bui.terUniCoo.hex.cp2_nominal = Buildings.Media.Air.specificHeatCapacityCp(bui.terUniCoo.hex.sta2_default);
 bui.terUniCoo.hex.C1_flow_nominal = bui.terUniCoo.hex.m1_flow_nominal * bui.terUniCoo.hex.cp1_nominal;
 bui.terUniCoo.hex.C2_flow_nominal = 14.485382537898948 * bui.terUniCoo.hex.cp2_nominal;
 bui.terUniCoo.hex.CMin_flow_nominal = min(bui.terUniCoo.hex.C1_flow_nominal, bui.terUniCoo.hex.C2_flow_nominal);
 bui.terUniCoo.hex.CMax_flow_nominal = max(bui.terUniCoo.hex.C1_flow_nominal, bui.terUniCoo.hex.C2_flow_nominal);
 bui.terUniCoo.hex.Z_nominal = bui.terUniCoo.hex.CMin_flow_nominal / bui.terUniCoo.hex.CMax_flow_nominal;
 -146960.0 = bui.terUniCoo.hex.m1_flow_nominal * bui.terUniCoo.hex.cp1_nominal * (bui.terUniCoo.hex.T_a1_nominal - bui.terUniCoo.hex.T_b1_nominal);
 if true then
  -146960.0 = -14.485382537898948 * bui.terUniCoo.hex.cp2_nominal * (bui.terUniCoo.hex.T_a2_nominal - bui.terUniCoo.hex.T_b2_nominal);
  bui.terUniCoo.hex.eps_nominal = abs(-146960.0 / ((bui.terUniCoo.hex.T_a1_nominal - bui.terUniCoo.hex.T_a2_nominal) * bui.terUniCoo.hex.CMin_flow_nominal));
 else
  bui.terUniCoo.hex.T_a1_nominal = 293.15;
  bui.terUniCoo.hex.T_a2_nominal = 293.15;
  bui.terUniCoo.hex.T_b1_nominal = 293.15;
  bui.terUniCoo.hex.T_b2_nominal = 293.15;
 end if;
 assert(bui.terUniCoo.hex.eps_nominal > 0 and bui.terUniCoo.hex.eps_nominal < 1, "eps_nominal out of bounds, eps_nominal = " + String(bui.terUniCoo.hex.eps_nominal) + "\n  To achieve the required heat transfer rate at epsilon=0.8, set |T_a1_nominal-T_a2_nominal| = " + String(abs(-146960.0 / 0.8 * bui.terUniCoo.hex.CMin_flow_nominal)) + "\n  or increase flow rates. The current parameters result in " + "\n  CMin_flow_nominal = " + String(bui.terUniCoo.hex.CMin_flow_nominal) + "\n  CMax_flow_nominal = " + String(bui.terUniCoo.hex.CMax_flow_nominal));
 if Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1MixedStream2Unmixed then
  bui.terUniCoo.hex.flowRegime_nominal = if bui.terUniCoo.hex.C1_flow_nominal < bui.terUniCoo.hex.C2_flow_nominal then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1UnmixedStream2Mixed then
  bui.terUniCoo.hex.flowRegime_nominal = if bui.terUniCoo.hex.C1_flow_nominal < bui.terUniCoo.hex.C2_flow_nominal then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.ParallelFlow then
  bui.terUniCoo.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow then
  bui.terUniCoo.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowUnmixed then
  bui.terUniCoo.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed;
 else
  bui.terUniCoo.hex.flowRegime_nominal = Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed;
  assert(Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow >= Buildings.Fluid.Types.HeatExchangerConfiguration.ParallelFlow and Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow <= Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1UnmixedStream2Mixed, "Invalid heat exchanger configuration.");
 end if;
 bui.terUniCoo.hex.NTU_nominal = if bui.terUniCoo.hex.eps_nominal > 0 and bui.terUniCoo.hex.eps_nominal < 1 then Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(bui.terUniCoo.hex.eps_nominal, bui.terUniCoo.hex.Z_nominal, Integer(bui.terUniCoo.hex.flowRegime_nominal)) else 0;
 bui.terUniCoo.hex.UA_nominal = bui.terUniCoo.hex.NTU_nominal * bui.terUniCoo.hex.CMin_flow_nominal;
 bui.terUniCoo.hex.cp1_default = Buildings.Media.Water.specificHeatCapacityCp(Buildings.Media.Water.setState_pTX(300000.0, 293.15, {1.0}));
 bui.terUniCoo.hex.cp2_default = Buildings.Media.Air.specificHeatCapacityCp(Buildings.Media.Air.setState_pTX(101325.0, 293.15, {0.01, 0.99}));
 bui.terUniCoo.hex.CMin_flow_small = min(bui.terUniCoo.hex.m1_flow_small * bui.terUniCoo.hex.cp1_default, 0.0014485382537898948 * bui.terUniCoo.hex.cp2_default);
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal1" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(0 == 0 or abs(sum(fill(0.0, 0)) - 1) < 1.0E-5, "If Medium.nXi > 1, then substance 'water' must be present for one component.'" + "SimpleLiquidWater" + "'.\n" + "Check medium model.");
 if false then
  assert(bui.terUniCoo.hex.bal1.preDro.m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
 end if;
 assert(bui.terUniCoo.hex.bal1.preDro.m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal1.preDro" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal2" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(1 == 0 or abs(sum({1.0}) - 1) < 1.0E-5, "If Medium.nXi > 1, then substance 'water' must be present for one component.'" + "Air" + "'.\n" + "Check medium model.");
 if true then
  assert(1.448538253789895 > 0, "m_flow_turbulent must be bigger than zero.");
 end if;
 assert(14.485382537898948 > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal2.preDro" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 if not false then
  if false then
   assert(bui.terUniCoo.sinAir.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.sinAir" + ": The parameter value p=" + String(bui.terUniCoo.sinAir.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if true then
   assert(bui.terUniCoo.sinAir.p_in_internal > 50000.0 and bui.terUniCoo.sinAir.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.sinAir" + ": The parameter value p=" + String(bui.terUniCoo.sinAir.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("Air", {"water", "air"}, false, true, bui.terUniCoo.sinAir.X_in_internal[1:2], "Boundary_pT");
 end if;
 assert(cardinality(bui.terUniCoo.sinAir.ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 if not false then
  if false then
   assert(bui.terUniCoo.retAir.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.retAir" + ": The parameter value p=" + String(bui.terUniCoo.retAir.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if true then
   assert(bui.terUniCoo.retAir.p_in_internal > 50000.0 and bui.terUniCoo.retAir.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.retAir" + ": The parameter value p=" + String(bui.terUniCoo.retAir.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("Air", {"water", "air"}, false, true, bui.terUniCoo.retAir.X_in_internal[1:2], "Boundary_pT");
 end if;
 assert(cardinality(bui.terUniCoo.retAir.ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 if false then
  der(bui.terUniCoo.TLoaODE.TAir) = 0;
 else
  bui.terUniCoo.TLoaODE.TAir = bui.terUniCoo.TLoaODE.TIndHea_nominal;
 end if;
 assert(bui.terUniCoo.scaChiWatFloInl.k > 1.0E-60 or - bui.terUniCoo.scaChiWatFloInl.k < -1.0E-60, "Gain must not be zero. Received k = " + String(bui.terUniCoo.scaChiWatFloInl.k));
 assert(bui.terUniCoo.scaChiWatFloOut.k > 1.0E-60 or - bui.terUniCoo.scaChiWatFloOut.k < -1.0E-60, "Gain must not be zero. Received k = " + String(bui.terUniCoo.scaChiWatFloOut.k));
 assert(1 == 1, "In " + "CouplingETS_TimeSeriesBuilding.bui" + ": The numbers of secondary heating source side inlet ports (" + String(1) + ") and outlet ports (" + String(1) + ") must be equal.");
 assert(1 == 1, "In " + "CouplingETS_TimeSeriesBuilding.bui" + ": The numbers of secondary cooling source side inlet ports (" + String(1) + ") and outlet ports (" + String(1) + ") must be equal.");
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, supChiWat.X_in_internal[1:1], "Boundary_pT");
 end if;
 assert(cardinality(supChiWat.ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, supHeaWat.X_in_internal[1:1], "Boundary_pT");
 end if;
 assert(cardinality(supHeaWat.ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 if not false then
  if true then
   assert(sinChiWat.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.sinChiWat" + ": The parameter value p=" + String(sinChiWat.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if false then
   assert(sinChiWat.p_in_internal > 50000.0 and sinChiWat.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.sinChiWat" + ": The parameter value p=" + String(sinChiWat.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, sinChiWat.X_in_internal[1:1], "Boundary_pT");
 end if;
 assert(cardinality(sinChiWat.ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 if not false then
  if true then
   assert(sinHeaWat.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.sinHeaWat" + ": The parameter value p=" + String(sinHeaWat.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if false then
   assert(sinHeaWat.p_in_internal > 50000.0 and sinHeaWat.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.sinHeaWat" + ": The parameter value p=" + String(sinHeaWat.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 assert(not false or not false, "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
 if not false and not false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, sinHeaWat.X_in_internal[1:1], "Boundary_pT");
 end if;
 assert(cardinality(sinHeaWat.ports[1]) <= 1, "
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 assert(7.024856596558317 >= 1.0E-60, "In " + "CouplingETS_TimeSeriesBuilding.pumBui" + ": The value of parameter m_flow_nominal should be greater or equal than " + String(1.0E-60) + " but it equals " + String(7.024856596558317));
 assert(pumBui.nominalValuesDefineDefaultPressureCurve or false or Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed, "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve.
             This leads to approximate calculations of the electrical power
             consumption. Add the correct pressure curve in the record per
             to obtain an accurate computation.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.", AssertionLevel.warning);
 assert(pumBui.nominalValuesDefineDefaultPressureCurve or (false or Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate == Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed) or false == false, "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve and you set use_powerCharacteristic = true.
             Since this can cause wrong power consumption, the model will overwrite
             this setting and use instead use_powerCharacteristic = false." + "Since this causes the efficiency curve to be used,
             make sure that the efficiency curves in the performance record per
             are correct or add the pressure curve of the mover.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.", AssertionLevel.warning);
 assert(0 == 0 or abs(sum(fill(0.0, 0)) - 1) < 1.0E-5, "In " + "CouplingETS_TimeSeriesBuilding.pumBui.vol.dynBal" + ":
         If Medium.nXi > 1, then substance 'water' must be present for one component of '" + "SimpleLiquidWater" + "'.
         Check medium model.");
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  assert(Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial, "In " + "CouplingETS_TimeSeriesBuilding.pumBui.vol.dynBal" + ":
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  pumBui.vol.dynBal.medium.T = pumBui.vol.dynBal.T_start;
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(pumBui.vol.dynBal.medium.T) = 0;
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  if false then
   pumBui.vol.dynBal.medium.p = pumBui.vol.dynBal.p_start;
  end if;
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   if false then
    der(pumBui.vol.dynBal.medium.p) = 0;
   end if;
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  pumBui.vol.dynBal.medium.Xi[1:0] = pumBui.vol.dynBal.X_start[1:0];
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(pumBui.vol.dynBal.medium.Xi[1:0]) = zeros(0);
  end if;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.FixedInitial then
  pumBui.vol.dynBal.C[1:0] = pumBui.vol.dynBal.C_start[1:0];
 else
  if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
   der(pumBui.vol.dynBal.C[1:0]) = zeros(0);
  end if;
 end if;
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.pumBui.heaDis" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
 assert(2 > 1, "Must have at least two data points for pressure.V_flow.");
 assert(Buildings.Utilities.Math.Functions.isMonotonic({0.0, 0.014112003576905093}, true) and 0.0 > -1.0E-15, "The fan pressure rise must be a strictly decreasing sequence with respect to the volume flow rate,
  with the first element for the fan pressure raise being non-zero.
The following performance data have been entered:
" + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.eff.getArrayAsString({0.0, 0.014112003576905093}, "pressure.V_flow", 6, 6));
 if not true then
  assert(0.014112003576905093 / -300000.0 < 0, "The last two pressure points for the fan or pump performance curve must be decreasing.
    You need to set more reasonable parameters.
Received
" + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.eff.getArrayAsString({300000.0, 0.0}, "dp", 6, 6));
 end if;
 if not true then
  Modelica.Utilities.Streams.print("
Warning:
========
It is recommended that the volume flow rate versus pressure relation
of the fan or pump satisfies the minimum decrease condition

        (per.pressure.dp[i+1]-per.pressure.dp[i])
d[i] = ------------------------------------------------- < " + String(-10629.249006532391) + "
       (per.pressure.V_flow[i+1]-per.pressure.V_flow[i])

 is
" + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.eff.getArrayAsString({-300000.0 / 0.014112003576905093}, "d", 6, 6) + "
Otherwise, a solution to the equations may not exist if the fan or pump speed is reduced.
In this situation, the solver will fail due to non-convergence and
the simulation stops.", "");
 end if;
 if true and true or 2 == 2 then
  pumBui.eff.preDer1[1:2] = Buildings.Utilities.Math.Functions.splineDerivatives({0.0, 0.014112003576905093}, pumBui.eff.pCur1.dp[1:2], Buildings.Utilities.Math.Functions.isMonotonic(pumBui.eff.pCur1.dp[1:2], false));
  pumBui.eff.preDer2[1:3] = zeros(2 + 1);
  pumBui.eff.preDer3[1:4] = zeros(2 + 2);
 elseif true or true then
  pumBui.eff.preDer1[1:2] = zeros(2);
  pumBui.eff.preDer2[1:3] = Buildings.Utilities.Math.Functions.splineDerivatives({0.0, 0.0, 0.0}, pumBui.eff.pCur2.dp[1:3], Buildings.Utilities.Math.Functions.isMonotonic(pumBui.eff.pCur2.dp[1:3], false));
  pumBui.eff.preDer3[1:4] = zeros(2 + 2);
 else
  pumBui.eff.preDer1[1:2] = zeros(2);
  pumBui.eff.preDer2[1:3] = zeros(2 + 1);
  pumBui.eff.preDer3[1:4] = Buildings.Utilities.Math.Functions.splineDerivatives({0.0, 0.0, 0.0, 0.0}, pumBui.eff.pCur3.dp[1:4], Buildings.Utilities.Math.Functions.isMonotonic(pumBui.eff.pCur3.dp[1:4], false));
 end if;
 pumBui.eff.motDer[1:1] = if false then zeros(size(pumBui.eff.per.motorEfficiency.V_flow[1:1], 1)) else {0};
 pumBui.eff.hydDer[1:1] = if false then zeros(size(pumBui.eff.per.hydraulicEfficiency.V_flow[1:1], 1)) else {0};
 assert(true, "In " + "CouplingETS_TimeSeriesBuilding.pumBui.eff" + ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.", AssertionLevel.warning);
equation
 coo.hex.hA1 = coo.hex.hA1_nominal * Buildings.Utilities.Math.Functions.regNonZeroPower(coo.hex.m1_flow / coo.hex.m1_flow_nominal, coo.hex.n1, 0.1);
 coo.hex.hA2 = coo.hex.hA2_nominal * Buildings.Utilities.Math.Functions.regNonZeroPower(coo.hex.m2_flow / 7.024856596558317, coo.hex.n2, 0.1);
 if Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.ParallelFlow then
  coo.hex.flowRegime = if coo.hex.C1_flow * coo.hex.C2_flow >= 0 then Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow else Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow then
  coo.hex.flowRegime = if coo.hex.C1_flow * coo.hex.C2_flow >= 0 then Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow else Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowUnmixed then
  coo.hex.flowRegime = Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1MixedStream2Unmixed then
  coo.hex.flowRegime = if coo.hex.C1_flow < coo.hex.C2_flow then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed;
 else
  coo.hex.flowRegime = if coo.hex.C1_flow < coo.hex.C2_flow then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed;
 end if;
 coo.hex.eps = Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C(coo.hex.UA, coo.hex.C1_flow, coo.hex.C2_flow, Integer(coo.hex.flowRegime), coo.hex.CMin_flow_nominal, coo.hex.CMax_flow_nominal, coo.hex.delta);
 if not false then
  coo.hex.bal1.vol.mWat_flow_internal = 0;
 end if;
 if not false then
  coo.hex.bal1.vol.C_flow_internal[1:0] = zeros(0);
 end if;
 coo.hex.bal1.vol.mXi_flow[1:0] = coo.hex.bal1.vol.mWat_flow_internal * fill(0.0, 0);
 if true then
  coo.hex.bal1.vol.m_flowInv = Buildings.Utilities.Math.Functions.inverseXRegularized(coo.hex.bal1.vol.port_a.m_flow, coo.hex.bal1.vol.deltaReg, coo.hex.bal1.vol.deltaInvReg, coo.hex.bal1.vol.aReg, coo.hex.bal1.vol.bReg, coo.hex.bal1.vol.cReg, coo.hex.bal1.vol.dReg, coo.hex.bal1.vol.eReg, coo.hex.bal1.vol.fReg);
 else
  coo.hex.bal1.vol.m_flowInv = 0;
 end if;
 if true then
  assert(noEvent(abs(coo.hex.bal1.vol.Q_flow) < 200.0 * coo.hex.bal1.vol.cp_default * max(coo.hex.bal1.vol.m_flow_small / 1000.0, abs(coo.hex.bal1.vol.m_flow))), "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal1.vol" + ":
   The heat flow rate equals " + String(coo.hex.bal1.vol.Q_flow) + " W and the mass flow rate equals " + String(coo.hex.bal1.vol.m_flow) + " kg/s,
   which results in a temperature difference " + String(abs(coo.hex.bal1.vol.Q_flow) / (coo.hex.bal1.vol.cp_default * max(coo.hex.bal1.vol.m_flow_small / 1000.0, abs(coo.hex.bal1.vol.m_flow)))) + " K > dTMax=" + String(200.0) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
 end if;
 if true then
  coo.hex.bal1.vol.hOut = Buildings.Utilities.Math.Functions.regStep(coo.hex.bal1.vol.port_a.m_flow, coo.hex.bal1.vol.port_b.h_outflow, coo.hex.bal1.vol.port_a.h_outflow, coo.hex.bal1.vol.m_flow_small / 1000.0);
  coo.hex.bal1.vol.XiOut[1:0] = Buildings.Utilities.Math.Functions.regStep(coo.hex.bal1.vol.port_a.m_flow, coo.hex.bal1.vol.port_b.Xi_outflow[1:0], coo.hex.bal1.vol.port_a.Xi_outflow[1:0], coo.hex.bal1.vol.m_flow_small / 1000.0);
  coo.hex.bal1.vol.COut[1:0] = Buildings.Utilities.Math.Functions.regStep(coo.hex.bal1.vol.port_a.m_flow, coo.hex.bal1.vol.port_b.C_outflow[1:0], coo.hex.bal1.vol.port_a.C_outflow[1:0], coo.hex.bal1.vol.m_flow_small / 1000.0);
 else
  coo.hex.bal1.vol.hOut = coo.hex.bal1.vol.port_b.h_outflow;
  coo.hex.bal1.vol.XiOut[1:0] = coo.hex.bal1.vol.port_b.Xi_outflow[1:0];
  coo.hex.bal1.vol.COut[1:0] = coo.hex.bal1.vol.port_b.C_outflow[1:0];
 end if;
 coo.hex.bal1.vol.port_a.m_flow + coo.hex.bal1.vol.port_b.m_flow = 0;
 if true then
  coo.hex.bal1.vol.port_b.Xi_outflow[1:0] = inStream(coo.hex.bal1.vol.port_a.Xi_outflow[1:0]) + coo.hex.bal1.vol.mXi_flow[1:0] * coo.hex.bal1.vol.m_flowInv;
 else
  assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal1.vol" + ": Wrong implementation for forward flow.");
  coo.hex.bal1.vol.port_b.Xi_outflow[1:0] = inStream(coo.hex.bal1.vol.port_a.Xi_outflow[1:0]);
 end if;
 if true then
  if true then
   coo.hex.bal1.vol.port_a.Xi_outflow[1:0] = inStream(coo.hex.bal1.vol.port_b.Xi_outflow[1:0]) - coo.hex.bal1.vol.mXi_flow[1:0] * coo.hex.bal1.vol.m_flowInv;
  else
   assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal1.vol" + ": Wrong implementation for reverse flow.");
   coo.hex.bal1.vol.port_a.Xi_outflow[1:0] = inStream(coo.hex.bal1.vol.port_b.Xi_outflow[1:0]);
  end if;
 else
  coo.hex.bal1.vol.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 end if;
 if true then
  coo.hex.bal1.vol.port_b.h_outflow = inStream(coo.hex.bal1.vol.port_a.h_outflow) + coo.hex.bal1.vol.Q_flow * coo.hex.bal1.vol.m_flowInv;
  if true then
   coo.hex.bal1.vol.port_a.h_outflow = inStream(coo.hex.bal1.vol.port_b.h_outflow) - coo.hex.bal1.vol.Q_flow * coo.hex.bal1.vol.m_flowInv;
  else
   coo.hex.bal1.vol.port_a.h_outflow = 83680.0;
  end if;
 else
  coo.hex.bal1.vol.port_a.m_flow * (inStream(coo.hex.bal1.vol.port_a.h_outflow) - coo.hex.bal1.vol.port_b.h_outflow) = - coo.hex.bal1.vol.Q_flow;
  if true then
   coo.hex.bal1.vol.port_a.m_flow * (inStream(coo.hex.bal1.vol.port_b.h_outflow) - coo.hex.bal1.vol.port_a.h_outflow) = coo.hex.bal1.vol.Q_flow;
  else
   coo.hex.bal1.vol.port_a.h_outflow = 83680.0;
  end if;
 end if;
 if true and false then
  coo.hex.bal1.vol.port_b.C_outflow[1:0] = inStream(coo.hex.bal1.vol.port_a.C_outflow[1:0]) + coo.hex.bal1.vol.C_flow_internal[1:0] * coo.hex.bal1.vol.m_flowInv;
 else
  assert(not false, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal1.vol" + ": Wrong implementation of trace substance balance for forward flow.");
  coo.hex.bal1.vol.port_b.C_outflow[1:0] = inStream(coo.hex.bal1.vol.port_a.C_outflow[1:0]);
 end if;
 if true then
  if false then
   coo.hex.bal1.vol.port_a.C_outflow[1:0] = inStream(coo.hex.bal1.vol.port_b.C_outflow[1:0]) - coo.hex.bal1.vol.C_flow_internal[1:0] * coo.hex.bal1.vol.m_flowInv;
  else
   coo.hex.bal1.vol.port_a.C_outflow[1:0] = inStream(coo.hex.bal1.vol.port_b.C_outflow[1:0]);
  end if;
 else
  coo.hex.bal1.vol.port_a.C_outflow[1:0] = zeros(0);
 end if;
 coo.hex.bal1.vol.port_a.p = coo.hex.bal1.vol.port_b.p;
 if true then
  if false then
   if false then
    coo.hex.bal1.preDro.m_flow = coo.hex.bal1.preDro.dp * coo.hex.bal1.preDro.coeff;
   else
    coo.hex.bal1.preDro.dp = coo.hex.bal1.preDro.m_flow * coo.hex.bal1.preDro.coeff;
   end if;
  else
   if true then
    if false then
     coo.hex.bal1.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(coo.hex.bal1.preDro.dp, coo.hex.bal1.preDro.k, coo.hex.bal1.preDro.m_flow_turbulent);
    else
     coo.hex.bal1.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.hex.bal1.preDro.m_flow, coo.hex.bal1.preDro.k, coo.hex.bal1.preDro.m_flow_turbulent);
    end if;
   else
    if false then
     coo.hex.bal1.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(coo.hex.bal1.preDro.dp, coo.hex.bal1.preDro.k, coo.hex.bal1.preDro.m_flow_turbulent);
    else
     coo.hex.bal1.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.hex.bal1.preDro.m_flow, coo.hex.bal1.preDro.k, coo.hex.bal1.preDro.m_flow_turbulent);
    end if;
   end if;
  end if;
 else
  coo.hex.bal1.preDro.dp = 0;
 end if;
 coo.hex.bal1.preDro.port_a.h_outflow = inStream(coo.hex.bal1.preDro.port_b.h_outflow);
 coo.hex.bal1.preDro.port_b.h_outflow = inStream(coo.hex.bal1.preDro.port_a.h_outflow);
 coo.hex.bal1.preDro.port_a.m_flow + coo.hex.bal1.preDro.port_b.m_flow = 0;
 coo.hex.bal1.preDro.port_a.Xi_outflow[1:0] = inStream(coo.hex.bal1.preDro.port_b.Xi_outflow[1:0]);
 coo.hex.bal1.preDro.port_b.Xi_outflow[1:0] = inStream(coo.hex.bal1.preDro.port_a.Xi_outflow[1:0]);
 coo.hex.bal1.preDro.port_a.C_outflow[1:0] = inStream(coo.hex.bal1.preDro.port_b.C_outflow[1:0]);
 coo.hex.bal1.preDro.port_b.C_outflow[1:0] = inStream(coo.hex.bal1.preDro.port_a.C_outflow[1:0]);
 if not false then
  coo.hex.bal2.vol.mWat_flow_internal = 0;
 end if;
 if not false then
  coo.hex.bal2.vol.C_flow_internal[1:0] = zeros(0);
 end if;
 coo.hex.bal2.vol.mXi_flow[1:0] = coo.hex.bal2.vol.mWat_flow_internal * fill(0.0, 0);
 if true then
  coo.hex.bal2.vol.m_flowInv = Buildings.Utilities.Math.Functions.inverseXRegularized(coo.hex.bal2.vol.port_a.m_flow, 7.024856596558318E-7, 1423516.6031573217, -2.1352749047359824E7, 2.411415428162826E14, -1.0413454231722027E21, 2.19276153666763E27, -2.221244068539758E33, 8.65383400968502E38);
 else
  coo.hex.bal2.vol.m_flowInv = 0;
 end if;
 if true then
  assert(noEvent(abs(coo.hex.bal2.vol.Q_flow) < 200.0 * coo.hex.bal2.vol.cp_default * max(7.024856596558318E-4 / 1000.0, abs(coo.hex.bal2.vol.m_flow))), "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal2.vol" + ":
   The heat flow rate equals " + String(coo.hex.bal2.vol.Q_flow) + " W and the mass flow rate equals " + String(coo.hex.bal2.vol.m_flow) + " kg/s,
   which results in a temperature difference " + String(abs(coo.hex.bal2.vol.Q_flow) / (coo.hex.bal2.vol.cp_default * max(7.024856596558318E-4 / 1000.0, abs(coo.hex.bal2.vol.m_flow)))) + " K > dTMax=" + String(200.0) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
 end if;
 if true then
  coo.hex.bal2.vol.hOut = Buildings.Utilities.Math.Functions.regStep(coo.hex.bal2.vol.port_a.m_flow, coo.hex.bal2.vol.port_b.h_outflow, coo.hex.bal2.vol.port_a.h_outflow, 7.024856596558318E-4 / 1000.0);
  coo.hex.bal2.vol.XiOut[1:0] = Buildings.Utilities.Math.Functions.regStep(coo.hex.bal2.vol.port_a.m_flow, coo.hex.bal2.vol.port_b.Xi_outflow[1:0], coo.hex.bal2.vol.port_a.Xi_outflow[1:0], 7.024856596558318E-4 / 1000.0);
  coo.hex.bal2.vol.COut[1:0] = Buildings.Utilities.Math.Functions.regStep(coo.hex.bal2.vol.port_a.m_flow, coo.hex.bal2.vol.port_b.C_outflow[1:0], coo.hex.bal2.vol.port_a.C_outflow[1:0], 7.024856596558318E-4 / 1000.0);
 else
  coo.hex.bal2.vol.hOut = coo.hex.bal2.vol.port_b.h_outflow;
  coo.hex.bal2.vol.XiOut[1:0] = coo.hex.bal2.vol.port_b.Xi_outflow[1:0];
  coo.hex.bal2.vol.COut[1:0] = coo.hex.bal2.vol.port_b.C_outflow[1:0];
 end if;
 coo.hex.bal2.vol.port_a.m_flow + coo.hex.bal2.vol.port_b.m_flow = 0;
 if true then
  coo.hex.bal2.vol.port_b.Xi_outflow[1:0] = inStream(coo.hex.bal2.vol.port_a.Xi_outflow[1:0]) + coo.hex.bal2.vol.mXi_flow[1:0] * coo.hex.bal2.vol.m_flowInv;
 else
  assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal2.vol" + ": Wrong implementation for forward flow.");
  coo.hex.bal2.vol.port_b.Xi_outflow[1:0] = inStream(coo.hex.bal2.vol.port_a.Xi_outflow[1:0]);
 end if;
 if true then
  if true then
   coo.hex.bal2.vol.port_a.Xi_outflow[1:0] = inStream(coo.hex.bal2.vol.port_b.Xi_outflow[1:0]) - coo.hex.bal2.vol.mXi_flow[1:0] * coo.hex.bal2.vol.m_flowInv;
  else
   assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal2.vol" + ": Wrong implementation for reverse flow.");
   coo.hex.bal2.vol.port_a.Xi_outflow[1:0] = inStream(coo.hex.bal2.vol.port_b.Xi_outflow[1:0]);
  end if;
 else
  coo.hex.bal2.vol.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 end if;
 if true then
  coo.hex.bal2.vol.port_b.h_outflow = inStream(coo.hex.bal2.vol.port_a.h_outflow) + coo.hex.bal2.vol.Q_flow * coo.hex.bal2.vol.m_flowInv;
  if true then
   coo.hex.bal2.vol.port_a.h_outflow = inStream(coo.hex.bal2.vol.port_b.h_outflow) - coo.hex.bal2.vol.Q_flow * coo.hex.bal2.vol.m_flowInv;
  else
   coo.hex.bal2.vol.port_a.h_outflow = 83680.0;
  end if;
 else
  coo.hex.bal2.vol.port_a.m_flow * (inStream(coo.hex.bal2.vol.port_a.h_outflow) - coo.hex.bal2.vol.port_b.h_outflow) = - coo.hex.bal2.vol.Q_flow;
  if true then
   coo.hex.bal2.vol.port_a.m_flow * (inStream(coo.hex.bal2.vol.port_b.h_outflow) - coo.hex.bal2.vol.port_a.h_outflow) = coo.hex.bal2.vol.Q_flow;
  else
   coo.hex.bal2.vol.port_a.h_outflow = 83680.0;
  end if;
 end if;
 if true and false then
  coo.hex.bal2.vol.port_b.C_outflow[1:0] = inStream(coo.hex.bal2.vol.port_a.C_outflow[1:0]) + coo.hex.bal2.vol.C_flow_internal[1:0] * coo.hex.bal2.vol.m_flowInv;
 else
  assert(not false, "In " + "CouplingETS_TimeSeriesBuilding.coo.hex.bal2.vol" + ": Wrong implementation of trace substance balance for forward flow.");
  coo.hex.bal2.vol.port_b.C_outflow[1:0] = inStream(coo.hex.bal2.vol.port_a.C_outflow[1:0]);
 end if;
 if true then
  if false then
   coo.hex.bal2.vol.port_a.C_outflow[1:0] = inStream(coo.hex.bal2.vol.port_b.C_outflow[1:0]) - coo.hex.bal2.vol.C_flow_internal[1:0] * coo.hex.bal2.vol.m_flowInv;
  else
   coo.hex.bal2.vol.port_a.C_outflow[1:0] = inStream(coo.hex.bal2.vol.port_b.C_outflow[1:0]);
  end if;
 else
  coo.hex.bal2.vol.port_a.C_outflow[1:0] = zeros(0);
 end if;
 coo.hex.bal2.vol.port_a.p = coo.hex.bal2.vol.port_b.p;
 if true then
  if false then
   if false then
    coo.hex.bal2.preDro.m_flow = coo.hex.bal2.preDro.dp * coo.hex.bal2.preDro.coeff;
   else
    coo.hex.bal2.preDro.dp = coo.hex.bal2.preDro.m_flow * coo.hex.bal2.preDro.coeff;
   end if;
  else
   if true then
    if false then
     coo.hex.bal2.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(coo.hex.bal2.preDro.dp, coo.hex.bal2.preDro.k, 0.7024856596558318);
    else
     coo.hex.bal2.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.hex.bal2.preDro.m_flow, coo.hex.bal2.preDro.k, 0.7024856596558318);
    end if;
   else
    if false then
     coo.hex.bal2.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(coo.hex.bal2.preDro.dp, coo.hex.bal2.preDro.k, 0.7024856596558318);
    else
     coo.hex.bal2.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.hex.bal2.preDro.m_flow, coo.hex.bal2.preDro.k, 0.7024856596558318);
    end if;
   end if;
  end if;
 else
  coo.hex.bal2.preDro.dp = 0;
 end if;
 coo.hex.bal2.preDro.port_a.h_outflow = inStream(coo.hex.bal2.preDro.port_b.h_outflow);
 coo.hex.bal2.preDro.port_b.h_outflow = inStream(coo.hex.bal2.preDro.port_a.h_outflow);
 coo.hex.bal2.preDro.port_a.m_flow + coo.hex.bal2.preDro.port_b.m_flow = 0;
 coo.hex.bal2.preDro.port_a.Xi_outflow[1:0] = inStream(coo.hex.bal2.preDro.port_b.Xi_outflow[1:0]);
 coo.hex.bal2.preDro.port_b.Xi_outflow[1:0] = inStream(coo.hex.bal2.preDro.port_a.Xi_outflow[1:0]);
 coo.hex.bal2.preDro.port_a.C_outflow[1:0] = inStream(coo.hex.bal2.preDro.port_b.C_outflow[1:0]);
 coo.hex.bal2.preDro.port_b.C_outflow[1:0] = inStream(coo.hex.bal2.preDro.port_a.C_outflow[1:0]);
 assert(1.0 >= 0.0, "LimPID: Limits must be consistent. However, yMax (=" + String(1.0) + ") < yMin (=" + String(0.0) + ")");
 if Modelica.Blocks.Types.InitPID.InitialOutput == Modelica.Blocks.Types.InitPID.InitialOutput and (0.0 < 0.0 or 0.0 > 1.0) then
  Modelica.Utilities.Streams.error("LimPID: Start value y_start (=" + String(0.0) + ") is outside of the limits of yMin (=" + String(0.0) + ") and yMax (=" + String(1.0) + ")");
 end if;
 if Buildings.Types.Reset.Disabled <> Buildings.Types.Reset.Input then
  coo.con.y_reset_internal = 0.0;
 end if;
 coo.con.addP.y = coo.con.addP.k1 * coo.con.addP.u1 + coo.con.addP.k2 * coo.con.addP.u2;
 coo.con.addD.y = coo.con.addD.k1 * coo.con.addD.u1 + coo.con.addD.k2 * coo.con.addD.u2;
 coo.con.P.y = coo.con.P.k * coo.con.P.u;
 der(coo.con.I.y) = coo.con.I.k * coo.con.I.u;
 if Buildings.Types.Reset.Disabled <> Buildings.Types.Reset.Input then
  coo.con.I.y_reset_internal = 0.0;
 end if;
 if Buildings.Types.Reset.Disabled == Buildings.Types.Reset.Disabled then
  coo.con.I.trigger_internal = false;
 else
  when coo.con.I.trigger_internal then
   reinit(coo.con.I.y, coo.con.I.y_reset_internal);
  end when;
 end if;
 der(coo.con.D.x) = (coo.con.D.u - coo.con.D.x) / coo.con.D.T;
 coo.con.D.y = 0.1 / coo.con.D.T * (coo.con.D.u - coo.con.D.x);
 coo.con.addPID.y = coo.con.addPID.u1 + coo.con.addPID.u2 + coo.con.addPID.u3;
 coo.con.addI.y = coo.con.addI.k1 * coo.con.addI.u1 + coo.con.addI.k2 * coo.con.addI.u2 + coo.con.addI.k3 * coo.con.addI.u3;
 coo.con.addSat.y = coo.con.addSat.u1 + (- coo.con.addSat.u2);
 coo.con.gainPID.y = coo.con.gainPID.k * coo.con.gainPID.u;
 coo.con.gainTrack.y = coo.con.gainTrack.k * coo.con.gainTrack.u;
 assert(coo.con.limiter.uMax >= coo.con.limiter.uMin, "Limiter: Limits must be consistent. However, uMax (=" + String(coo.con.limiter.uMax) + ") < uMin (=" + String(coo.con.limiter.uMin) + ")");
 if true then
  coo.con.limiter.y = smooth(0, noEvent(if coo.con.limiter.u > coo.con.limiter.uMax then coo.con.limiter.uMax elseif coo.con.limiter.u < coo.con.limiter.uMin then coo.con.limiter.uMin else coo.con.limiter.u));
 else
  coo.con.limiter.y = smooth(0, if coo.con.limiter.u > coo.con.limiter.uMax then coo.con.limiter.uMax elseif coo.con.limiter.u < coo.con.limiter.uMin then coo.con.limiter.uMin else coo.con.limiter.u);
 end if;
 if true then
  coo.senTDisSup.T_a_inflow = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.senTDisSup.port_b.p, coo.senTDisSup.port_b.h_outflow, coo.senTDisSup.port_b.Xi_outflow[1:0]));
  coo.senTDisSup.T_b_inflow = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.senTDisSup.port_a.p, coo.senTDisSup.port_a.h_outflow, coo.senTDisSup.port_a.Xi_outflow[1:0]));
  coo.senTDisSup.TMed = Modelica.Fluid.Utilities.regStep(coo.senTDisSup.port_a.m_flow, coo.senTDisSup.T_a_inflow, coo.senTDisSup.T_b_inflow, coo.senTDisSup.m_flow_small);
 else
  coo.senTDisSup.TMed = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.senTDisSup.port_b.p, coo.senTDisSup.port_b.h_outflow, coo.senTDisSup.port_b.Xi_outflow[1:0]));
  coo.senTDisSup.T_a_inflow = coo.senTDisSup.TMed;
  coo.senTDisSup.T_b_inflow = coo.senTDisSup.TMed;
 end if;
 if true then
  if false then
   der(coo.senTDisSup.T) = (coo.senTDisSup.TMed - coo.senTDisSup.T) * coo.senTDisSup.k + (coo.senTDisSup.TAmb - coo.senTDisSup.T) * coo.senTDisSup.tauHeaTraInv / (coo.senTDisSup.ratTau * coo.senTDisSup.k + 1);
  else
   der(coo.senTDisSup.T) = (coo.senTDisSup.TMed - coo.senTDisSup.T) * coo.senTDisSup.k;
  end if;
 else
  coo.senTDisSup.T = coo.senTDisSup.TMed;
 end if;
 if true then
  coo.senTDisSup.mNor_flow = coo.senTDisSup.port_a.m_flow / coo.senTDisSup.m_flow_nominal;
  coo.senTDisSup.k = Modelica.Fluid.Utilities.regStep(coo.senTDisSup.port_a.m_flow, coo.senTDisSup.mNor_flow, - coo.senTDisSup.mNor_flow, coo.senTDisSup.m_flow_small);
 else
  coo.senTDisSup.mNor_flow = 1;
  coo.senTDisSup.k = 1;
 end if;
 coo.senTDisSup.port_b.m_flow = - coo.senTDisSup.port_a.m_flow;
 coo.senTDisSup.port_a.p = coo.senTDisSup.port_b.p;
 coo.senTDisSup.port_a.h_outflow = inStream(coo.senTDisSup.port_b.h_outflow);
 coo.senTDisSup.port_b.h_outflow = inStream(coo.senTDisSup.port_a.h_outflow);
 coo.senTDisSup.port_a.Xi_outflow[1:0] = inStream(coo.senTDisSup.port_b.Xi_outflow[1:0]);
 coo.senTDisSup.port_b.Xi_outflow[1:0] = inStream(coo.senTDisSup.port_a.Xi_outflow[1:0]);
 coo.senTDisSup.port_a.C_outflow[1:0] = inStream(coo.senTDisSup.port_b.C_outflow[1:0]);
 coo.senTDisSup.port_b.C_outflow[1:0] = inStream(coo.senTDisSup.port_a.C_outflow[1:0]);
 if true then
  coo.senTDisRet.T_a_inflow = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.senTDisRet.port_b.p, coo.senTDisRet.port_b.h_outflow, coo.senTDisRet.port_b.Xi_outflow[1:0]));
  coo.senTDisRet.T_b_inflow = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.senTDisRet.port_a.p, coo.senTDisRet.port_a.h_outflow, coo.senTDisRet.port_a.Xi_outflow[1:0]));
  coo.senTDisRet.TMed = Modelica.Fluid.Utilities.regStep(coo.senTDisRet.port_a.m_flow, coo.senTDisRet.T_a_inflow, coo.senTDisRet.T_b_inflow, coo.senTDisRet.m_flow_small);
 else
  coo.senTDisRet.TMed = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.senTDisRet.port_b.p, coo.senTDisRet.port_b.h_outflow, coo.senTDisRet.port_b.Xi_outflow[1:0]));
  coo.senTDisRet.T_a_inflow = coo.senTDisRet.TMed;
  coo.senTDisRet.T_b_inflow = coo.senTDisRet.TMed;
 end if;
 if true then
  if false then
   der(coo.senTDisRet.T) = (coo.senTDisRet.TMed - coo.senTDisRet.T) * coo.senTDisRet.k + (coo.senTDisRet.TAmb - coo.senTDisRet.T) * coo.senTDisRet.tauHeaTraInv / (coo.senTDisRet.ratTau * coo.senTDisRet.k + 1);
  else
   der(coo.senTDisRet.T) = (coo.senTDisRet.TMed - coo.senTDisRet.T) * coo.senTDisRet.k;
  end if;
 else
  coo.senTDisRet.T = coo.senTDisRet.TMed;
 end if;
 if true then
  coo.senTDisRet.mNor_flow = coo.senTDisRet.port_a.m_flow / coo.senTDisRet.m_flow_nominal;
  coo.senTDisRet.k = Modelica.Fluid.Utilities.regStep(coo.senTDisRet.port_a.m_flow, coo.senTDisRet.mNor_flow, - coo.senTDisRet.mNor_flow, coo.senTDisRet.m_flow_small);
 else
  coo.senTDisRet.mNor_flow = 1;
  coo.senTDisRet.k = 1;
 end if;
 coo.senTDisRet.port_b.m_flow = - coo.senTDisRet.port_a.m_flow;
 coo.senTDisRet.port_a.p = coo.senTDisRet.port_b.p;
 coo.senTDisRet.port_a.h_outflow = inStream(coo.senTDisRet.port_b.h_outflow);
 coo.senTDisRet.port_b.h_outflow = inStream(coo.senTDisRet.port_a.h_outflow);
 coo.senTDisRet.port_a.Xi_outflow[1:0] = inStream(coo.senTDisRet.port_b.Xi_outflow[1:0]);
 coo.senTDisRet.port_b.Xi_outflow[1:0] = inStream(coo.senTDisRet.port_a.Xi_outflow[1:0]);
 coo.senTDisRet.port_a.C_outflow[1:0] = inStream(coo.senTDisRet.port_b.C_outflow[1:0]);
 coo.senTDisRet.port_b.C_outflow[1:0] = inStream(coo.senTDisRet.port_a.C_outflow[1:0]);
 der(coo.int.y) = coo.int.k * coo.int.u;
 coo.senMasFlo.m_flow = coo.senMasFlo.port_a.m_flow;
 coo.senMasFlo.port_b.m_flow = - coo.senMasFlo.port_a.m_flow;
 coo.senMasFlo.port_a.p = coo.senMasFlo.port_b.p;
 coo.senMasFlo.port_a.h_outflow = inStream(coo.senMasFlo.port_b.h_outflow);
 coo.senMasFlo.port_b.h_outflow = inStream(coo.senMasFlo.port_a.h_outflow);
 coo.senMasFlo.port_a.Xi_outflow[1:0] = inStream(coo.senMasFlo.port_b.Xi_outflow[1:0]);
 coo.senMasFlo.port_b.Xi_outflow[1:0] = inStream(coo.senMasFlo.port_a.Xi_outflow[1:0]);
 coo.senMasFlo.port_a.C_outflow[1:0] = inStream(coo.senMasFlo.port_b.C_outflow[1:0]);
 coo.senMasFlo.port_b.C_outflow[1:0] = inStream(coo.senMasFlo.port_a.C_outflow[1:0]);
 if true then
  coo.TBuiSup.T_a_inflow = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.TBuiSup.port_b.p, coo.TBuiSup.port_b.h_outflow, coo.TBuiSup.port_b.Xi_outflow[1:0]));
  coo.TBuiSup.T_b_inflow = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.TBuiSup.port_a.p, coo.TBuiSup.port_a.h_outflow, coo.TBuiSup.port_a.Xi_outflow[1:0]));
  coo.TBuiSup.TMed = Modelica.Fluid.Utilities.regStep(coo.TBuiSup.port_a.m_flow, coo.TBuiSup.T_a_inflow, coo.TBuiSup.T_b_inflow, 7.024856596558318E-4);
 else
  coo.TBuiSup.TMed = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.TBuiSup.port_b.p, coo.TBuiSup.port_b.h_outflow, coo.TBuiSup.port_b.Xi_outflow[1:0]));
  coo.TBuiSup.T_a_inflow = coo.TBuiSup.TMed;
  coo.TBuiSup.T_b_inflow = coo.TBuiSup.TMed;
 end if;
 if true then
  if false then
   der(coo.TBuiSup.T) = (coo.TBuiSup.TMed - coo.TBuiSup.T) * coo.TBuiSup.k + (coo.TBuiSup.TAmb - coo.TBuiSup.T) * coo.TBuiSup.tauHeaTraInv / (coo.TBuiSup.ratTau * coo.TBuiSup.k + 1);
  else
   der(coo.TBuiSup.T) = (coo.TBuiSup.TMed - coo.TBuiSup.T) * coo.TBuiSup.k;
  end if;
 else
  coo.TBuiSup.T = coo.TBuiSup.TMed;
 end if;
 if true then
  coo.TBuiSup.mNor_flow = coo.TBuiSup.port_a.m_flow / 7.024856596558317;
  coo.TBuiSup.k = Modelica.Fluid.Utilities.regStep(coo.TBuiSup.port_a.m_flow, coo.TBuiSup.mNor_flow, - coo.TBuiSup.mNor_flow, 7.024856596558318E-4);
 else
  coo.TBuiSup.mNor_flow = 1;
  coo.TBuiSup.k = 1;
 end if;
 coo.TBuiSup.port_b.m_flow = - coo.TBuiSup.port_a.m_flow;
 coo.TBuiSup.port_a.p = coo.TBuiSup.port_b.p;
 coo.TBuiSup.port_a.h_outflow = inStream(coo.TBuiSup.port_b.h_outflow);
 coo.TBuiSup.port_b.h_outflow = inStream(coo.TBuiSup.port_a.h_outflow);
 coo.TBuiSup.port_a.Xi_outflow[1:0] = inStream(coo.TBuiSup.port_b.Xi_outflow[1:0]);
 coo.TBuiSup.port_b.Xi_outflow[1:0] = inStream(coo.TBuiSup.port_a.Xi_outflow[1:0]);
 coo.TBuiSup.port_a.C_outflow[1:0] = inStream(coo.TBuiSup.port_b.C_outflow[1:0]);
 coo.TBuiSup.port_b.C_outflow[1:0] = inStream(coo.TBuiSup.port_a.C_outflow[1:0]);
 coo.val.kVal = coo.val.phi * coo.val.Kv_SI;
 if 0.0 > 1.0E-15 then
  coo.val.k = sqrt(1 / (1 / coo.val.kFixed ^ 2 + 1 / coo.val.kVal ^ 2));
 else
  coo.val.k = coo.val.kVal;
 end if;
 if false then
  coo.val.m_flow * coo.val.m_flow_nominal_pos = coo.val.k ^ 2 * coo.val.dp;
 else
  if true then
   if false then
    coo.val.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(coo.val.dp, coo.val.k, coo.val.m_flow_turbulent);
   else
    coo.val.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.val.m_flow, coo.val.k, coo.val.m_flow_turbulent);
   end if;
  else
   if false then
    coo.val.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(coo.val.dp, coo.val.k, coo.val.m_flow_turbulent);
   else
    coo.val.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.val.m_flow, coo.val.k, coo.val.m_flow_turbulent);
   end if;
  end if;
 end if;
 coo.val.port_a.h_outflow = 83680.0;
 coo.val.port_b.h_outflow = inStream(coo.val.port_a.h_outflow);
 coo.val.port_a.m_flow + coo.val.port_b.m_flow = 0;
 coo.val.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 coo.val.port_b.Xi_outflow[1:0] = inStream(coo.val.port_a.Xi_outflow[1:0]);
 coo.val.port_a.C_outflow[1:0] = zeros(0);
 coo.val.port_b.C_outflow[1:0] = inStream(coo.val.port_a.C_outflow[1:0]);
 coo.cp.y = coo.cp.k * coo.cp.u;
 coo.pro.y = coo.pro.u1 * coo.pro.u2;
 coo.dTDis.y = coo.dTDis.k1 * coo.dTDis.u1 + coo.dTDis.k2 * coo.dTDis.u2;
 if true then
  coo.TBuiRet.T_a_inflow = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.TBuiRet.port_b.p, coo.TBuiRet.port_b.h_outflow, coo.TBuiRet.port_b.Xi_outflow[1:0]));
  coo.TBuiRet.T_b_inflow = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.TBuiRet.port_a.p, coo.TBuiRet.port_a.h_outflow, coo.TBuiRet.port_a.Xi_outflow[1:0]));
  coo.TBuiRet.TMed = Modelica.Fluid.Utilities.regStep(coo.TBuiRet.port_a.m_flow, coo.TBuiRet.T_a_inflow, coo.TBuiRet.T_b_inflow, 7.024856596558318E-4);
 else
  coo.TBuiRet.TMed = Buildings.Media.Water.temperature(Buildings.Media.Water.setState_phX(coo.TBuiRet.port_b.p, coo.TBuiRet.port_b.h_outflow, coo.TBuiRet.port_b.Xi_outflow[1:0]));
  coo.TBuiRet.T_a_inflow = coo.TBuiRet.TMed;
  coo.TBuiRet.T_b_inflow = coo.TBuiRet.TMed;
 end if;
 if true then
  if false then
   der(coo.TBuiRet.T) = (coo.TBuiRet.TMed - coo.TBuiRet.T) * coo.TBuiRet.k + (coo.TBuiRet.TAmb - coo.TBuiRet.T) * coo.TBuiRet.tauHeaTraInv / (coo.TBuiRet.ratTau * coo.TBuiRet.k + 1);
  else
   der(coo.TBuiRet.T) = (coo.TBuiRet.TMed - coo.TBuiRet.T) * coo.TBuiRet.k;
  end if;
 else
  coo.TBuiRet.T = coo.TBuiRet.TMed;
 end if;
 if true then
  coo.TBuiRet.mNor_flow = coo.TBuiRet.port_a.m_flow / 7.024856596558317;
  coo.TBuiRet.k = Modelica.Fluid.Utilities.regStep(coo.TBuiRet.port_a.m_flow, coo.TBuiRet.mNor_flow, - coo.TBuiRet.mNor_flow, 7.024856596558318E-4);
 else
  coo.TBuiRet.mNor_flow = 1;
  coo.TBuiRet.k = 1;
 end if;
 coo.TBuiRet.port_b.m_flow = - coo.TBuiRet.port_a.m_flow;
 coo.TBuiRet.port_a.p = coo.TBuiRet.port_b.p;
 coo.TBuiRet.port_a.h_outflow = inStream(coo.TBuiRet.port_b.h_outflow);
 coo.TBuiRet.port_b.h_outflow = inStream(coo.TBuiRet.port_a.h_outflow);
 coo.TBuiRet.port_a.Xi_outflow[1:0] = inStream(coo.TBuiRet.port_b.Xi_outflow[1:0]);
 coo.TBuiRet.port_b.Xi_outflow[1:0] = inStream(coo.TBuiRet.port_a.Xi_outflow[1:0]);
 coo.TBuiRet.port_a.C_outflow[1:0] = inStream(coo.TBuiRet.port_b.C_outflow[1:0]);
 coo.TBuiRet.port_b.C_outflow[1:0] = inStream(coo.TBuiRet.port_a.C_outflow[1:0]);
 if true then
  assert(bui.loa.tableName <> "NoName", "tableOnFile = true and no table name given");
 else
  assert(size(bui.loa.table[1:0,1:2], 1) > 0 and size(bui.loa.table[1:0,1:2], 2) > 0, "tableOnFile = false and parameter table is an empty matrix");
 end if;
 bui.loa.timeScaled = time;
 when {time >= pre(bui.loa.nextTimeEvent), initial()} then
  bui.loa.nextTimeEventScaled = Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getNextTimeEvent(bui.loa.tableID, bui.loa.timeScaled, bui.loa.tableOnFileRead);
  if bui.loa.nextTimeEventScaled < 1.7976931348623157E308 then
   bui.loa.nextTimeEvent = bui.loa.nextTimeEventScaled;
  else
   bui.loa.nextTimeEvent = 1.7976931348623157E308;
  end if;
 end when;
 if Modelica.Blocks.Types.Smoothness.LinearSegments == Modelica.Blocks.Types.Smoothness.ConstantSegments then
  bui.loa.y[1] = bui.loa.p_offset[1] + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableValueNoDer(bui.loa.tableID, 1, bui.loa.timeScaled, bui.loa.nextTimeEventScaled, pre(bui.loa.nextTimeEventScaled), bui.loa.tableOnFileRead);
  bui.loa.y[2] = bui.loa.p_offset[2] + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableValueNoDer(bui.loa.tableID, 2, bui.loa.timeScaled, bui.loa.nextTimeEventScaled, pre(bui.loa.nextTimeEventScaled), bui.loa.tableOnFileRead);
  bui.loa.y[3] = bui.loa.p_offset[3] + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableValueNoDer(bui.loa.tableID, 3, bui.loa.timeScaled, bui.loa.nextTimeEventScaled, pre(bui.loa.nextTimeEventScaled), bui.loa.tableOnFileRead);
 else
  bui.loa.y[1] = bui.loa.p_offset[1] + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableValue(bui.loa.tableID, 1, bui.loa.timeScaled, bui.loa.nextTimeEventScaled, pre(bui.loa.nextTimeEventScaled), bui.loa.tableOnFileRead);
  bui.loa.y[2] = bui.loa.p_offset[2] + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableValue(bui.loa.tableID, 2, bui.loa.timeScaled, bui.loa.nextTimeEventScaled, pre(bui.loa.nextTimeEventScaled), bui.loa.tableOnFileRead);
  bui.loa.y[3] = bui.loa.p_offset[3] + Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableValue(bui.loa.tableID, 3, bui.loa.timeScaled, bui.loa.nextTimeEventScaled, pre(bui.loa.nextTimeEventScaled), bui.loa.tableOnFileRead);
 end if;
 bui.terUniHea.fan.inputSwitch.y = bui.terUniHea.fan.inputSwitch.u;
 if not true then
  assert(bui.terUniHea.fan.vol.ports[1].m_flow > -0.0016528673093224517, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol" + ": Model has flow reversal,
  but the parameter allowFlowReversal is set to false.
  m_flow_small    = " + String(0.0016528673093224517) + "
  ports[1].m_flow = " + String(bui.terUniHea.fan.vol.ports[1].m_flow) + "
");
 end if;
 if false then
  bui.terUniHea.fan.vol.U = 0;
  bui.terUniHea.fan.vol.mXi[1:1] = zeros(1);
  bui.terUniHea.fan.vol.m = 0;
  bui.terUniHea.fan.vol.mC[1:0] = zeros(0);
 end if;
 if not false then
  bui.terUniHea.fan.vol.dynBal.mWat_flow_internal = 0;
 end if;
 if not false then
  bui.terUniHea.fan.vol.dynBal.C_flow_internal[1:0] = zeros(0);
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  bui.terUniHea.fan.vol.dynBal.m = bui.terUniHea.fan.vol.dynBal.fluidVolume * bui.terUniHea.fan.vol.dynBal.rho_start;
 else
  if true then
   bui.terUniHea.fan.vol.dynBal.m = bui.terUniHea.fan.vol.dynBal.fluidVolume * Buildings.Media.Air.density(Buildings.Media.Air.setState_phX(bui.terUniHea.fan.vol.dynBal.medium.p, bui.terUniHea.fan.vol.dynBal.hOut, {0.01, 0.99}));
  else
   bui.terUniHea.fan.vol.dynBal.m = bui.terUniHea.fan.vol.dynBal.fluidVolume * bui.terUniHea.fan.vol.dynBal.medium.d;
  end if;
 end if;
 bui.terUniHea.fan.vol.dynBal.mXi[1:1] = bui.terUniHea.fan.vol.dynBal.m * bui.terUniHea.fan.vol.dynBal.medium.Xi[1:1];
 if false then
  bui.terUniHea.fan.vol.dynBal.U = bui.terUniHea.fan.vol.dynBal.m * bui.terUniHea.fan.vol.dynBal.medium.u + bui.terUniHea.fan.vol.dynBal.CSen * (bui.terUniHea.fan.vol.dynBal.medium.T - 273.15);
 else
  bui.terUniHea.fan.vol.dynBal.U = bui.terUniHea.fan.vol.dynBal.m * bui.terUniHea.fan.vol.dynBal.medium.u;
 end if;
 bui.terUniHea.fan.vol.dynBal.mC[1:0] = bui.terUniHea.fan.vol.dynBal.m * bui.terUniHea.fan.vol.dynBal.C[1:0];
 bui.terUniHea.fan.vol.dynBal.hOut = bui.terUniHea.fan.vol.dynBal.medium.h;
 bui.terUniHea.fan.vol.dynBal.XiOut[1:1] = bui.terUniHea.fan.vol.dynBal.medium.Xi[1:1];
 bui.terUniHea.fan.vol.dynBal.COut[1:0] = bui.terUniHea.fan.vol.dynBal.C[1:0];
 bui.terUniHea.fan.vol.dynBal.ports_H_flow[1] = semiLinear(bui.terUniHea.fan.vol.dynBal.ports[1].m_flow, inStream(bui.terUniHea.fan.vol.dynBal.ports[1].h_outflow), bui.terUniHea.fan.vol.dynBal.ports[1].h_outflow);
 bui.terUniHea.fan.vol.dynBal.ports_mXi_flow[1,1] = semiLinear(bui.terUniHea.fan.vol.dynBal.ports[1].m_flow, inStream(bui.terUniHea.fan.vol.dynBal.ports[1].Xi_outflow[1]), bui.terUniHea.fan.vol.dynBal.ports[1].Xi_outflow[1]);
 bui.terUniHea.fan.vol.dynBal.ports_H_flow[2] = semiLinear(bui.terUniHea.fan.vol.dynBal.ports[2].m_flow, inStream(bui.terUniHea.fan.vol.dynBal.ports[2].h_outflow), bui.terUniHea.fan.vol.dynBal.ports[2].h_outflow);
 bui.terUniHea.fan.vol.dynBal.ports_mXi_flow[2,1] = semiLinear(bui.terUniHea.fan.vol.dynBal.ports[2].m_flow, inStream(bui.terUniHea.fan.vol.dynBal.ports[2].Xi_outflow[1]), bui.terUniHea.fan.vol.dynBal.ports[2].Xi_outflow[1]);
 bui.terUniHea.fan.vol.dynBal.mbXi_flow[1] = sum(bui.terUniHea.fan.vol.dynBal.ports_mXi_flow[1:2,1]);
 bui.terUniHea.fan.vol.dynBal.mb_flow = sum({bui.terUniHea.fan.vol.dynBal.ports[1].m_flow, bui.terUniHea.fan.vol.dynBal.ports[2].m_flow});
 bui.terUniHea.fan.vol.dynBal.Hb_flow = sum(bui.terUniHea.fan.vol.dynBal.ports_H_flow[1:2]);
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  0 = bui.terUniHea.fan.vol.dynBal.Hb_flow + bui.terUniHea.fan.vol.dynBal.Q_flow;
 else
  der(bui.terUniHea.fan.vol.dynBal.U) = bui.terUniHea.fan.vol.dynBal.Hb_flow + bui.terUniHea.fan.vol.dynBal.Q_flow;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  0 = bui.terUniHea.fan.vol.dynBal.mb_flow;
 else
  der(bui.terUniHea.fan.vol.dynBal.m) = bui.terUniHea.fan.vol.dynBal.mb_flow;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  zeros(1) = bui.terUniHea.fan.vol.dynBal.mbXi_flow[1:1] + bui.terUniHea.fan.vol.dynBal.mWat_flow_internal * {1.0};
 else
  der(bui.terUniHea.fan.vol.dynBal.mXi[1:1]) = bui.terUniHea.fan.vol.dynBal.mbXi_flow[1:1] + bui.terUniHea.fan.vol.dynBal.mWat_flow_internal * {1.0};
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  zeros(0) = bui.terUniHea.fan.vol.dynBal.mbC_flow[1:0] + bui.terUniHea.fan.vol.dynBal.C_flow_internal[1:0];
 else
  der(bui.terUniHea.fan.vol.dynBal.mC[1:0]) = bui.terUniHea.fan.vol.dynBal.mbC_flow[1:0] + bui.terUniHea.fan.vol.dynBal.C_flow_internal[1:0];
 end if;
 bui.terUniHea.fan.vol.dynBal.ports[1].p = bui.terUniHea.fan.vol.dynBal.medium.p;
 bui.terUniHea.fan.vol.dynBal.ports[1].h_outflow = bui.terUniHea.fan.vol.dynBal.medium.h;
 bui.terUniHea.fan.vol.dynBal.ports[1].Xi_outflow[1:1] = bui.terUniHea.fan.vol.dynBal.medium.Xi[1:1];
 bui.terUniHea.fan.vol.dynBal.ports[1].C_outflow[1:0] = bui.terUniHea.fan.vol.dynBal.C[1:0];
 bui.terUniHea.fan.vol.dynBal.ports[2].p = bui.terUniHea.fan.vol.dynBal.medium.p;
 bui.terUniHea.fan.vol.dynBal.ports[2].h_outflow = bui.terUniHea.fan.vol.dynBal.medium.h;
 bui.terUniHea.fan.vol.dynBal.ports[2].Xi_outflow[1:1] = bui.terUniHea.fan.vol.dynBal.medium.Xi[1:1];
 bui.terUniHea.fan.vol.dynBal.ports[2].C_outflow[1:0] = bui.terUniHea.fan.vol.dynBal.C[1:0];
 bui.terUniHea.fan.vol.dynBal.UOut = bui.terUniHea.fan.vol.dynBal.U;
 bui.terUniHea.fan.vol.dynBal.mXiOut[1:1] = bui.terUniHea.fan.vol.dynBal.mXi[1:1];
 bui.terUniHea.fan.vol.dynBal.mOut = bui.terUniHea.fan.vol.dynBal.m;
 bui.terUniHea.fan.vol.dynBal.mCOut[1:0] = bui.terUniHea.fan.vol.dynBal.mC[1:0];
 assert(bui.terUniHea.fan.vol.dynBal.medium.T >= 200.0, "
In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol.dynBal.medium" + ": Temperature T exceeded its minimum allowed value of -73.15 degC (200 Kelvin)
as required from medium model \"" + "Air" + "\".");
 assert(bui.terUniHea.fan.vol.dynBal.medium.T <= 423.15, "
In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol.dynBal.medium" + ": Temperature T exceeded its maximum allowed value of 150 degC (423.15 Kelvin)
as required from medium model \"" + "Air" + "\".");
 bui.terUniHea.fan.vol.dynBal.medium.MM = 1 / (bui.terUniHea.fan.vol.dynBal.medium.Xi[1] / 0.01801528 + (1.0 - bui.terUniHea.fan.vol.dynBal.medium.Xi[1]) / 0.0289651159);
 bui.terUniHea.fan.vol.dynBal.medium.X_steam = bui.terUniHea.fan.vol.dynBal.medium.Xi[1];
 bui.terUniHea.fan.vol.dynBal.medium.X_air = 1 - bui.terUniHea.fan.vol.dynBal.medium.Xi[1];
 bui.terUniHea.fan.vol.dynBal.medium.dT = bui.terUniHea.fan.vol.dynBal.medium.T - 273.15;
 bui.terUniHea.fan.vol.dynBal.medium.h = bui.terUniHea.fan.vol.dynBal.medium.dT * 1006.0 * bui.terUniHea.fan.vol.dynBal.medium.X_air + (bui.terUniHea.fan.vol.dynBal.medium.dT * 1860.0 + 2501014.5) * bui.terUniHea.fan.vol.dynBal.medium.X_steam;
 bui.terUniHea.fan.vol.dynBal.medium.R = 287.0512249529787 * bui.terUniHea.fan.vol.dynBal.medium.X_air + 461.5233290850878 * bui.terUniHea.fan.vol.dynBal.medium.X_steam;
 bui.terUniHea.fan.vol.dynBal.medium.u = bui.terUniHea.fan.vol.dynBal.medium.h - 101325.0 / 1.2;
 bui.terUniHea.fan.vol.dynBal.medium.d / 1.2 = bui.terUniHea.fan.vol.dynBal.medium.p / 101325.0;
 bui.terUniHea.fan.vol.dynBal.medium.state.p = bui.terUniHea.fan.vol.dynBal.medium.p;
 bui.terUniHea.fan.vol.dynBal.medium.state.T = bui.terUniHea.fan.vol.dynBal.medium.T;
 bui.terUniHea.fan.vol.dynBal.medium.state.X[1:2] = bui.terUniHea.fan.vol.dynBal.medium.X[1:2];
 if true then
  bui.terUniHea.fan.vol.dynBal.medium.Xi[1:1] = bui.terUniHea.fan.vol.dynBal.medium.X[1:1];
  if false then
   bui.terUniHea.fan.vol.dynBal.medium.X[1:2] = {0.01, 0.99};
  end if;
  if true and not false then
   bui.terUniHea.fan.vol.dynBal.medium.X[2] = 1 - sum(bui.terUniHea.fan.vol.dynBal.medium.Xi[1:1]);
  end if;
  assert(bui.terUniHea.fan.vol.dynBal.medium.X[1] >= -1.0E-5 and bui.terUniHea.fan.vol.dynBal.medium.X[1] <= 1 + 1.0E-5, "Mass fraction X[" + String(1) + "] = " + String(bui.terUniHea.fan.vol.dynBal.medium.X[1]) + "of substance " + "water" + "\nof medium " + "Air" + " is not in the range 0..1");
  assert(bui.terUniHea.fan.vol.dynBal.medium.X[2] >= -1.0E-5 and bui.terUniHea.fan.vol.dynBal.medium.X[2] <= 1 + 1.0E-5, "Mass fraction X[" + String(2) + "] = " + String(bui.terUniHea.fan.vol.dynBal.medium.X[2]) + "of substance " + "air" + "\nof medium " + "Air" + " is not in the range 0..1");
 end if;
 assert(bui.terUniHea.fan.vol.dynBal.medium.p >= 0.0, "Pressure (= " + String(bui.terUniHea.fan.vol.dynBal.medium.p) + " Pa) of medium \"" + "Air" + "\" is negative\n(Temperature = " + String(bui.terUniHea.fan.vol.dynBal.medium.T) + " K)");
 bui.terUniHea.fan.vol.preTem.port.T = bui.terUniHea.fan.vol.preTem.T;
 bui.terUniHea.fan.vol.heaFloSen.port_a.T = bui.terUniHea.fan.vol.heaFloSen.port_b.T;
 bui.terUniHea.fan.vol.heaFloSen.port_a.Q_flow + bui.terUniHea.fan.vol.heaFloSen.port_b.Q_flow = 0;
 bui.terUniHea.fan.vol.heaFloSen.Q_flow = bui.terUniHea.fan.vol.heaFloSen.port_a.Q_flow;
 assert(16.528673093224516 > 0, "u_nominal > 0 required");
 assert(Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.LowPass or Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.HighPass or bui.terUniHea.fan.filter.f_min > 0, "f_min > 0 required for band pass and band stop filter");
 assert(bui.terUniHea.fan.filter.A_ripple > 0, "A_ripple > 0 required");
 assert(bui.terUniHea.fan.filter.f_cut > 0, "f_cut > 0 required");
 bui.terUniHea.fan.filter.uu[1] = bui.terUniHea.fan.filter.u / 16.528673093224516;
 der(bui.terUniHea.fan.filter.x[1]) = bui.terUniHea.fan.filter.r[1] * (bui.terUniHea.fan.filter.x[1] - bui.terUniHea.fan.filter.uu[1]);
 der(bui.terUniHea.fan.filter.x[2]) = bui.terUniHea.fan.filter.r[2] * (bui.terUniHea.fan.filter.x[2] - bui.terUniHea.fan.filter.uu[2]);
 if Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.LowPass then
  bui.terUniHea.fan.filter.uu[1 + 1] = bui.terUniHea.fan.filter.x[1];
  bui.terUniHea.fan.filter.uu[2 + 1] = bui.terUniHea.fan.filter.x[2];
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.HighPass then
  bui.terUniHea.fan.filter.uu[1 + 1] = - bui.terUniHea.fan.filter.x[1] + bui.terUniHea.fan.filter.uu[1];
  bui.terUniHea.fan.filter.uu[2 + 1] = - bui.terUniHea.fan.filter.x[2] + bui.terUniHea.fan.filter.uu[2];
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.BandPass then
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.BandStop then
 else
  assert(false, "filterType (= " + String(Modelica.Blocks.Types.FilterType.LowPass) + ") is unknown");
  bui.terUniHea.fan.filter.uu[1:3] = zeros(2 + 1);
 end if;
 bui.terUniHea.fan.filter.y = bui.terUniHea.fan.filter.gain * 16.528673093224516 * bui.terUniHea.fan.filter.uu[2 + 1];
 if true then
  bui.terUniHea.fan.preSou.m_flow = bui.terUniHea.fan.preSou.m_flow_internal;
 else
  bui.terUniHea.fan.preSou.m_flow_internal = 0;
 end if;
 if false then
  bui.terUniHea.fan.preSou.dp = bui.terUniHea.fan.preSou.dp_internal;
 else
  bui.terUniHea.fan.preSou.dp_internal = 0;
 end if;
 bui.terUniHea.fan.preSou.port_a.h_outflow = inStream(bui.terUniHea.fan.preSou.port_b.h_outflow);
 bui.terUniHea.fan.preSou.port_b.h_outflow = inStream(bui.terUniHea.fan.preSou.port_a.h_outflow);
 bui.terUniHea.fan.preSou.dp = bui.terUniHea.fan.preSou.port_a.p - bui.terUniHea.fan.preSou.port_b.p;
 bui.terUniHea.fan.preSou.m_flow = bui.terUniHea.fan.preSou.port_a.m_flow;
 assert(bui.terUniHea.fan.preSou.m_flow > -0.0016528673093224517 or true, "Reverting flow occurs even though allowFlowReversal is false");
 bui.terUniHea.fan.preSou.port_a.m_flow + bui.terUniHea.fan.preSou.port_b.m_flow = 0;
 bui.terUniHea.fan.preSou.port_a.Xi_outflow[1:1] = inStream(bui.terUniHea.fan.preSou.port_b.Xi_outflow[1:1]);
 bui.terUniHea.fan.preSou.port_b.Xi_outflow[1:1] = inStream(bui.terUniHea.fan.preSou.port_a.Xi_outflow[1:1]);
 bui.terUniHea.fan.preSou.port_a.C_outflow[1:0] = inStream(bui.terUniHea.fan.preSou.port_b.C_outflow[1:0]);
 bui.terUniHea.fan.preSou.port_b.C_outflow[1:0] = inStream(bui.terUniHea.fan.preSou.port_a.C_outflow[1:0]);
 bui.terUniHea.fan.heaDis.etaHyd * bui.terUniHea.fan.heaDis.WHyd = bui.terUniHea.fan.heaDis.WFlo;
 bui.terUniHea.fan.heaDis.QThe_flow + bui.terUniHea.fan.heaDis.WFlo = if bui.terUniHea.fan.heaDis.motorCooledByFluid then bui.terUniHea.fan.heaDis.PEle else bui.terUniHea.fan.heaDis.WHyd;
 bui.terUniHea.fan.heaDis.Q_flow = Buildings.Utilities.Math.Functions.regStep(noEvent(abs(bui.terUniHea.fan.heaDis.V_flow)) - 2 * 0.013773894244353765, bui.terUniHea.fan.heaDis.QThe_flow, 0, 0.013773894244353765);
 bui.terUniHea.fan.PToMed.y = bui.terUniHea.fan.PToMed.u1 + bui.terUniHea.fan.PToMed.u2;
 bui.terUniHea.fan.prePow.port.Q_flow = (- bui.terUniHea.fan.prePow.Q_flow) * 1;
 bui.terUniHea.fan.senMasFlo.m_flow = bui.terUniHea.fan.senMasFlo.port_a.m_flow;
 bui.terUniHea.fan.senMasFlo.port_b.m_flow = - bui.terUniHea.fan.senMasFlo.port_a.m_flow;
 bui.terUniHea.fan.senMasFlo.port_a.p = bui.terUniHea.fan.senMasFlo.port_b.p;
 bui.terUniHea.fan.senMasFlo.port_a.h_outflow = inStream(bui.terUniHea.fan.senMasFlo.port_b.h_outflow);
 bui.terUniHea.fan.senMasFlo.port_b.h_outflow = inStream(bui.terUniHea.fan.senMasFlo.port_a.h_outflow);
 bui.terUniHea.fan.senMasFlo.port_a.Xi_outflow[1:1] = inStream(bui.terUniHea.fan.senMasFlo.port_b.Xi_outflow[1:1]);
 bui.terUniHea.fan.senMasFlo.port_b.Xi_outflow[1:1] = inStream(bui.terUniHea.fan.senMasFlo.port_a.Xi_outflow[1:1]);
 bui.terUniHea.fan.senMasFlo.port_a.C_outflow[1:0] = inStream(bui.terUniHea.fan.senMasFlo.port_b.C_outflow[1:0]);
 bui.terUniHea.fan.senMasFlo.port_b.C_outflow[1:0] = inStream(bui.terUniHea.fan.senMasFlo.port_a.C_outflow[1:0]);
 bui.terUniHea.fan.senRelPre.port_a.m_flow = 0;
 bui.terUniHea.fan.senRelPre.port_b.m_flow = 0;
 bui.terUniHea.fan.senRelPre.port_a.h_outflow = 0;
 bui.terUniHea.fan.senRelPre.port_b.h_outflow = 0;
 bui.terUniHea.fan.senRelPre.port_a.Xi_outflow[1:1] = zeros(1);
 bui.terUniHea.fan.senRelPre.port_b.Xi_outflow[1:1] = zeros(1);
 bui.terUniHea.fan.senRelPre.port_a.C_outflow[1:0] = zeros(0);
 bui.terUniHea.fan.senRelPre.port_b.C_outflow[1:0] = zeros(0);
 bui.terUniHea.fan.senRelPre.p_rel = bui.terUniHea.fan.senRelPre.port_a.p - bui.terUniHea.fan.senRelPre.port_b.p;
 bui.terUniHea.fan.eff.y_out = bui.terUniHea.fan.eff.r_N;
 bui.terUniHea.fan.eff.V_flow = bui.terUniHea.fan.eff.m_flow / bui.terUniHea.fan.eff.rho;
 bui.terUniHea.fan.eff.r_V = bui.terUniHea.fan.eff.V_flow / 13.773894244353764;
 if false == false and Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate <> Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed then
  bui.terUniHea.fan.eff.r_N = 1;
 else
  if 1 == 1 then
   if true then
    bui.terUniHea.fan.eff.V_flow * 0.007260110918957602 + bui.terUniHea.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.r_N, bui.terUniHea.fan.eff.preDer1[1:2], 400.0, 13.773894244353764, bui.terUniHea.fan.eff.pCur1);
   else
    bui.terUniHea.fan.eff.V_flow * 0.007260110918957602 + bui.terUniHea.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.r_N, bui.terUniHea.fan.eff.preDer1[1:2], 400.0, 13.773894244353764, bui.terUniHea.fan.eff.pCur1);
   end if;
  elseif 1 == 2 then
   if true then
    bui.terUniHea.fan.eff.V_flow * 0.007260110918957602 + bui.terUniHea.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.r_N, bui.terUniHea.fan.eff.preDer2[1:3], 400.0, 13.773894244353764, bui.terUniHea.fan.eff.pCur2);
   else
    bui.terUniHea.fan.eff.V_flow * 0.007260110918957602 + bui.terUniHea.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.r_N, bui.terUniHea.fan.eff.preDer2[1:3], 400.0, 13.773894244353764, bui.terUniHea.fan.eff.pCur2);
   end if;
  else
   if true then
    bui.terUniHea.fan.eff.V_flow * 0.007260110918957602 + bui.terUniHea.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.r_N, bui.terUniHea.fan.eff.preDer3[1:4], 400.0, 13.773894244353764, bui.terUniHea.fan.eff.pCur3);
   else
    bui.terUniHea.fan.eff.V_flow * 0.007260110918957602 + bui.terUniHea.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.r_N, bui.terUniHea.fan.eff.preDer3[1:4], 400.0, 13.773894244353764, bui.terUniHea.fan.eff.pCur3);
   end if;
  end if;
 end if;
 bui.terUniHea.fan.eff.WFlo = bui.terUniHea.fan.eff.dp_internal * bui.terUniHea.fan.eff.V_flow;
 if false then
  if true then
   bui.terUniHea.fan.eff.PEle = Buildings.Fluid.Movers.BaseClasses.Characteristics.power(bui.terUniHea.fan.eff.per.power, bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.r_N, bui.terUniHea.fan.eff.powDer[1:1], 0.05);
  else
   bui.terUniHea.fan.eff.PEle = bui.terUniHea.fan.eff.rho / 1.2 * Buildings.Fluid.Movers.BaseClasses.Characteristics.power(bui.terUniHea.fan.eff.per.power, bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.r_N, bui.terUniHea.fan.eff.powDer[1:1], 0.05);
  end if;
  bui.terUniHea.fan.eff.eta = bui.terUniHea.fan.eff.WFlo / Buildings.Utilities.Math.Functions.smoothMax(bui.terUniHea.fan.eff.PEle, 1.0E-5, 1.0E-6);
  bui.terUniHea.fan.eff.etaHyd = 1;
  bui.terUniHea.fan.eff.etaMot = bui.terUniHea.fan.eff.eta;
 else
  if true then
   bui.terUniHea.fan.eff.etaHyd = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(bui.terUniHea.fan.eff.per.hydraulicEfficiency, bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.hydDer[1:1], bui.terUniHea.fan.eff.r_N, 0.05);
   bui.terUniHea.fan.eff.etaMot = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(bui.terUniHea.fan.eff.per.motorEfficiency, bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.motDer[1:1], bui.terUniHea.fan.eff.r_N, 0.05);
  else
   bui.terUniHea.fan.eff.etaHyd = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(bui.terUniHea.fan.eff.per.hydraulicEfficiency, bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.hydDer[1:1], bui.terUniHea.fan.eff.r_N, 0.05);
   bui.terUniHea.fan.eff.etaMot = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(bui.terUniHea.fan.eff.per.motorEfficiency, bui.terUniHea.fan.eff.V_flow, bui.terUniHea.fan.eff.motDer[1:1], bui.terUniHea.fan.eff.r_N, 0.05);
  end if;
  bui.terUniHea.fan.eff.PEle = bui.terUniHea.fan.eff.WFlo / Buildings.Utilities.Math.Functions.smoothMax(bui.terUniHea.fan.eff.eta, 1.0E-5, 1.0E-6);
  bui.terUniHea.fan.eff.eta = bui.terUniHea.fan.eff.etaHyd * bui.terUniHea.fan.eff.etaMot;
 end if;
 bui.terUniHea.con.controlError.y = bui.terUniHea.con.controlError.u1 - bui.terUniHea.con.controlError.u2;
 der(bui.terUniHea.con.I.y) = bui.terUniHea.con.I.k * bui.terUniHea.con.I.u;
 if Buildings.Controls.OBC.CDL.Types.Reset.Disabled <> Buildings.Controls.OBC.CDL.Types.Reset.Input then
  bui.terUniHea.con.I.y_reset_internal = bui.terUniHea.con.I.y_reset;
 end if;
 if Buildings.Controls.OBC.CDL.Types.Reset.Disabled == Buildings.Controls.OBC.CDL.Types.Reset.Disabled then
  bui.terUniHea.con.I.trigger_internal = false;
 else
  when bui.terUniHea.con.I.trigger_internal then
   reinit(bui.terUniHea.con.I.y, bui.terUniHea.con.I.y_reset_internal);
  end when;
 end if;
 bui.terUniHea.con.errP.y = bui.terUniHea.con.errP.u1 - bui.terUniHea.con.errP.u2;
 bui.terUniHea.con.errI1.y = bui.terUniHea.con.errI1.u1 - bui.terUniHea.con.errI1.u2;
 bui.terUniHea.con.errI2.y = bui.terUniHea.con.errI2.u1 - bui.terUniHea.con.errI2.u2;
 bui.terUniHea.con.lim.y = smooth(0, noEvent(if bui.terUniHea.con.lim.u > bui.terUniHea.con.lim.uMax then bui.terUniHea.con.lim.uMax elseif bui.terUniHea.con.lim.u < bui.terUniHea.con.lim.uMin then bui.terUniHea.con.lim.uMin else bui.terUniHea.con.lim.u));
 bui.terUniHea.con.Dzero.y = 0.0;
 bui.terUniHea.con.uS_revAct.y = bui.terUniHea.con.uS_revAct.k * bui.terUniHea.con.uS_revAct.u;
 bui.terUniHea.con.uSetWp.y = bui.terUniHea.con.uSetWp.k * bui.terUniHea.con.uSetWp.u;
 bui.terUniHea.con.uMea_revAct.y = bui.terUniHea.con.uMea_revAct.k * bui.terUniHea.con.uMea_revAct.u;
 bui.terUniHea.con.addPD.y = bui.terUniHea.con.addPD.u1 + bui.terUniHea.con.addPD.u2;
 bui.terUniHea.con.gainPID.y = bui.terUniHea.con.gainPID.k * bui.terUniHea.con.gainPID.u;
 bui.terUniHea.con.addPID.y = bui.terUniHea.con.addPID.u1 + bui.terUniHea.con.addPID.u2;
 bui.terUniHea.con.antWinErr.y = bui.terUniHea.con.antWinErr.u1 - bui.terUniHea.con.antWinErr.u2;
 bui.terUniHea.con.antWinGai.y = bui.terUniHea.con.antWinGai.k * bui.terUniHea.con.antWinGai.u;
 bui.terUniHea.con.cheYMinMax.y = bui.terUniHea.con.cheYMinMax.k;
 assert(bui.terUniHea.con.assMesYMinMax.u, bui.terUniHea.con.assMesYMinMax.message, AssertionLevel.warning);
 bui.terUniHea.hex.hA.m1_flow = bui.terUniHea.hex.m1_flow;
 bui.terUniHea.hex.hA.m2_flow = bui.terUniHea.hex.m2_flow;
 bui.terUniHea.hex.hA.T_1 = bui.terUniHea.hex.T_in1;
 bui.terUniHea.hex.hA.T_2 = bui.terUniHea.hex.T_in2;
 bui.terUniHea.hex.hA.fm_w = bui.terUniHea.hex.hA.m1_flow / bui.terUniHea.hex.hA.m_flow_nominal_w;
 bui.terUniHea.hex.hA.fm_a = bui.terUniHea.hex.hA.m2_flow / 16.528673093224516;
 bui.terUniHea.hex.hA.x_w = 1;
 bui.terUniHea.hex.hA.x_a = 1;
 if true then
  bui.terUniHea.hex.hA.hA_1 = bui.terUniHea.hex.hA.x_w * bui.terUniHea.hex.hA.hA_nominal_w * Buildings.Utilities.Math.Functions.regNonZeroPower(bui.terUniHea.hex.hA.fm_w, bui.terUniHea.hex.hA.n_w, 0.1);
 else
  bui.terUniHea.hex.hA.hA_1 = bui.terUniHea.hex.hA.x_w * bui.terUniHea.hex.hA.hA_nominal_w;
 end if;
 if true then
  bui.terUniHea.hex.hA.hA_2 = bui.terUniHea.hex.hA.x_a * bui.terUniHea.hex.hA.hA_nominal_a * Buildings.Utilities.Math.Functions.regNonZeroPower(bui.terUniHea.hex.hA.fm_a, bui.terUniHea.hex.hA.n_a, 0.1);
 else
  bui.terUniHea.hex.hA.hA_2 = bui.terUniHea.hex.hA.x_a * bui.terUniHea.hex.hA.hA_nominal_a;
 end if;
 if Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.ParallelFlow then
  bui.terUniHea.hex.flowRegime = if bui.terUniHea.hex.C1_flow * bui.terUniHea.hex.C2_flow >= 0 then Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow else Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow then
  bui.terUniHea.hex.flowRegime = if bui.terUniHea.hex.C1_flow * bui.terUniHea.hex.C2_flow >= 0 then Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow else Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowUnmixed then
  bui.terUniHea.hex.flowRegime = Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1MixedStream2Unmixed then
  bui.terUniHea.hex.flowRegime = if bui.terUniHea.hex.C1_flow < bui.terUniHea.hex.C2_flow then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed;
 else
  bui.terUniHea.hex.flowRegime = if bui.terUniHea.hex.C1_flow < bui.terUniHea.hex.C2_flow then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed;
 end if;
 bui.terUniHea.hex.eps = Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C(bui.terUniHea.hex.UA, bui.terUniHea.hex.C1_flow, bui.terUniHea.hex.C2_flow, Integer(bui.terUniHea.hex.flowRegime), bui.terUniHea.hex.CMin_flow_nominal, bui.terUniHea.hex.CMax_flow_nominal, bui.terUniHea.hex.delta);
 if not false then
  bui.terUniHea.hex.bal1.vol.mWat_flow_internal = 0;
 end if;
 if not false then
  bui.terUniHea.hex.bal1.vol.C_flow_internal[1:0] = zeros(0);
 end if;
 bui.terUniHea.hex.bal1.vol.mXi_flow[1:0] = bui.terUniHea.hex.bal1.vol.mWat_flow_internal * fill(0.0, 0);
 if true then
  bui.terUniHea.hex.bal1.vol.m_flowInv = Buildings.Utilities.Math.Functions.inverseXRegularized(bui.terUniHea.hex.bal1.vol.port_a.m_flow, bui.terUniHea.hex.bal1.vol.deltaReg, bui.terUniHea.hex.bal1.vol.deltaInvReg, bui.terUniHea.hex.bal1.vol.aReg, bui.terUniHea.hex.bal1.vol.bReg, bui.terUniHea.hex.bal1.vol.cReg, bui.terUniHea.hex.bal1.vol.dReg, bui.terUniHea.hex.bal1.vol.eReg, bui.terUniHea.hex.bal1.vol.fReg);
 else
  bui.terUniHea.hex.bal1.vol.m_flowInv = 0;
 end if;
 if true then
  assert(noEvent(abs(bui.terUniHea.hex.bal1.vol.Q_flow) < 200.0 * bui.terUniHea.hex.bal1.vol.cp_default * max(bui.terUniHea.hex.bal1.vol.m_flow_small / 1000.0, abs(bui.terUniHea.hex.bal1.vol.m_flow))), "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal1.vol" + ":
   The heat flow rate equals " + String(bui.terUniHea.hex.bal1.vol.Q_flow) + " W and the mass flow rate equals " + String(bui.terUniHea.hex.bal1.vol.m_flow) + " kg/s,
   which results in a temperature difference " + String(abs(bui.terUniHea.hex.bal1.vol.Q_flow) / (bui.terUniHea.hex.bal1.vol.cp_default * max(bui.terUniHea.hex.bal1.vol.m_flow_small / 1000.0, abs(bui.terUniHea.hex.bal1.vol.m_flow)))) + " K > dTMax=" + String(200.0) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
 end if;
 if false then
  bui.terUniHea.hex.bal1.vol.hOut = Buildings.Utilities.Math.Functions.regStep(bui.terUniHea.hex.bal1.vol.port_a.m_flow, bui.terUniHea.hex.bal1.vol.port_b.h_outflow, bui.terUniHea.hex.bal1.vol.port_a.h_outflow, bui.terUniHea.hex.bal1.vol.m_flow_small / 1000.0);
  bui.terUniHea.hex.bal1.vol.XiOut[1:0] = Buildings.Utilities.Math.Functions.regStep(bui.terUniHea.hex.bal1.vol.port_a.m_flow, bui.terUniHea.hex.bal1.vol.port_b.Xi_outflow[1:0], bui.terUniHea.hex.bal1.vol.port_a.Xi_outflow[1:0], bui.terUniHea.hex.bal1.vol.m_flow_small / 1000.0);
  bui.terUniHea.hex.bal1.vol.COut[1:0] = Buildings.Utilities.Math.Functions.regStep(bui.terUniHea.hex.bal1.vol.port_a.m_flow, bui.terUniHea.hex.bal1.vol.port_b.C_outflow[1:0], bui.terUniHea.hex.bal1.vol.port_a.C_outflow[1:0], bui.terUniHea.hex.bal1.vol.m_flow_small / 1000.0);
 else
  bui.terUniHea.hex.bal1.vol.hOut = bui.terUniHea.hex.bal1.vol.port_b.h_outflow;
  bui.terUniHea.hex.bal1.vol.XiOut[1:0] = bui.terUniHea.hex.bal1.vol.port_b.Xi_outflow[1:0];
  bui.terUniHea.hex.bal1.vol.COut[1:0] = bui.terUniHea.hex.bal1.vol.port_b.C_outflow[1:0];
 end if;
 bui.terUniHea.hex.bal1.vol.port_a.m_flow + bui.terUniHea.hex.bal1.vol.port_b.m_flow = 0;
 if true then
  bui.terUniHea.hex.bal1.vol.port_b.Xi_outflow[1:0] = inStream(bui.terUniHea.hex.bal1.vol.port_a.Xi_outflow[1:0]) + bui.terUniHea.hex.bal1.vol.mXi_flow[1:0] * bui.terUniHea.hex.bal1.vol.m_flowInv;
 else
  assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal1.vol" + ": Wrong implementation for forward flow.");
  bui.terUniHea.hex.bal1.vol.port_b.Xi_outflow[1:0] = inStream(bui.terUniHea.hex.bal1.vol.port_a.Xi_outflow[1:0]);
 end if;
 if false then
  if true then
   bui.terUniHea.hex.bal1.vol.port_a.Xi_outflow[1:0] = inStream(bui.terUniHea.hex.bal1.vol.port_b.Xi_outflow[1:0]) - bui.terUniHea.hex.bal1.vol.mXi_flow[1:0] * bui.terUniHea.hex.bal1.vol.m_flowInv;
  else
   assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal1.vol" + ": Wrong implementation for reverse flow.");
   bui.terUniHea.hex.bal1.vol.port_a.Xi_outflow[1:0] = inStream(bui.terUniHea.hex.bal1.vol.port_b.Xi_outflow[1:0]);
  end if;
 else
  bui.terUniHea.hex.bal1.vol.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 end if;
 if true then
  bui.terUniHea.hex.bal1.vol.port_b.h_outflow = inStream(bui.terUniHea.hex.bal1.vol.port_a.h_outflow) + bui.terUniHea.hex.bal1.vol.Q_flow * bui.terUniHea.hex.bal1.vol.m_flowInv;
  if false then
   bui.terUniHea.hex.bal1.vol.port_a.h_outflow = inStream(bui.terUniHea.hex.bal1.vol.port_b.h_outflow) - bui.terUniHea.hex.bal1.vol.Q_flow * bui.terUniHea.hex.bal1.vol.m_flowInv;
  else
   bui.terUniHea.hex.bal1.vol.port_a.h_outflow = 83680.0;
  end if;
 else
  bui.terUniHea.hex.bal1.vol.port_a.m_flow * (inStream(bui.terUniHea.hex.bal1.vol.port_a.h_outflow) - bui.terUniHea.hex.bal1.vol.port_b.h_outflow) = - bui.terUniHea.hex.bal1.vol.Q_flow;
  if false then
   bui.terUniHea.hex.bal1.vol.port_a.m_flow * (inStream(bui.terUniHea.hex.bal1.vol.port_b.h_outflow) - bui.terUniHea.hex.bal1.vol.port_a.h_outflow) = bui.terUniHea.hex.bal1.vol.Q_flow;
  else
   bui.terUniHea.hex.bal1.vol.port_a.h_outflow = 83680.0;
  end if;
 end if;
 if true and false then
  bui.terUniHea.hex.bal1.vol.port_b.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal1.vol.port_a.C_outflow[1:0]) + bui.terUniHea.hex.bal1.vol.C_flow_internal[1:0] * bui.terUniHea.hex.bal1.vol.m_flowInv;
 else
  assert(not false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal1.vol" + ": Wrong implementation of trace substance balance for forward flow.");
  bui.terUniHea.hex.bal1.vol.port_b.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal1.vol.port_a.C_outflow[1:0]);
 end if;
 if false then
  if false then
   bui.terUniHea.hex.bal1.vol.port_a.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal1.vol.port_b.C_outflow[1:0]) - bui.terUniHea.hex.bal1.vol.C_flow_internal[1:0] * bui.terUniHea.hex.bal1.vol.m_flowInv;
  else
   bui.terUniHea.hex.bal1.vol.port_a.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal1.vol.port_b.C_outflow[1:0]);
  end if;
 else
  bui.terUniHea.hex.bal1.vol.port_a.C_outflow[1:0] = zeros(0);
 end if;
 bui.terUniHea.hex.bal1.vol.port_a.p = bui.terUniHea.hex.bal1.vol.port_b.p;
 if false then
  if false then
   if false then
    bui.terUniHea.hex.bal1.preDro.m_flow = bui.terUniHea.hex.bal1.preDro.dp * bui.terUniHea.hex.bal1.preDro.coeff;
   else
    bui.terUniHea.hex.bal1.preDro.dp = bui.terUniHea.hex.bal1.preDro.m_flow * bui.terUniHea.hex.bal1.preDro.coeff;
   end if;
  else
   if true then
    if false then
     bui.terUniHea.hex.bal1.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.terUniHea.hex.bal1.preDro.dp, bui.terUniHea.hex.bal1.preDro.k, bui.terUniHea.hex.bal1.preDro.m_flow_turbulent);
    else
     bui.terUniHea.hex.bal1.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.terUniHea.hex.bal1.preDro.m_flow, bui.terUniHea.hex.bal1.preDro.k, bui.terUniHea.hex.bal1.preDro.m_flow_turbulent);
    end if;
   else
    if false then
     bui.terUniHea.hex.bal1.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.terUniHea.hex.bal1.preDro.dp, bui.terUniHea.hex.bal1.preDro.k, bui.terUniHea.hex.bal1.preDro.m_flow_turbulent);
    else
     bui.terUniHea.hex.bal1.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.terUniHea.hex.bal1.preDro.m_flow, bui.terUniHea.hex.bal1.preDro.k, bui.terUniHea.hex.bal1.preDro.m_flow_turbulent);
    end if;
   end if;
  end if;
 else
  bui.terUniHea.hex.bal1.preDro.dp = 0;
 end if;
 bui.terUniHea.hex.bal1.preDro.port_a.h_outflow = 83680.0;
 bui.terUniHea.hex.bal1.preDro.port_b.h_outflow = inStream(bui.terUniHea.hex.bal1.preDro.port_a.h_outflow);
 bui.terUniHea.hex.bal1.preDro.port_a.m_flow + bui.terUniHea.hex.bal1.preDro.port_b.m_flow = 0;
 bui.terUniHea.hex.bal1.preDro.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 bui.terUniHea.hex.bal1.preDro.port_b.Xi_outflow[1:0] = inStream(bui.terUniHea.hex.bal1.preDro.port_a.Xi_outflow[1:0]);
 bui.terUniHea.hex.bal1.preDro.port_a.C_outflow[1:0] = zeros(0);
 bui.terUniHea.hex.bal1.preDro.port_b.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal1.preDro.port_a.C_outflow[1:0]);
 if not false then
  bui.terUniHea.hex.bal2.vol.mWat_flow_internal = 0;
 end if;
 if not false then
  bui.terUniHea.hex.bal2.vol.C_flow_internal[1:0] = zeros(0);
 end if;
 bui.terUniHea.hex.bal2.vol.mXi_flow[1:1] = bui.terUniHea.hex.bal2.vol.mWat_flow_internal * {1.0};
 if true then
  bui.terUniHea.hex.bal2.vol.m_flowInv = Buildings.Utilities.Math.Functions.inverseXRegularized(bui.terUniHea.hex.bal2.vol.port_a.m_flow, 1.6528673093224517E-6, 605009.2432464666, -9075138.648697, 4.3558305945225805E13, -7.994535425078913E19, 7.154664875226009E25, -3.080304466479727E31, 5.100413634744618E36);
 else
  bui.terUniHea.hex.bal2.vol.m_flowInv = 0;
 end if;
 if true then
  assert(noEvent(abs(bui.terUniHea.hex.bal2.vol.Q_flow) < 200.0 * bui.terUniHea.hex.bal2.vol.cp_default * max(0.0016528673093224517 / 1000.0, abs(bui.terUniHea.hex.bal2.vol.m_flow))), "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal2.vol" + ":
   The heat flow rate equals " + String(bui.terUniHea.hex.bal2.vol.Q_flow) + " W and the mass flow rate equals " + String(bui.terUniHea.hex.bal2.vol.m_flow) + " kg/s,
   which results in a temperature difference " + String(abs(bui.terUniHea.hex.bal2.vol.Q_flow) / (bui.terUniHea.hex.bal2.vol.cp_default * max(0.0016528673093224517 / 1000.0, abs(bui.terUniHea.hex.bal2.vol.m_flow)))) + " K > dTMax=" + String(200.0) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
 end if;
 if true then
  bui.terUniHea.hex.bal2.vol.hOut = Buildings.Utilities.Math.Functions.regStep(bui.terUniHea.hex.bal2.vol.port_a.m_flow, bui.terUniHea.hex.bal2.vol.port_b.h_outflow, bui.terUniHea.hex.bal2.vol.port_a.h_outflow, 0.0016528673093224517 / 1000.0);
  bui.terUniHea.hex.bal2.vol.XiOut[1:1] = Buildings.Utilities.Math.Functions.regStep(bui.terUniHea.hex.bal2.vol.port_a.m_flow, bui.terUniHea.hex.bal2.vol.port_b.Xi_outflow[1:1], bui.terUniHea.hex.bal2.vol.port_a.Xi_outflow[1:1], 0.0016528673093224517 / 1000.0);
  bui.terUniHea.hex.bal2.vol.COut[1:0] = Buildings.Utilities.Math.Functions.regStep(bui.terUniHea.hex.bal2.vol.port_a.m_flow, bui.terUniHea.hex.bal2.vol.port_b.C_outflow[1:0], bui.terUniHea.hex.bal2.vol.port_a.C_outflow[1:0], 0.0016528673093224517 / 1000.0);
 else
  bui.terUniHea.hex.bal2.vol.hOut = bui.terUniHea.hex.bal2.vol.port_b.h_outflow;
  bui.terUniHea.hex.bal2.vol.XiOut[1:1] = bui.terUniHea.hex.bal2.vol.port_b.Xi_outflow[1:1];
  bui.terUniHea.hex.bal2.vol.COut[1:0] = bui.terUniHea.hex.bal2.vol.port_b.C_outflow[1:0];
 end if;
 bui.terUniHea.hex.bal2.vol.port_a.m_flow + bui.terUniHea.hex.bal2.vol.port_b.m_flow = 0;
 if true then
  bui.terUniHea.hex.bal2.vol.port_b.Xi_outflow[1:1] = inStream(bui.terUniHea.hex.bal2.vol.port_a.Xi_outflow[1:1]) + bui.terUniHea.hex.bal2.vol.mXi_flow[1:1] * bui.terUniHea.hex.bal2.vol.m_flowInv;
 else
  assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal2.vol" + ": Wrong implementation for forward flow.");
  bui.terUniHea.hex.bal2.vol.port_b.Xi_outflow[1:1] = inStream(bui.terUniHea.hex.bal2.vol.port_a.Xi_outflow[1:1]);
 end if;
 if true then
  if true then
   bui.terUniHea.hex.bal2.vol.port_a.Xi_outflow[1:1] = inStream(bui.terUniHea.hex.bal2.vol.port_b.Xi_outflow[1:1]) - bui.terUniHea.hex.bal2.vol.mXi_flow[1:1] * bui.terUniHea.hex.bal2.vol.m_flowInv;
  else
   assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal2.vol" + ": Wrong implementation for reverse flow.");
   bui.terUniHea.hex.bal2.vol.port_a.Xi_outflow[1:1] = inStream(bui.terUniHea.hex.bal2.vol.port_b.Xi_outflow[1:1]);
  end if;
 else
  bui.terUniHea.hex.bal2.vol.port_a.Xi_outflow[1:1] = {0.01};
 end if;
 if true then
  bui.terUniHea.hex.bal2.vol.port_b.h_outflow = inStream(bui.terUniHea.hex.bal2.vol.port_a.h_outflow) + bui.terUniHea.hex.bal2.vol.Q_flow * bui.terUniHea.hex.bal2.vol.m_flowInv;
  if true then
   bui.terUniHea.hex.bal2.vol.port_a.h_outflow = inStream(bui.terUniHea.hex.bal2.vol.port_b.h_outflow) - bui.terUniHea.hex.bal2.vol.Q_flow * bui.terUniHea.hex.bal2.vol.m_flowInv;
  else
   bui.terUniHea.hex.bal2.vol.port_a.h_outflow = 45300.945;
  end if;
 else
  bui.terUniHea.hex.bal2.vol.port_a.m_flow * (inStream(bui.terUniHea.hex.bal2.vol.port_a.h_outflow) - bui.terUniHea.hex.bal2.vol.port_b.h_outflow) = - bui.terUniHea.hex.bal2.vol.Q_flow;
  if true then
   bui.terUniHea.hex.bal2.vol.port_a.m_flow * (inStream(bui.terUniHea.hex.bal2.vol.port_b.h_outflow) - bui.terUniHea.hex.bal2.vol.port_a.h_outflow) = bui.terUniHea.hex.bal2.vol.Q_flow;
  else
   bui.terUniHea.hex.bal2.vol.port_a.h_outflow = 45300.945;
  end if;
 end if;
 if true and false then
  bui.terUniHea.hex.bal2.vol.port_b.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal2.vol.port_a.C_outflow[1:0]) + bui.terUniHea.hex.bal2.vol.C_flow_internal[1:0] * bui.terUniHea.hex.bal2.vol.m_flowInv;
 else
  assert(not false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.hex.bal2.vol" + ": Wrong implementation of trace substance balance for forward flow.");
  bui.terUniHea.hex.bal2.vol.port_b.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal2.vol.port_a.C_outflow[1:0]);
 end if;
 if true then
  if false then
   bui.terUniHea.hex.bal2.vol.port_a.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal2.vol.port_b.C_outflow[1:0]) - bui.terUniHea.hex.bal2.vol.C_flow_internal[1:0] * bui.terUniHea.hex.bal2.vol.m_flowInv;
  else
   bui.terUniHea.hex.bal2.vol.port_a.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal2.vol.port_b.C_outflow[1:0]);
  end if;
 else
  bui.terUniHea.hex.bal2.vol.port_a.C_outflow[1:0] = zeros(0);
 end if;
 bui.terUniHea.hex.bal2.vol.port_a.p = bui.terUniHea.hex.bal2.vol.port_b.p;
 if true then
  if false then
   if false then
    bui.terUniHea.hex.bal2.preDro.m_flow = bui.terUniHea.hex.bal2.preDro.dp * bui.terUniHea.hex.bal2.preDro.coeff;
   else
    bui.terUniHea.hex.bal2.preDro.dp = bui.terUniHea.hex.bal2.preDro.m_flow * bui.terUniHea.hex.bal2.preDro.coeff;
   end if;
  else
   if true then
    if false then
     bui.terUniHea.hex.bal2.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.terUniHea.hex.bal2.preDro.dp, bui.terUniHea.hex.bal2.preDro.k, 1.6528673093224517);
    else
     bui.terUniHea.hex.bal2.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.terUniHea.hex.bal2.preDro.m_flow, bui.terUniHea.hex.bal2.preDro.k, 1.6528673093224517);
    end if;
   else
    if false then
     bui.terUniHea.hex.bal2.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.terUniHea.hex.bal2.preDro.dp, bui.terUniHea.hex.bal2.preDro.k, 1.6528673093224517);
    else
     bui.terUniHea.hex.bal2.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.terUniHea.hex.bal2.preDro.m_flow, bui.terUniHea.hex.bal2.preDro.k, 1.6528673093224517);
    end if;
   end if;
  end if;
 else
  bui.terUniHea.hex.bal2.preDro.dp = 0;
 end if;
 bui.terUniHea.hex.bal2.preDro.port_a.h_outflow = inStream(bui.terUniHea.hex.bal2.preDro.port_b.h_outflow);
 bui.terUniHea.hex.bal2.preDro.port_b.h_outflow = inStream(bui.terUniHea.hex.bal2.preDro.port_a.h_outflow);
 bui.terUniHea.hex.bal2.preDro.port_a.m_flow + bui.terUniHea.hex.bal2.preDro.port_b.m_flow = 0;
 bui.terUniHea.hex.bal2.preDro.port_a.Xi_outflow[1:1] = inStream(bui.terUniHea.hex.bal2.preDro.port_b.Xi_outflow[1:1]);
 bui.terUniHea.hex.bal2.preDro.port_b.Xi_outflow[1:1] = inStream(bui.terUniHea.hex.bal2.preDro.port_a.Xi_outflow[1:1]);
 bui.terUniHea.hex.bal2.preDro.port_a.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal2.preDro.port_b.C_outflow[1:0]);
 bui.terUniHea.hex.bal2.preDro.port_b.C_outflow[1:0] = inStream(bui.terUniHea.hex.bal2.preDro.port_a.C_outflow[1:0]);
 bui.terUniHea.gaiMasFlo.y = bui.terUniHea.gaiMasFlo.k * bui.terUniHea.gaiMasFlo.u;
 bui.terUniHea.gaiFloNom2.y = 16.528673093224516 * bui.terUniHea.gaiFloNom2.u;
 if false then
  if false then
   assert(bui.terUniHea.sinAir.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.sinAir" + ": The value of p_in=" + String(bui.terUniHea.sinAir.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if true then
   assert(bui.terUniHea.sinAir.p_in_internal > 50000.0 and bui.terUniHea.sinAir.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.sinAir" + ": The value of p_in=" + String(bui.terUniHea.sinAir.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 if not false then
  bui.terUniHea.sinAir.p_in_internal = bui.terUniHea.sinAir.p;
 end if;
 bui.terUniHea.sinAir.ports[1].p = bui.terUniHea.sinAir.p_in_internal;
 if not false then
  bui.terUniHea.sinAir.T_in_internal = bui.terUniHea.sinAir.T;
 end if;
 bui.terUniHea.sinAir.ports[1].h_outflow = bui.terUniHea.sinAir.h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("Air", {"water", "air"}, false, true, bui.terUniHea.sinAir.X_in_internal[1:2], "Boundary_pT");
 end if;
 if false then
  bui.terUniHea.sinAir.X_in_internal[1:1] = bui.terUniHea.sinAir.Xi_in_internal[1:1];
  if true then
   bui.terUniHea.sinAir.X_in_internal[2] = 1 - sum(bui.terUniHea.sinAir.Xi_in_internal[1:1]);
  end if;
 elseif false then
  bui.terUniHea.sinAir.X_in_internal[1:1] = bui.terUniHea.sinAir.Xi_in_internal[1:1];
 else
  bui.terUniHea.sinAir.X_in_internal[1:2] = bui.terUniHea.sinAir.X[1:2];
  bui.terUniHea.sinAir.Xi_in_internal[1:1] = bui.terUniHea.sinAir.X[1:1];
 end if;
 if not false then
  bui.terUniHea.sinAir.C_in_internal[1:0] = bui.terUniHea.sinAir.C[1:0];
 end if;
 bui.terUniHea.sinAir.ports[1].Xi_outflow[1:1] = bui.terUniHea.sinAir.Xi_in_internal[1:1];
 bui.terUniHea.sinAir.ports[1].C_outflow[1:0] = bui.terUniHea.sinAir.C_in_internal[1:0];
 if false then
  if false then
   assert(bui.terUniHea.retAir.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.retAir" + ": The value of p_in=" + String(bui.terUniHea.retAir.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if true then
   assert(bui.terUniHea.retAir.p_in_internal > 50000.0 and bui.terUniHea.retAir.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.retAir" + ": The value of p_in=" + String(bui.terUniHea.retAir.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 if not false then
  bui.terUniHea.retAir.p_in_internal = bui.terUniHea.retAir.p;
 end if;
 bui.terUniHea.retAir.ports[1].p = bui.terUniHea.retAir.p_in_internal;
 if not true then
  bui.terUniHea.retAir.T_in_internal = bui.terUniHea.retAir.T;
 end if;
 bui.terUniHea.retAir.ports[1].h_outflow = bui.terUniHea.retAir.h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("Air", {"water", "air"}, false, true, bui.terUniHea.retAir.X_in_internal[1:2], "Boundary_pT");
 end if;
 if false then
  bui.terUniHea.retAir.X_in_internal[1:1] = bui.terUniHea.retAir.Xi_in_internal[1:1];
  if true then
   bui.terUniHea.retAir.X_in_internal[2] = 1 - sum(bui.terUniHea.retAir.Xi_in_internal[1:1]);
  end if;
 elseif false then
  bui.terUniHea.retAir.X_in_internal[1:1] = bui.terUniHea.retAir.Xi_in_internal[1:1];
 else
  bui.terUniHea.retAir.X_in_internal[1:2] = bui.terUniHea.retAir.X[1:2];
  bui.terUniHea.retAir.Xi_in_internal[1:1] = bui.terUniHea.retAir.X[1:1];
 end if;
 if not false then
  bui.terUniHea.retAir.C_in_internal[1:0] = bui.terUniHea.retAir.C[1:0];
 end if;
 bui.terUniHea.retAir.ports[1].Xi_outflow[1:1] = bui.terUniHea.retAir.Xi_in_internal[1:1];
 bui.terUniHea.retAir.ports[1].C_outflow[1:0] = bui.terUniHea.retAir.C_in_internal[1:0];
 der(bui.terUniHea.TLoaODE.TAir) * bui.terUniHea.TLoaODE.tau = (bui.terUniHea.TLoaODE.QAct_flow - bui.terUniHea.TLoaODE.QReq_flow) / bui.terUniHea.TLoaODE.G + bui.terUniHea.TLoaODE.TSet - bui.terUniHea.TLoaODE.TAir;
 assert(bui.terUniHea.TLoaODE.TAir >= 273.15, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniHea.TLoaODE" + ": The computed indoor temperature is below 0°C.");
 bui.terUniHea.gaiHeaFlo.y = 5.963384817222255E-6 * bui.terUniHea.gaiHeaFlo.u;
 bui.terUniHea.gaiHeaFlo1.y = 5.963384817222255E-6 * bui.terUniHea.gaiHeaFlo1.u;
 bui.terUniHea.swi.y = if bui.terUniHea.swi.u2 then bui.terUniHea.swi.u1 else bui.terUniHea.swi.u3;
 bui.terUniHea.one.y = bui.terUniHea.one.k;
 bui.terUniHea.con1.y = bui.terUniHea.con1.k;
 bui.terUniHea.scaQReqHea_flow.y = bui.terUniHea.scaQReqHea_flow.k * bui.terUniHea.scaQReqHea_flow.u;
 bui.terUniHea.scaQActHea_flow.y = bui.terUniHea.scaQActHea_flow.k * bui.terUniHea.scaQActHea_flow.u;
 bui.terUniHea.scaPFan.y = bui.terUniHea.scaPFan.k * bui.terUniHea.scaPFan.u;
 bui.terUniHea.scaMasFloReqHeaWat.y = bui.terUniHea.scaMasFloReqHeaWat.k * bui.terUniHea.scaMasFloReqHeaWat.u;
 bui.terUniHea.scaHeaWatFloInl.port_a.p = bui.terUniHea.scaHeaWatFloInl.port_b.p;
 bui.terUniHea.scaHeaWatFloInl.port_b.m_flow = (- bui.terUniHea.scaHeaWatFloInl.k) * bui.terUniHea.scaHeaWatFloInl.port_a.m_flow;
 bui.terUniHea.scaHeaWatFloInl.port_a.h_outflow = inStream(bui.terUniHea.scaHeaWatFloInl.port_b.h_outflow);
 bui.terUniHea.scaHeaWatFloInl.port_b.h_outflow = inStream(bui.terUniHea.scaHeaWatFloInl.port_a.h_outflow);
 bui.terUniHea.scaHeaWatFloInl.port_a.Xi_outflow[1:0] = inStream(bui.terUniHea.scaHeaWatFloInl.port_b.Xi_outflow[1:0]);
 bui.terUniHea.scaHeaWatFloInl.port_b.Xi_outflow[1:0] = inStream(bui.terUniHea.scaHeaWatFloInl.port_a.Xi_outflow[1:0]);
 bui.terUniHea.scaHeaWatFloInl.port_a.C_outflow[1:0] = inStream(bui.terUniHea.scaHeaWatFloInl.port_b.C_outflow[1:0]);
 bui.terUniHea.scaHeaWatFloInl.port_b.C_outflow[1:0] = inStream(bui.terUniHea.scaHeaWatFloInl.port_a.C_outflow[1:0]);
 bui.terUniHea.scaHeaWatFloOut.port_a.p = bui.terUniHea.scaHeaWatFloOut.port_b.p;
 bui.terUniHea.scaHeaWatFloOut.port_b.m_flow = (- bui.terUniHea.scaHeaWatFloOut.k) * bui.terUniHea.scaHeaWatFloOut.port_a.m_flow;
 bui.terUniHea.scaHeaWatFloOut.port_a.h_outflow = inStream(bui.terUniHea.scaHeaWatFloOut.port_b.h_outflow);
 bui.terUniHea.scaHeaWatFloOut.port_b.h_outflow = inStream(bui.terUniHea.scaHeaWatFloOut.port_a.h_outflow);
 bui.terUniHea.scaHeaWatFloOut.port_a.Xi_outflow[1:0] = inStream(bui.terUniHea.scaHeaWatFloOut.port_b.Xi_outflow[1:0]);
 bui.terUniHea.scaHeaWatFloOut.port_b.Xi_outflow[1:0] = inStream(bui.terUniHea.scaHeaWatFloOut.port_a.Xi_outflow[1:0]);
 bui.terUniHea.scaHeaWatFloOut.port_a.C_outflow[1:0] = inStream(bui.terUniHea.scaHeaWatFloOut.port_b.C_outflow[1:0]);
 bui.terUniHea.scaHeaWatFloOut.port_b.C_outflow[1:0] = inStream(bui.terUniHea.scaHeaWatFloOut.port_a.C_outflow[1:0]);
 assert(bui.disFloHea.mReqTot_flow < 8.015774378585085 + 8.015774378585086E-4, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea" + ": The total required mass flow rate equals " + String(bui.disFloHea.mReqTot_flow) + " kg/s which is higher than the nominal mass
    flow rate value of " + String(8.015774378585085) + " kg/s.", AssertionLevel.error);
 if size(bui.disFloHea.sumMasFloReq.u[1:1], 1) > 0 then
  bui.disFloHea.sumMasFloReq.y = {1.0} * bui.disFloHea.sumMasFloReq.u[1:1];
 else
  bui.disFloHea.sumMasFloReq.y = 0;
 end if;
 if not true then
  bui.disFloHea.sou_m_flow[1].m_flow_in_internal = bui.disFloHea.sou_m_flow[1].m_flow;
 end if;
 bui.disFloHea.sou_m_flow[1].ports[1].p = bui.disFloHea.sou_m_flow[1].p_in_internal;
 sum({bui.disFloHea.sou_m_flow[1].ports[1].m_flow}) = - bui.disFloHea.sou_m_flow[1].m_flow_in_internal;
 if not true then
  bui.disFloHea.sou_m_flow[1].T_in_internal = bui.disFloHea.sou_m_flow[1].T;
 end if;
 bui.disFloHea.sou_m_flow[1].ports[1].h_outflow = bui.disFloHea.sou_m_flow[1].h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, bui.disFloHea.sou_m_flow[1].X_in_internal[1:1], "Boundary_pT");
 end if;
 if false then
  bui.disFloHea.sou_m_flow[1].X_in_internal[1:0] = bui.disFloHea.sou_m_flow[1].Xi_in_internal[1:0];
  if true then
   bui.disFloHea.sou_m_flow[1].X_in_internal[1] = 1 - sum(bui.disFloHea.sou_m_flow[1].Xi_in_internal[1:0]);
  end if;
 elseif false then
  bui.disFloHea.sou_m_flow[1].X_in_internal[1:0] = bui.disFloHea.sou_m_flow[1].Xi_in_internal[1:0];
 else
  bui.disFloHea.sou_m_flow[1].X_in_internal[1:1] = bui.disFloHea.sou_m_flow[1].X[1:1];
  bui.disFloHea.sou_m_flow[1].Xi_in_internal[1:0] = bui.disFloHea.sou_m_flow[1].X[1:0];
 end if;
 if not false then
  bui.disFloHea.sou_m_flow[1].C_in_internal[1:0] = bui.disFloHea.sou_m_flow[1].C[1:0];
 end if;
 bui.disFloHea.sou_m_flow[1].ports[1].Xi_outflow[1:0] = bui.disFloHea.sou_m_flow[1].Xi_in_internal[1:0];
 bui.disFloHea.sou_m_flow[1].ports[1].C_outflow[1:0] = bui.disFloHea.sou_m_flow[1].C_in_internal[1:0];
 if false then
  if true then
   assert(bui.disFloHea.sin.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.sin" + ": The value of p_in=" + String(bui.disFloHea.sin.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if false then
   assert(bui.disFloHea.sin.p_in_internal > 50000.0 and bui.disFloHea.sin.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.sin" + ": The value of p_in=" + String(bui.disFloHea.sin.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 if not false then
  bui.disFloHea.sin.p_in_internal = bui.disFloHea.sin.p;
 end if;
 bui.disFloHea.sin.ports[1].p = bui.disFloHea.sin.p_in_internal;
 if not false then
  bui.disFloHea.sin.T_in_internal = bui.disFloHea.sin.T;
 end if;
 bui.disFloHea.sin.ports[1].h_outflow = bui.disFloHea.sin.h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, bui.disFloHea.sin.X_in_internal[1:1], "Boundary_pT");
 end if;
 if false then
  bui.disFloHea.sin.X_in_internal[1:0] = bui.disFloHea.sin.Xi_in_internal[1:0];
  if true then
   bui.disFloHea.sin.X_in_internal[1] = 1 - sum(bui.disFloHea.sin.Xi_in_internal[1:0]);
  end if;
 elseif false then
  bui.disFloHea.sin.X_in_internal[1:0] = bui.disFloHea.sin.Xi_in_internal[1:0];
 else
  bui.disFloHea.sin.X_in_internal[1:1] = bui.disFloHea.sin.X[1:1];
  bui.disFloHea.sin.Xi_in_internal[1:0] = bui.disFloHea.sin.X[1:0];
 end if;
 if not false then
  bui.disFloHea.sin.C_in_internal[1:0] = bui.disFloHea.sin.C[1:0];
 end if;
 bui.disFloHea.sin.ports[1].Xi_outflow[1:0] = bui.disFloHea.sin.Xi_in_internal[1:0];
 bui.disFloHea.sin.ports[1].C_outflow[1:0] = bui.disFloHea.sin.C_in_internal[1:0];
 if size(bui.disFloHea.Q_flowSum.u[1:1], 1) > 0 then
  bui.disFloHea.Q_flowSum.y = bui.disFloHea.Q_flowSum.k[1:1] * bui.disFloHea.Q_flowSum.u[1:1];
 else
  bui.disFloHea.Q_flowSum.y = 0;
 end if;
 if false then
  bui.disFloHea.pipPre.m_flow = bui.disFloHea.pipPre.m_flow_internal;
 else
  bui.disFloHea.pipPre.m_flow_internal = 0;
 end if;
 if true then
  bui.disFloHea.pipPre.dp = bui.disFloHea.pipPre.dp_internal;
 else
  bui.disFloHea.pipPre.dp_internal = 0;
 end if;
 bui.disFloHea.pipPre.port_a.h_outflow = 83680.0;
 bui.disFloHea.pipPre.port_b.h_outflow = inStream(bui.disFloHea.pipPre.port_a.h_outflow);
 bui.disFloHea.pipPre.dp = bui.disFloHea.pipPre.port_a.p - bui.disFloHea.pipPre.port_b.p;
 bui.disFloHea.pipPre.m_flow = bui.disFloHea.pipPre.port_a.m_flow;
 assert(bui.disFloHea.pipPre.m_flow > -8.015774378585086E-4 or false, "Reverting flow occurs even though allowFlowReversal is false");
 bui.disFloHea.pipPre.port_a.m_flow + bui.disFloHea.pipPre.port_b.m_flow = 0;
 bui.disFloHea.pipPre.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 bui.disFloHea.pipPre.port_b.Xi_outflow[1:0] = inStream(bui.disFloHea.pipPre.port_a.Xi_outflow[1:0]);
 bui.disFloHea.pipPre.port_a.C_outflow[1:0] = zeros(0);
 bui.disFloHea.pipPre.port_b.C_outflow[1:0] = inStream(bui.disFloHea.pipPre.port_a.C_outflow[1:0]);
 bui.disFloHea.heaCoo.preHea.port.Q_flow = (- bui.disFloHea.heaCoo.preHea.Q_flow) * 1;
 bui.disFloHea.heaCoo.gai.y = - bui.disFloHea.heaCoo.gai.u;
 if not false then
  assert(bui.disFloHea.heaCoo.vol.ports[1].m_flow > -8.015774378585086E-4, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol" + ": Model has flow reversal,
  but the parameter allowFlowReversal is set to false.
  m_flow_small    = " + String(8.015774378585086E-4) + "
  ports[1].m_flow = " + String(bui.disFloHea.heaCoo.vol.ports[1].m_flow) + "
");
 end if;
 if false then
  bui.disFloHea.heaCoo.vol.U = 0;
  bui.disFloHea.heaCoo.vol.mXi[1:0] = zeros(0);
  bui.disFloHea.heaCoo.vol.m = 0;
  bui.disFloHea.heaCoo.vol.mC[1:0] = zeros(0);
 end if;
 if not false then
  bui.disFloHea.heaCoo.vol.dynBal.mWat_flow_internal = 0;
 end if;
 if not false then
  bui.disFloHea.heaCoo.vol.dynBal.C_flow_internal[1:0] = zeros(0);
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  bui.disFloHea.heaCoo.vol.dynBal.m = bui.disFloHea.heaCoo.vol.dynBal.fluidVolume * bui.disFloHea.heaCoo.vol.dynBal.rho_start;
 else
  if false then
   bui.disFloHea.heaCoo.vol.dynBal.m = bui.disFloHea.heaCoo.vol.dynBal.fluidVolume * Buildings.Media.Water.density(Buildings.Media.Water.setState_phX(bui.disFloHea.heaCoo.vol.dynBal.medium.p, bui.disFloHea.heaCoo.vol.dynBal.hOut, {1.0}));
  else
   bui.disFloHea.heaCoo.vol.dynBal.m = bui.disFloHea.heaCoo.vol.dynBal.fluidVolume * bui.disFloHea.heaCoo.vol.dynBal.medium.d;
  end if;
 end if;
 bui.disFloHea.heaCoo.vol.dynBal.mXi[1:0] = bui.disFloHea.heaCoo.vol.dynBal.m * bui.disFloHea.heaCoo.vol.dynBal.medium.Xi[1:0];
 if false then
  bui.disFloHea.heaCoo.vol.dynBal.U = bui.disFloHea.heaCoo.vol.dynBal.m * bui.disFloHea.heaCoo.vol.dynBal.medium.u + bui.disFloHea.heaCoo.vol.dynBal.CSen * (bui.disFloHea.heaCoo.vol.dynBal.medium.T - 273.15);
 else
  bui.disFloHea.heaCoo.vol.dynBal.U = bui.disFloHea.heaCoo.vol.dynBal.m * bui.disFloHea.heaCoo.vol.dynBal.medium.u;
 end if;
 bui.disFloHea.heaCoo.vol.dynBal.mC[1:0] = bui.disFloHea.heaCoo.vol.dynBal.m * bui.disFloHea.heaCoo.vol.dynBal.C[1:0];
 bui.disFloHea.heaCoo.vol.dynBal.hOut = bui.disFloHea.heaCoo.vol.dynBal.medium.h;
 bui.disFloHea.heaCoo.vol.dynBal.XiOut[1:0] = bui.disFloHea.heaCoo.vol.dynBal.medium.Xi[1:0];
 bui.disFloHea.heaCoo.vol.dynBal.COut[1:0] = bui.disFloHea.heaCoo.vol.dynBal.C[1:0];
 bui.disFloHea.heaCoo.vol.dynBal.ports_H_flow[1] = semiLinear(bui.disFloHea.heaCoo.vol.dynBal.ports[1].m_flow, inStream(bui.disFloHea.heaCoo.vol.dynBal.ports[1].h_outflow), bui.disFloHea.heaCoo.vol.dynBal.ports[1].h_outflow);
 bui.disFloHea.heaCoo.vol.dynBal.ports_H_flow[2] = semiLinear(bui.disFloHea.heaCoo.vol.dynBal.ports[2].m_flow, inStream(bui.disFloHea.heaCoo.vol.dynBal.ports[2].h_outflow), bui.disFloHea.heaCoo.vol.dynBal.ports[2].h_outflow);
 bui.disFloHea.heaCoo.vol.dynBal.mb_flow = sum({bui.disFloHea.heaCoo.vol.dynBal.ports[1].m_flow, bui.disFloHea.heaCoo.vol.dynBal.ports[2].m_flow});
 bui.disFloHea.heaCoo.vol.dynBal.Hb_flow = sum(bui.disFloHea.heaCoo.vol.dynBal.ports_H_flow[1:2]);
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  0 = bui.disFloHea.heaCoo.vol.dynBal.Hb_flow + bui.disFloHea.heaCoo.vol.dynBal.Q_flow;
 else
  der(bui.disFloHea.heaCoo.vol.dynBal.U) = bui.disFloHea.heaCoo.vol.dynBal.Hb_flow + bui.disFloHea.heaCoo.vol.dynBal.Q_flow;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  0 = bui.disFloHea.heaCoo.vol.dynBal.mb_flow;
 else
  der(bui.disFloHea.heaCoo.vol.dynBal.m) = bui.disFloHea.heaCoo.vol.dynBal.mb_flow;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  zeros(0) = bui.disFloHea.heaCoo.vol.dynBal.mbXi_flow[1:0] + bui.disFloHea.heaCoo.vol.dynBal.mWat_flow_internal * fill(0.0, 0);
 else
  der(bui.disFloHea.heaCoo.vol.dynBal.mXi[1:0]) = bui.disFloHea.heaCoo.vol.dynBal.mbXi_flow[1:0] + bui.disFloHea.heaCoo.vol.dynBal.mWat_flow_internal * fill(0.0, 0);
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  zeros(0) = bui.disFloHea.heaCoo.vol.dynBal.mbC_flow[1:0] + bui.disFloHea.heaCoo.vol.dynBal.C_flow_internal[1:0];
 else
  der(bui.disFloHea.heaCoo.vol.dynBal.mC[1:0]) = bui.disFloHea.heaCoo.vol.dynBal.mbC_flow[1:0] + bui.disFloHea.heaCoo.vol.dynBal.C_flow_internal[1:0];
 end if;
 bui.disFloHea.heaCoo.vol.dynBal.ports[1].p = bui.disFloHea.heaCoo.vol.dynBal.medium.p;
 bui.disFloHea.heaCoo.vol.dynBal.ports[1].h_outflow = bui.disFloHea.heaCoo.vol.dynBal.medium.h;
 bui.disFloHea.heaCoo.vol.dynBal.ports[1].Xi_outflow[1:0] = bui.disFloHea.heaCoo.vol.dynBal.medium.Xi[1:0];
 bui.disFloHea.heaCoo.vol.dynBal.ports[1].C_outflow[1:0] = bui.disFloHea.heaCoo.vol.dynBal.C[1:0];
 bui.disFloHea.heaCoo.vol.dynBal.ports[2].p = bui.disFloHea.heaCoo.vol.dynBal.medium.p;
 bui.disFloHea.heaCoo.vol.dynBal.ports[2].h_outflow = bui.disFloHea.heaCoo.vol.dynBal.medium.h;
 bui.disFloHea.heaCoo.vol.dynBal.ports[2].Xi_outflow[1:0] = bui.disFloHea.heaCoo.vol.dynBal.medium.Xi[1:0];
 bui.disFloHea.heaCoo.vol.dynBal.ports[2].C_outflow[1:0] = bui.disFloHea.heaCoo.vol.dynBal.C[1:0];
 bui.disFloHea.heaCoo.vol.dynBal.UOut = bui.disFloHea.heaCoo.vol.dynBal.U;
 bui.disFloHea.heaCoo.vol.dynBal.mXiOut[1:0] = bui.disFloHea.heaCoo.vol.dynBal.mXi[1:0];
 bui.disFloHea.heaCoo.vol.dynBal.mOut = bui.disFloHea.heaCoo.vol.dynBal.m;
 bui.disFloHea.heaCoo.vol.dynBal.mCOut[1:0] = bui.disFloHea.heaCoo.vol.dynBal.mC[1:0];
 assert(bui.disFloHea.heaCoo.vol.dynBal.medium.T >= 272.15, "
  In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol.dynBal.medium" + ": Temperature T = " + String(bui.disFloHea.heaCoo.vol.dynBal.medium.T) + " K exceeded its minimum allowed value of " + String(272.15 - 273.15) + " degC (" + String(272.15) + " Kelvin)
as required from medium model \"" + "SimpleLiquidWater" + "\".");
 assert(bui.disFloHea.heaCoo.vol.dynBal.medium.T <= 403.15, "
  In " + "CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol.dynBal.medium" + ": Temperature T = " + String(bui.disFloHea.heaCoo.vol.dynBal.medium.T) + " K exceeded its maximum allowed value of " + String(403.15 - 273.15) + " degC (" + String(403.15) + " Kelvin)
as required from medium model \"" + "SimpleLiquidWater" + "\".");
 bui.disFloHea.heaCoo.vol.dynBal.medium.h = 4184.0 * (bui.disFloHea.heaCoo.vol.dynBal.medium.T - 273.15);
 bui.disFloHea.heaCoo.vol.dynBal.medium.u = bui.disFloHea.heaCoo.vol.dynBal.medium.h;
 bui.disFloHea.heaCoo.vol.dynBal.medium.state.T = bui.disFloHea.heaCoo.vol.dynBal.medium.T;
 bui.disFloHea.heaCoo.vol.dynBal.medium.state.p = bui.disFloHea.heaCoo.vol.dynBal.medium.p;
 bui.disFloHea.heaCoo.vol.preTem.port.T = bui.disFloHea.heaCoo.vol.preTem.T;
 bui.disFloHea.heaCoo.vol.heaFloSen.port_a.T = bui.disFloHea.heaCoo.vol.heaFloSen.port_b.T;
 bui.disFloHea.heaCoo.vol.heaFloSen.port_a.Q_flow + bui.disFloHea.heaCoo.vol.heaFloSen.port_b.Q_flow = 0;
 bui.disFloHea.heaCoo.vol.heaFloSen.Q_flow = bui.disFloHea.heaCoo.vol.heaFloSen.port_a.Q_flow;
 if false then
  if false then
   if false then
    bui.disFloHea.heaCoo.preDro.m_flow = 0;
   else
    bui.disFloHea.heaCoo.preDro.dp = 0;
   end if;
  else
   if true then
    if false then
     bui.disFloHea.heaCoo.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.disFloHea.heaCoo.preDro.dp, 0.0, 0.0);
    else
     bui.disFloHea.heaCoo.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.disFloHea.heaCoo.preDro.m_flow, 0.0, 0.0);
    end if;
   else
    if false then
     bui.disFloHea.heaCoo.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.disFloHea.heaCoo.preDro.dp, 0.0, 0.0);
    else
     bui.disFloHea.heaCoo.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.disFloHea.heaCoo.preDro.m_flow, 0.0, 0.0);
    end if;
   end if;
  end if;
 else
  bui.disFloHea.heaCoo.preDro.dp = 0;
 end if;
 bui.disFloHea.heaCoo.preDro.port_a.h_outflow = 83680.0;
 bui.disFloHea.heaCoo.preDro.port_b.h_outflow = inStream(bui.disFloHea.heaCoo.preDro.port_a.h_outflow);
 bui.disFloHea.heaCoo.preDro.port_a.m_flow + bui.disFloHea.heaCoo.preDro.port_b.m_flow = 0;
 bui.disFloHea.heaCoo.preDro.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 bui.disFloHea.heaCoo.preDro.port_b.Xi_outflow[1:0] = inStream(bui.disFloHea.heaCoo.preDro.port_a.Xi_outflow[1:0]);
 bui.disFloHea.heaCoo.preDro.port_a.C_outflow[1:0] = zeros(0);
 bui.disFloHea.heaCoo.preDro.port_b.C_outflow[1:0] = inStream(bui.disFloHea.heaCoo.preDro.port_a.C_outflow[1:0]);
 bui.disFloHea.senMasFlo.m_flow = bui.disFloHea.senMasFlo.port_a.m_flow;
 bui.disFloHea.senMasFlo.port_b.m_flow = - bui.disFloHea.senMasFlo.port_a.m_flow;
 bui.disFloHea.senMasFlo.port_a.p = bui.disFloHea.senMasFlo.port_b.p;
 bui.disFloHea.senMasFlo.port_a.h_outflow = 83680.0;
 bui.disFloHea.senMasFlo.port_b.h_outflow = inStream(bui.disFloHea.senMasFlo.port_a.h_outflow);
 bui.disFloHea.senMasFlo.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 bui.disFloHea.senMasFlo.port_b.Xi_outflow[1:0] = inStream(bui.disFloHea.senMasFlo.port_a.Xi_outflow[1:0]);
 bui.disFloHea.senMasFlo.port_a.C_outflow[1:0] = zeros(0);
 bui.disFloHea.senMasFlo.port_b.C_outflow[1:0] = inStream(bui.disFloHea.senMasFlo.port_a.C_outflow[1:0]);
 bui.disFloHea.reaRep.y[1:1] = fill(bui.disFloHea.reaRep.u, 1);
 assert(bui.disFloCoo.mReqTot_flow < 7.024856596558317 + 7.024856596558318E-4, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo" + ": The total required mass flow rate equals " + String(bui.disFloCoo.mReqTot_flow) + " kg/s which is higher than the nominal mass
    flow rate value of " + String(7.024856596558317) + " kg/s.", AssertionLevel.error);
 if size(bui.disFloCoo.sumMasFloReq.u[1:1], 1) > 0 then
  bui.disFloCoo.sumMasFloReq.y = {1.0} * bui.disFloCoo.sumMasFloReq.u[1:1];
 else
  bui.disFloCoo.sumMasFloReq.y = 0;
 end if;
 if not true then
  bui.disFloCoo.sou_m_flow[1].m_flow_in_internal = bui.disFloCoo.sou_m_flow[1].m_flow;
 end if;
 bui.disFloCoo.sou_m_flow[1].ports[1].p = bui.disFloCoo.sou_m_flow[1].p_in_internal;
 sum({bui.disFloCoo.sou_m_flow[1].ports[1].m_flow}) = - bui.disFloCoo.sou_m_flow[1].m_flow_in_internal;
 if not true then
  bui.disFloCoo.sou_m_flow[1].T_in_internal = bui.disFloCoo.sou_m_flow[1].T;
 end if;
 bui.disFloCoo.sou_m_flow[1].ports[1].h_outflow = bui.disFloCoo.sou_m_flow[1].h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, bui.disFloCoo.sou_m_flow[1].X_in_internal[1:1], "Boundary_pT");
 end if;
 if false then
  bui.disFloCoo.sou_m_flow[1].X_in_internal[1:0] = bui.disFloCoo.sou_m_flow[1].Xi_in_internal[1:0];
  if true then
   bui.disFloCoo.sou_m_flow[1].X_in_internal[1] = 1 - sum(bui.disFloCoo.sou_m_flow[1].Xi_in_internal[1:0]);
  end if;
 elseif false then
  bui.disFloCoo.sou_m_flow[1].X_in_internal[1:0] = bui.disFloCoo.sou_m_flow[1].Xi_in_internal[1:0];
 else
  bui.disFloCoo.sou_m_flow[1].X_in_internal[1:1] = bui.disFloCoo.sou_m_flow[1].X[1:1];
  bui.disFloCoo.sou_m_flow[1].Xi_in_internal[1:0] = bui.disFloCoo.sou_m_flow[1].X[1:0];
 end if;
 if not false then
  bui.disFloCoo.sou_m_flow[1].C_in_internal[1:0] = bui.disFloCoo.sou_m_flow[1].C[1:0];
 end if;
 bui.disFloCoo.sou_m_flow[1].ports[1].Xi_outflow[1:0] = bui.disFloCoo.sou_m_flow[1].Xi_in_internal[1:0];
 bui.disFloCoo.sou_m_flow[1].ports[1].C_outflow[1:0] = bui.disFloCoo.sou_m_flow[1].C_in_internal[1:0];
 if false then
  if true then
   assert(bui.disFloCoo.sin.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.sin" + ": The value of p_in=" + String(bui.disFloCoo.sin.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if false then
   assert(bui.disFloCoo.sin.p_in_internal > 50000.0 and bui.disFloCoo.sin.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.sin" + ": The value of p_in=" + String(bui.disFloCoo.sin.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 if not false then
  bui.disFloCoo.sin.p_in_internal = bui.disFloCoo.sin.p;
 end if;
 bui.disFloCoo.sin.ports[1].p = bui.disFloCoo.sin.p_in_internal;
 if not false then
  bui.disFloCoo.sin.T_in_internal = bui.disFloCoo.sin.T;
 end if;
 bui.disFloCoo.sin.ports[1].h_outflow = bui.disFloCoo.sin.h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, bui.disFloCoo.sin.X_in_internal[1:1], "Boundary_pT");
 end if;
 if false then
  bui.disFloCoo.sin.X_in_internal[1:0] = bui.disFloCoo.sin.Xi_in_internal[1:0];
  if true then
   bui.disFloCoo.sin.X_in_internal[1] = 1 - sum(bui.disFloCoo.sin.Xi_in_internal[1:0]);
  end if;
 elseif false then
  bui.disFloCoo.sin.X_in_internal[1:0] = bui.disFloCoo.sin.Xi_in_internal[1:0];
 else
  bui.disFloCoo.sin.X_in_internal[1:1] = bui.disFloCoo.sin.X[1:1];
  bui.disFloCoo.sin.Xi_in_internal[1:0] = bui.disFloCoo.sin.X[1:0];
 end if;
 if not false then
  bui.disFloCoo.sin.C_in_internal[1:0] = bui.disFloCoo.sin.C[1:0];
 end if;
 bui.disFloCoo.sin.ports[1].Xi_outflow[1:0] = bui.disFloCoo.sin.Xi_in_internal[1:0];
 bui.disFloCoo.sin.ports[1].C_outflow[1:0] = bui.disFloCoo.sin.C_in_internal[1:0];
 if size(bui.disFloCoo.Q_flowSum.u[1:1], 1) > 0 then
  bui.disFloCoo.Q_flowSum.y = bui.disFloCoo.Q_flowSum.k[1:1] * bui.disFloCoo.Q_flowSum.u[1:1];
 else
  bui.disFloCoo.Q_flowSum.y = 0;
 end if;
 if false then
  bui.disFloCoo.pipPre.m_flow = bui.disFloCoo.pipPre.m_flow_internal;
 else
  bui.disFloCoo.pipPre.m_flow_internal = 0;
 end if;
 if true then
  bui.disFloCoo.pipPre.dp = bui.disFloCoo.pipPre.dp_internal;
 else
  bui.disFloCoo.pipPre.dp_internal = 0;
 end if;
 bui.disFloCoo.pipPre.port_a.h_outflow = 83680.0;
 bui.disFloCoo.pipPre.port_b.h_outflow = inStream(bui.disFloCoo.pipPre.port_a.h_outflow);
 bui.disFloCoo.pipPre.dp = bui.disFloCoo.pipPre.port_a.p - bui.disFloCoo.pipPre.port_b.p;
 bui.disFloCoo.pipPre.m_flow = bui.disFloCoo.pipPre.port_a.m_flow;
 assert(bui.disFloCoo.pipPre.m_flow > -7.024856596558318E-4 or false, "Reverting flow occurs even though allowFlowReversal is false");
 bui.disFloCoo.pipPre.port_a.m_flow + bui.disFloCoo.pipPre.port_b.m_flow = 0;
 bui.disFloCoo.pipPre.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 bui.disFloCoo.pipPre.port_b.Xi_outflow[1:0] = inStream(bui.disFloCoo.pipPre.port_a.Xi_outflow[1:0]);
 bui.disFloCoo.pipPre.port_a.C_outflow[1:0] = zeros(0);
 bui.disFloCoo.pipPre.port_b.C_outflow[1:0] = inStream(bui.disFloCoo.pipPre.port_a.C_outflow[1:0]);
 bui.disFloCoo.heaCoo.preHea.port.Q_flow = (- bui.disFloCoo.heaCoo.preHea.Q_flow) * 1;
 bui.disFloCoo.heaCoo.gai.y = - bui.disFloCoo.heaCoo.gai.u;
 if not false then
  assert(bui.disFloCoo.heaCoo.vol.ports[1].m_flow > -7.024856596558318E-4, "In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol" + ": Model has flow reversal,
  but the parameter allowFlowReversal is set to false.
  m_flow_small    = " + String(7.024856596558318E-4) + "
  ports[1].m_flow = " + String(bui.disFloCoo.heaCoo.vol.ports[1].m_flow) + "
");
 end if;
 if false then
  bui.disFloCoo.heaCoo.vol.U = 0;
  bui.disFloCoo.heaCoo.vol.mXi[1:0] = zeros(0);
  bui.disFloCoo.heaCoo.vol.m = 0;
  bui.disFloCoo.heaCoo.vol.mC[1:0] = zeros(0);
 end if;
 if not false then
  bui.disFloCoo.heaCoo.vol.dynBal.mWat_flow_internal = 0;
 end if;
 if not false then
  bui.disFloCoo.heaCoo.vol.dynBal.C_flow_internal[1:0] = zeros(0);
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  bui.disFloCoo.heaCoo.vol.dynBal.m = bui.disFloCoo.heaCoo.vol.dynBal.fluidVolume * bui.disFloCoo.heaCoo.vol.dynBal.rho_start;
 else
  if false then
   bui.disFloCoo.heaCoo.vol.dynBal.m = bui.disFloCoo.heaCoo.vol.dynBal.fluidVolume * Buildings.Media.Water.density(Buildings.Media.Water.setState_phX(bui.disFloCoo.heaCoo.vol.dynBal.medium.p, bui.disFloCoo.heaCoo.vol.dynBal.hOut, {1.0}));
  else
   bui.disFloCoo.heaCoo.vol.dynBal.m = bui.disFloCoo.heaCoo.vol.dynBal.fluidVolume * bui.disFloCoo.heaCoo.vol.dynBal.medium.d;
  end if;
 end if;
 bui.disFloCoo.heaCoo.vol.dynBal.mXi[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.m * bui.disFloCoo.heaCoo.vol.dynBal.medium.Xi[1:0];
 if false then
  bui.disFloCoo.heaCoo.vol.dynBal.U = bui.disFloCoo.heaCoo.vol.dynBal.m * bui.disFloCoo.heaCoo.vol.dynBal.medium.u + bui.disFloCoo.heaCoo.vol.dynBal.CSen * (bui.disFloCoo.heaCoo.vol.dynBal.medium.T - 273.15);
 else
  bui.disFloCoo.heaCoo.vol.dynBal.U = bui.disFloCoo.heaCoo.vol.dynBal.m * bui.disFloCoo.heaCoo.vol.dynBal.medium.u;
 end if;
 bui.disFloCoo.heaCoo.vol.dynBal.mC[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.m * bui.disFloCoo.heaCoo.vol.dynBal.C[1:0];
 bui.disFloCoo.heaCoo.vol.dynBal.hOut = bui.disFloCoo.heaCoo.vol.dynBal.medium.h;
 bui.disFloCoo.heaCoo.vol.dynBal.XiOut[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.medium.Xi[1:0];
 bui.disFloCoo.heaCoo.vol.dynBal.COut[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.C[1:0];
 bui.disFloCoo.heaCoo.vol.dynBal.ports_H_flow[1] = semiLinear(bui.disFloCoo.heaCoo.vol.dynBal.ports[1].m_flow, inStream(bui.disFloCoo.heaCoo.vol.dynBal.ports[1].h_outflow), bui.disFloCoo.heaCoo.vol.dynBal.ports[1].h_outflow);
 bui.disFloCoo.heaCoo.vol.dynBal.ports_H_flow[2] = semiLinear(bui.disFloCoo.heaCoo.vol.dynBal.ports[2].m_flow, inStream(bui.disFloCoo.heaCoo.vol.dynBal.ports[2].h_outflow), bui.disFloCoo.heaCoo.vol.dynBal.ports[2].h_outflow);
 bui.disFloCoo.heaCoo.vol.dynBal.mb_flow = sum({bui.disFloCoo.heaCoo.vol.dynBal.ports[1].m_flow, bui.disFloCoo.heaCoo.vol.dynBal.ports[2].m_flow});
 bui.disFloCoo.heaCoo.vol.dynBal.Hb_flow = sum(bui.disFloCoo.heaCoo.vol.dynBal.ports_H_flow[1:2]);
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  0 = bui.disFloCoo.heaCoo.vol.dynBal.Hb_flow + bui.disFloCoo.heaCoo.vol.dynBal.Q_flow;
 else
  der(bui.disFloCoo.heaCoo.vol.dynBal.U) = bui.disFloCoo.heaCoo.vol.dynBal.Hb_flow + bui.disFloCoo.heaCoo.vol.dynBal.Q_flow;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  0 = bui.disFloCoo.heaCoo.vol.dynBal.mb_flow;
 else
  der(bui.disFloCoo.heaCoo.vol.dynBal.m) = bui.disFloCoo.heaCoo.vol.dynBal.mb_flow;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  zeros(0) = bui.disFloCoo.heaCoo.vol.dynBal.mbXi_flow[1:0] + bui.disFloCoo.heaCoo.vol.dynBal.mWat_flow_internal * fill(0.0, 0);
 else
  der(bui.disFloCoo.heaCoo.vol.dynBal.mXi[1:0]) = bui.disFloCoo.heaCoo.vol.dynBal.mbXi_flow[1:0] + bui.disFloCoo.heaCoo.vol.dynBal.mWat_flow_internal * fill(0.0, 0);
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  zeros(0) = bui.disFloCoo.heaCoo.vol.dynBal.mbC_flow[1:0] + bui.disFloCoo.heaCoo.vol.dynBal.C_flow_internal[1:0];
 else
  der(bui.disFloCoo.heaCoo.vol.dynBal.mC[1:0]) = bui.disFloCoo.heaCoo.vol.dynBal.mbC_flow[1:0] + bui.disFloCoo.heaCoo.vol.dynBal.C_flow_internal[1:0];
 end if;
 bui.disFloCoo.heaCoo.vol.dynBal.ports[1].p = bui.disFloCoo.heaCoo.vol.dynBal.medium.p;
 bui.disFloCoo.heaCoo.vol.dynBal.ports[1].h_outflow = bui.disFloCoo.heaCoo.vol.dynBal.medium.h;
 bui.disFloCoo.heaCoo.vol.dynBal.ports[1].Xi_outflow[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.medium.Xi[1:0];
 bui.disFloCoo.heaCoo.vol.dynBal.ports[1].C_outflow[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.C[1:0];
 bui.disFloCoo.heaCoo.vol.dynBal.ports[2].p = bui.disFloCoo.heaCoo.vol.dynBal.medium.p;
 bui.disFloCoo.heaCoo.vol.dynBal.ports[2].h_outflow = bui.disFloCoo.heaCoo.vol.dynBal.medium.h;
 bui.disFloCoo.heaCoo.vol.dynBal.ports[2].Xi_outflow[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.medium.Xi[1:0];
 bui.disFloCoo.heaCoo.vol.dynBal.ports[2].C_outflow[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.C[1:0];
 bui.disFloCoo.heaCoo.vol.dynBal.UOut = bui.disFloCoo.heaCoo.vol.dynBal.U;
 bui.disFloCoo.heaCoo.vol.dynBal.mXiOut[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.mXi[1:0];
 bui.disFloCoo.heaCoo.vol.dynBal.mOut = bui.disFloCoo.heaCoo.vol.dynBal.m;
 bui.disFloCoo.heaCoo.vol.dynBal.mCOut[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.mC[1:0];
 assert(bui.disFloCoo.heaCoo.vol.dynBal.medium.T >= 272.15, "
  In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol.dynBal.medium" + ": Temperature T = " + String(bui.disFloCoo.heaCoo.vol.dynBal.medium.T) + " K exceeded its minimum allowed value of " + String(272.15 - 273.15) + " degC (" + String(272.15) + " Kelvin)
as required from medium model \"" + "SimpleLiquidWater" + "\".");
 assert(bui.disFloCoo.heaCoo.vol.dynBal.medium.T <= 403.15, "
  In " + "CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol.dynBal.medium" + ": Temperature T = " + String(bui.disFloCoo.heaCoo.vol.dynBal.medium.T) + " K exceeded its maximum allowed value of " + String(403.15 - 273.15) + " degC (" + String(403.15) + " Kelvin)
as required from medium model \"" + "SimpleLiquidWater" + "\".");
 bui.disFloCoo.heaCoo.vol.dynBal.medium.h = 4184.0 * (bui.disFloCoo.heaCoo.vol.dynBal.medium.T - 273.15);
 bui.disFloCoo.heaCoo.vol.dynBal.medium.u = bui.disFloCoo.heaCoo.vol.dynBal.medium.h;
 bui.disFloCoo.heaCoo.vol.dynBal.medium.state.T = bui.disFloCoo.heaCoo.vol.dynBal.medium.T;
 bui.disFloCoo.heaCoo.vol.dynBal.medium.state.p = bui.disFloCoo.heaCoo.vol.dynBal.medium.p;
 bui.disFloCoo.heaCoo.vol.preTem.port.T = bui.disFloCoo.heaCoo.vol.preTem.T;
 bui.disFloCoo.heaCoo.vol.heaFloSen.port_a.T = bui.disFloCoo.heaCoo.vol.heaFloSen.port_b.T;
 bui.disFloCoo.heaCoo.vol.heaFloSen.port_a.Q_flow + bui.disFloCoo.heaCoo.vol.heaFloSen.port_b.Q_flow = 0;
 bui.disFloCoo.heaCoo.vol.heaFloSen.Q_flow = bui.disFloCoo.heaCoo.vol.heaFloSen.port_a.Q_flow;
 if false then
  if false then
   if false then
    bui.disFloCoo.heaCoo.preDro.m_flow = 0;
   else
    bui.disFloCoo.heaCoo.preDro.dp = 0;
   end if;
  else
   if true then
    if false then
     bui.disFloCoo.heaCoo.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.disFloCoo.heaCoo.preDro.dp, 0.0, 0.0);
    else
     bui.disFloCoo.heaCoo.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.disFloCoo.heaCoo.preDro.m_flow, 0.0, 0.0);
    end if;
   else
    if false then
     bui.disFloCoo.heaCoo.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.disFloCoo.heaCoo.preDro.dp, 0.0, 0.0);
    else
     bui.disFloCoo.heaCoo.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.disFloCoo.heaCoo.preDro.m_flow, 0.0, 0.0);
    end if;
   end if;
  end if;
 else
  bui.disFloCoo.heaCoo.preDro.dp = 0;
 end if;
 bui.disFloCoo.heaCoo.preDro.port_a.h_outflow = 83680.0;
 bui.disFloCoo.heaCoo.preDro.port_b.h_outflow = inStream(bui.disFloCoo.heaCoo.preDro.port_a.h_outflow);
 bui.disFloCoo.heaCoo.preDro.port_a.m_flow + bui.disFloCoo.heaCoo.preDro.port_b.m_flow = 0;
 bui.disFloCoo.heaCoo.preDro.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 bui.disFloCoo.heaCoo.preDro.port_b.Xi_outflow[1:0] = inStream(bui.disFloCoo.heaCoo.preDro.port_a.Xi_outflow[1:0]);
 bui.disFloCoo.heaCoo.preDro.port_a.C_outflow[1:0] = zeros(0);
 bui.disFloCoo.heaCoo.preDro.port_b.C_outflow[1:0] = inStream(bui.disFloCoo.heaCoo.preDro.port_a.C_outflow[1:0]);
 bui.disFloCoo.senMasFlo.m_flow = bui.disFloCoo.senMasFlo.port_a.m_flow;
 bui.disFloCoo.senMasFlo.port_b.m_flow = - bui.disFloCoo.senMasFlo.port_a.m_flow;
 bui.disFloCoo.senMasFlo.port_a.p = bui.disFloCoo.senMasFlo.port_b.p;
 bui.disFloCoo.senMasFlo.port_a.h_outflow = 83680.0;
 bui.disFloCoo.senMasFlo.port_b.h_outflow = inStream(bui.disFloCoo.senMasFlo.port_a.h_outflow);
 bui.disFloCoo.senMasFlo.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 bui.disFloCoo.senMasFlo.port_b.Xi_outflow[1:0] = inStream(bui.disFloCoo.senMasFlo.port_a.Xi_outflow[1:0]);
 bui.disFloCoo.senMasFlo.port_a.C_outflow[1:0] = zeros(0);
 bui.disFloCoo.senMasFlo.port_b.C_outflow[1:0] = inStream(bui.disFloCoo.senMasFlo.port_a.C_outflow[1:0]);
 bui.disFloCoo.reaRep.y[1:1] = fill(bui.disFloCoo.reaRep.u, 1);
 bui.terUniCoo.con.controlError.y = bui.terUniCoo.con.controlError.u1 - bui.terUniCoo.con.controlError.u2;
 der(bui.terUniCoo.con.I.y) = bui.terUniCoo.con.I.k * bui.terUniCoo.con.I.u;
 if Buildings.Controls.OBC.CDL.Types.Reset.Disabled <> Buildings.Controls.OBC.CDL.Types.Reset.Input then
  bui.terUniCoo.con.I.y_reset_internal = bui.terUniCoo.con.I.y_reset;
 end if;
 if Buildings.Controls.OBC.CDL.Types.Reset.Disabled == Buildings.Controls.OBC.CDL.Types.Reset.Disabled then
  bui.terUniCoo.con.I.trigger_internal = false;
 else
  when bui.terUniCoo.con.I.trigger_internal then
   reinit(bui.terUniCoo.con.I.y, bui.terUniCoo.con.I.y_reset_internal);
  end when;
 end if;
 bui.terUniCoo.con.errP.y = bui.terUniCoo.con.errP.u1 - bui.terUniCoo.con.errP.u2;
 bui.terUniCoo.con.errI1.y = bui.terUniCoo.con.errI1.u1 - bui.terUniCoo.con.errI1.u2;
 bui.terUniCoo.con.errI2.y = bui.terUniCoo.con.errI2.u1 - bui.terUniCoo.con.errI2.u2;
 bui.terUniCoo.con.lim.y = smooth(0, noEvent(if bui.terUniCoo.con.lim.u > bui.terUniCoo.con.lim.uMax then bui.terUniCoo.con.lim.uMax elseif bui.terUniCoo.con.lim.u < bui.terUniCoo.con.lim.uMin then bui.terUniCoo.con.lim.uMin else bui.terUniCoo.con.lim.u));
 bui.terUniCoo.con.Dzero.y = 0.0;
 bui.terUniCoo.con.uS_revAct.y = bui.terUniCoo.con.uS_revAct.k * bui.terUniCoo.con.uS_revAct.u;
 bui.terUniCoo.con.uSetWp.y = bui.terUniCoo.con.uSetWp.k * bui.terUniCoo.con.uSetWp.u;
 bui.terUniCoo.con.uMea_revAct.y = bui.terUniCoo.con.uMea_revAct.k * bui.terUniCoo.con.uMea_revAct.u;
 bui.terUniCoo.con.addPD.y = bui.terUniCoo.con.addPD.u1 + bui.terUniCoo.con.addPD.u2;
 bui.terUniCoo.con.gainPID.y = bui.terUniCoo.con.gainPID.k * bui.terUniCoo.con.gainPID.u;
 bui.terUniCoo.con.addPID.y = bui.terUniCoo.con.addPID.u1 + bui.terUniCoo.con.addPID.u2;
 bui.terUniCoo.con.antWinErr.y = bui.terUniCoo.con.antWinErr.u1 - bui.terUniCoo.con.antWinErr.u2;
 bui.terUniCoo.con.antWinGai.y = bui.terUniCoo.con.antWinGai.k * bui.terUniCoo.con.antWinGai.u;
 bui.terUniCoo.con.cheYMinMax.y = bui.terUniCoo.con.cheYMinMax.k;
 assert(bui.terUniCoo.con.assMesYMinMax.u, bui.terUniCoo.con.assMesYMinMax.message, AssertionLevel.warning);
 bui.terUniCoo.fan.inputSwitch.y = bui.terUniCoo.fan.inputSwitch.u;
 if not true then
  assert(bui.terUniCoo.fan.vol.ports[1].m_flow > -0.0014485382537898948, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol" + ": Model has flow reversal,
  but the parameter allowFlowReversal is set to false.
  m_flow_small    = " + String(0.0014485382537898948) + "
  ports[1].m_flow = " + String(bui.terUniCoo.fan.vol.ports[1].m_flow) + "
");
 end if;
 if false then
  bui.terUniCoo.fan.vol.U = 0;
  bui.terUniCoo.fan.vol.mXi[1:1] = zeros(1);
  bui.terUniCoo.fan.vol.m = 0;
  bui.terUniCoo.fan.vol.mC[1:0] = zeros(0);
 end if;
 if not false then
  bui.terUniCoo.fan.vol.dynBal.mWat_flow_internal = 0;
 end if;
 if not false then
  bui.terUniCoo.fan.vol.dynBal.C_flow_internal[1:0] = zeros(0);
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  bui.terUniCoo.fan.vol.dynBal.m = bui.terUniCoo.fan.vol.dynBal.fluidVolume * bui.terUniCoo.fan.vol.dynBal.rho_start;
 else
  if true then
   bui.terUniCoo.fan.vol.dynBal.m = bui.terUniCoo.fan.vol.dynBal.fluidVolume * Buildings.Media.Air.density(Buildings.Media.Air.setState_phX(bui.terUniCoo.fan.vol.dynBal.medium.p, bui.terUniCoo.fan.vol.dynBal.hOut, {0.01, 0.99}));
  else
   bui.terUniCoo.fan.vol.dynBal.m = bui.terUniCoo.fan.vol.dynBal.fluidVolume * bui.terUniCoo.fan.vol.dynBal.medium.d;
  end if;
 end if;
 bui.terUniCoo.fan.vol.dynBal.mXi[1:1] = bui.terUniCoo.fan.vol.dynBal.m * bui.terUniCoo.fan.vol.dynBal.medium.Xi[1:1];
 if false then
  bui.terUniCoo.fan.vol.dynBal.U = bui.terUniCoo.fan.vol.dynBal.m * bui.terUniCoo.fan.vol.dynBal.medium.u + bui.terUniCoo.fan.vol.dynBal.CSen * (bui.terUniCoo.fan.vol.dynBal.medium.T - 273.15);
 else
  bui.terUniCoo.fan.vol.dynBal.U = bui.terUniCoo.fan.vol.dynBal.m * bui.terUniCoo.fan.vol.dynBal.medium.u;
 end if;
 bui.terUniCoo.fan.vol.dynBal.mC[1:0] = bui.terUniCoo.fan.vol.dynBal.m * bui.terUniCoo.fan.vol.dynBal.C[1:0];
 bui.terUniCoo.fan.vol.dynBal.hOut = bui.terUniCoo.fan.vol.dynBal.medium.h;
 bui.terUniCoo.fan.vol.dynBal.XiOut[1:1] = bui.terUniCoo.fan.vol.dynBal.medium.Xi[1:1];
 bui.terUniCoo.fan.vol.dynBal.COut[1:0] = bui.terUniCoo.fan.vol.dynBal.C[1:0];
 bui.terUniCoo.fan.vol.dynBal.ports_H_flow[1] = semiLinear(bui.terUniCoo.fan.vol.dynBal.ports[1].m_flow, inStream(bui.terUniCoo.fan.vol.dynBal.ports[1].h_outflow), bui.terUniCoo.fan.vol.dynBal.ports[1].h_outflow);
 bui.terUniCoo.fan.vol.dynBal.ports_mXi_flow[1,1] = semiLinear(bui.terUniCoo.fan.vol.dynBal.ports[1].m_flow, inStream(bui.terUniCoo.fan.vol.dynBal.ports[1].Xi_outflow[1]), bui.terUniCoo.fan.vol.dynBal.ports[1].Xi_outflow[1]);
 bui.terUniCoo.fan.vol.dynBal.ports_H_flow[2] = semiLinear(bui.terUniCoo.fan.vol.dynBal.ports[2].m_flow, inStream(bui.terUniCoo.fan.vol.dynBal.ports[2].h_outflow), bui.terUniCoo.fan.vol.dynBal.ports[2].h_outflow);
 bui.terUniCoo.fan.vol.dynBal.ports_mXi_flow[2,1] = semiLinear(bui.terUniCoo.fan.vol.dynBal.ports[2].m_flow, inStream(bui.terUniCoo.fan.vol.dynBal.ports[2].Xi_outflow[1]), bui.terUniCoo.fan.vol.dynBal.ports[2].Xi_outflow[1]);
 bui.terUniCoo.fan.vol.dynBal.mbXi_flow[1] = sum(bui.terUniCoo.fan.vol.dynBal.ports_mXi_flow[1:2,1]);
 bui.terUniCoo.fan.vol.dynBal.mb_flow = sum({bui.terUniCoo.fan.vol.dynBal.ports[1].m_flow, bui.terUniCoo.fan.vol.dynBal.ports[2].m_flow});
 bui.terUniCoo.fan.vol.dynBal.Hb_flow = sum(bui.terUniCoo.fan.vol.dynBal.ports_H_flow[1:2]);
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  0 = bui.terUniCoo.fan.vol.dynBal.Hb_flow + bui.terUniCoo.fan.vol.dynBal.Q_flow;
 else
  der(bui.terUniCoo.fan.vol.dynBal.U) = bui.terUniCoo.fan.vol.dynBal.Hb_flow + bui.terUniCoo.fan.vol.dynBal.Q_flow;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  0 = bui.terUniCoo.fan.vol.dynBal.mb_flow;
 else
  der(bui.terUniCoo.fan.vol.dynBal.m) = bui.terUniCoo.fan.vol.dynBal.mb_flow;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  zeros(1) = bui.terUniCoo.fan.vol.dynBal.mbXi_flow[1:1] + bui.terUniCoo.fan.vol.dynBal.mWat_flow_internal * {1.0};
 else
  der(bui.terUniCoo.fan.vol.dynBal.mXi[1:1]) = bui.terUniCoo.fan.vol.dynBal.mbXi_flow[1:1] + bui.terUniCoo.fan.vol.dynBal.mWat_flow_internal * {1.0};
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  zeros(0) = bui.terUniCoo.fan.vol.dynBal.mbC_flow[1:0] + bui.terUniCoo.fan.vol.dynBal.C_flow_internal[1:0];
 else
  der(bui.terUniCoo.fan.vol.dynBal.mC[1:0]) = bui.terUniCoo.fan.vol.dynBal.mbC_flow[1:0] + bui.terUniCoo.fan.vol.dynBal.C_flow_internal[1:0];
 end if;
 bui.terUniCoo.fan.vol.dynBal.ports[1].p = bui.terUniCoo.fan.vol.dynBal.medium.p;
 bui.terUniCoo.fan.vol.dynBal.ports[1].h_outflow = bui.terUniCoo.fan.vol.dynBal.medium.h;
 bui.terUniCoo.fan.vol.dynBal.ports[1].Xi_outflow[1:1] = bui.terUniCoo.fan.vol.dynBal.medium.Xi[1:1];
 bui.terUniCoo.fan.vol.dynBal.ports[1].C_outflow[1:0] = bui.terUniCoo.fan.vol.dynBal.C[1:0];
 bui.terUniCoo.fan.vol.dynBal.ports[2].p = bui.terUniCoo.fan.vol.dynBal.medium.p;
 bui.terUniCoo.fan.vol.dynBal.ports[2].h_outflow = bui.terUniCoo.fan.vol.dynBal.medium.h;
 bui.terUniCoo.fan.vol.dynBal.ports[2].Xi_outflow[1:1] = bui.terUniCoo.fan.vol.dynBal.medium.Xi[1:1];
 bui.terUniCoo.fan.vol.dynBal.ports[2].C_outflow[1:0] = bui.terUniCoo.fan.vol.dynBal.C[1:0];
 bui.terUniCoo.fan.vol.dynBal.UOut = bui.terUniCoo.fan.vol.dynBal.U;
 bui.terUniCoo.fan.vol.dynBal.mXiOut[1:1] = bui.terUniCoo.fan.vol.dynBal.mXi[1:1];
 bui.terUniCoo.fan.vol.dynBal.mOut = bui.terUniCoo.fan.vol.dynBal.m;
 bui.terUniCoo.fan.vol.dynBal.mCOut[1:0] = bui.terUniCoo.fan.vol.dynBal.mC[1:0];
 assert(bui.terUniCoo.fan.vol.dynBal.medium.T >= 200.0, "
In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol.dynBal.medium" + ": Temperature T exceeded its minimum allowed value of -73.15 degC (200 Kelvin)
as required from medium model \"" + "Air" + "\".");
 assert(bui.terUniCoo.fan.vol.dynBal.medium.T <= 423.15, "
In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol.dynBal.medium" + ": Temperature T exceeded its maximum allowed value of 150 degC (423.15 Kelvin)
as required from medium model \"" + "Air" + "\".");
 bui.terUniCoo.fan.vol.dynBal.medium.MM = 1 / (bui.terUniCoo.fan.vol.dynBal.medium.Xi[1] / 0.01801528 + (1.0 - bui.terUniCoo.fan.vol.dynBal.medium.Xi[1]) / 0.0289651159);
 bui.terUniCoo.fan.vol.dynBal.medium.X_steam = bui.terUniCoo.fan.vol.dynBal.medium.Xi[1];
 bui.terUniCoo.fan.vol.dynBal.medium.X_air = 1 - bui.terUniCoo.fan.vol.dynBal.medium.Xi[1];
 bui.terUniCoo.fan.vol.dynBal.medium.dT = bui.terUniCoo.fan.vol.dynBal.medium.T - 273.15;
 bui.terUniCoo.fan.vol.dynBal.medium.h = bui.terUniCoo.fan.vol.dynBal.medium.dT * 1006.0 * bui.terUniCoo.fan.vol.dynBal.medium.X_air + (bui.terUniCoo.fan.vol.dynBal.medium.dT * 1860.0 + 2501014.5) * bui.terUniCoo.fan.vol.dynBal.medium.X_steam;
 bui.terUniCoo.fan.vol.dynBal.medium.R = 287.0512249529787 * bui.terUniCoo.fan.vol.dynBal.medium.X_air + 461.5233290850878 * bui.terUniCoo.fan.vol.dynBal.medium.X_steam;
 bui.terUniCoo.fan.vol.dynBal.medium.u = bui.terUniCoo.fan.vol.dynBal.medium.h - 101325.0 / 1.2;
 bui.terUniCoo.fan.vol.dynBal.medium.d / 1.2 = bui.terUniCoo.fan.vol.dynBal.medium.p / 101325.0;
 bui.terUniCoo.fan.vol.dynBal.medium.state.p = bui.terUniCoo.fan.vol.dynBal.medium.p;
 bui.terUniCoo.fan.vol.dynBal.medium.state.T = bui.terUniCoo.fan.vol.dynBal.medium.T;
 bui.terUniCoo.fan.vol.dynBal.medium.state.X[1:2] = bui.terUniCoo.fan.vol.dynBal.medium.X[1:2];
 if true then
  bui.terUniCoo.fan.vol.dynBal.medium.Xi[1:1] = bui.terUniCoo.fan.vol.dynBal.medium.X[1:1];
  if false then
   bui.terUniCoo.fan.vol.dynBal.medium.X[1:2] = {0.01, 0.99};
  end if;
  if true and not false then
   bui.terUniCoo.fan.vol.dynBal.medium.X[2] = 1 - sum(bui.terUniCoo.fan.vol.dynBal.medium.Xi[1:1]);
  end if;
  assert(bui.terUniCoo.fan.vol.dynBal.medium.X[1] >= -1.0E-5 and bui.terUniCoo.fan.vol.dynBal.medium.X[1] <= 1 + 1.0E-5, "Mass fraction X[" + String(1) + "] = " + String(bui.terUniCoo.fan.vol.dynBal.medium.X[1]) + "of substance " + "water" + "\nof medium " + "Air" + " is not in the range 0..1");
  assert(bui.terUniCoo.fan.vol.dynBal.medium.X[2] >= -1.0E-5 and bui.terUniCoo.fan.vol.dynBal.medium.X[2] <= 1 + 1.0E-5, "Mass fraction X[" + String(2) + "] = " + String(bui.terUniCoo.fan.vol.dynBal.medium.X[2]) + "of substance " + "air" + "\nof medium " + "Air" + " is not in the range 0..1");
 end if;
 assert(bui.terUniCoo.fan.vol.dynBal.medium.p >= 0.0, "Pressure (= " + String(bui.terUniCoo.fan.vol.dynBal.medium.p) + " Pa) of medium \"" + "Air" + "\" is negative\n(Temperature = " + String(bui.terUniCoo.fan.vol.dynBal.medium.T) + " K)");
 bui.terUniCoo.fan.vol.preTem.port.T = bui.terUniCoo.fan.vol.preTem.T;
 bui.terUniCoo.fan.vol.heaFloSen.port_a.T = bui.terUniCoo.fan.vol.heaFloSen.port_b.T;
 bui.terUniCoo.fan.vol.heaFloSen.port_a.Q_flow + bui.terUniCoo.fan.vol.heaFloSen.port_b.Q_flow = 0;
 bui.terUniCoo.fan.vol.heaFloSen.Q_flow = bui.terUniCoo.fan.vol.heaFloSen.port_a.Q_flow;
 assert(14.485382537898948 > 0, "u_nominal > 0 required");
 assert(Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.LowPass or Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.HighPass or bui.terUniCoo.fan.filter.f_min > 0, "f_min > 0 required for band pass and band stop filter");
 assert(bui.terUniCoo.fan.filter.A_ripple > 0, "A_ripple > 0 required");
 assert(bui.terUniCoo.fan.filter.f_cut > 0, "f_cut > 0 required");
 bui.terUniCoo.fan.filter.uu[1] = bui.terUniCoo.fan.filter.u / 14.485382537898948;
 der(bui.terUniCoo.fan.filter.x[1]) = bui.terUniCoo.fan.filter.r[1] * (bui.terUniCoo.fan.filter.x[1] - bui.terUniCoo.fan.filter.uu[1]);
 der(bui.terUniCoo.fan.filter.x[2]) = bui.terUniCoo.fan.filter.r[2] * (bui.terUniCoo.fan.filter.x[2] - bui.terUniCoo.fan.filter.uu[2]);
 if Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.LowPass then
  bui.terUniCoo.fan.filter.uu[1 + 1] = bui.terUniCoo.fan.filter.x[1];
  bui.terUniCoo.fan.filter.uu[2 + 1] = bui.terUniCoo.fan.filter.x[2];
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.HighPass then
  bui.terUniCoo.fan.filter.uu[1 + 1] = - bui.terUniCoo.fan.filter.x[1] + bui.terUniCoo.fan.filter.uu[1];
  bui.terUniCoo.fan.filter.uu[2 + 1] = - bui.terUniCoo.fan.filter.x[2] + bui.terUniCoo.fan.filter.uu[2];
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.BandPass then
 elseif Modelica.Blocks.Types.FilterType.LowPass == Modelica.Blocks.Types.FilterType.BandStop then
 else
  assert(false, "filterType (= " + String(Modelica.Blocks.Types.FilterType.LowPass) + ") is unknown");
  bui.terUniCoo.fan.filter.uu[1:3] = zeros(2 + 1);
 end if;
 bui.terUniCoo.fan.filter.y = bui.terUniCoo.fan.filter.gain * 14.485382537898948 * bui.terUniCoo.fan.filter.uu[2 + 1];
 if true then
  bui.terUniCoo.fan.preSou.m_flow = bui.terUniCoo.fan.preSou.m_flow_internal;
 else
  bui.terUniCoo.fan.preSou.m_flow_internal = 0;
 end if;
 if false then
  bui.terUniCoo.fan.preSou.dp = bui.terUniCoo.fan.preSou.dp_internal;
 else
  bui.terUniCoo.fan.preSou.dp_internal = 0;
 end if;
 bui.terUniCoo.fan.preSou.port_a.h_outflow = inStream(bui.terUniCoo.fan.preSou.port_b.h_outflow);
 bui.terUniCoo.fan.preSou.port_b.h_outflow = inStream(bui.terUniCoo.fan.preSou.port_a.h_outflow);
 bui.terUniCoo.fan.preSou.dp = bui.terUniCoo.fan.preSou.port_a.p - bui.terUniCoo.fan.preSou.port_b.p;
 bui.terUniCoo.fan.preSou.m_flow = bui.terUniCoo.fan.preSou.port_a.m_flow;
 assert(bui.terUniCoo.fan.preSou.m_flow > -0.0014485382537898948 or true, "Reverting flow occurs even though allowFlowReversal is false");
 bui.terUniCoo.fan.preSou.port_a.m_flow + bui.terUniCoo.fan.preSou.port_b.m_flow = 0;
 bui.terUniCoo.fan.preSou.port_a.Xi_outflow[1:1] = inStream(bui.terUniCoo.fan.preSou.port_b.Xi_outflow[1:1]);
 bui.terUniCoo.fan.preSou.port_b.Xi_outflow[1:1] = inStream(bui.terUniCoo.fan.preSou.port_a.Xi_outflow[1:1]);
 bui.terUniCoo.fan.preSou.port_a.C_outflow[1:0] = inStream(bui.terUniCoo.fan.preSou.port_b.C_outflow[1:0]);
 bui.terUniCoo.fan.preSou.port_b.C_outflow[1:0] = inStream(bui.terUniCoo.fan.preSou.port_a.C_outflow[1:0]);
 bui.terUniCoo.fan.senMasFlo.m_flow = bui.terUniCoo.fan.senMasFlo.port_a.m_flow;
 bui.terUniCoo.fan.senMasFlo.port_b.m_flow = - bui.terUniCoo.fan.senMasFlo.port_a.m_flow;
 bui.terUniCoo.fan.senMasFlo.port_a.p = bui.terUniCoo.fan.senMasFlo.port_b.p;
 bui.terUniCoo.fan.senMasFlo.port_a.h_outflow = inStream(bui.terUniCoo.fan.senMasFlo.port_b.h_outflow);
 bui.terUniCoo.fan.senMasFlo.port_b.h_outflow = inStream(bui.terUniCoo.fan.senMasFlo.port_a.h_outflow);
 bui.terUniCoo.fan.senMasFlo.port_a.Xi_outflow[1:1] = inStream(bui.terUniCoo.fan.senMasFlo.port_b.Xi_outflow[1:1]);
 bui.terUniCoo.fan.senMasFlo.port_b.Xi_outflow[1:1] = inStream(bui.terUniCoo.fan.senMasFlo.port_a.Xi_outflow[1:1]);
 bui.terUniCoo.fan.senMasFlo.port_a.C_outflow[1:0] = inStream(bui.terUniCoo.fan.senMasFlo.port_b.C_outflow[1:0]);
 bui.terUniCoo.fan.senMasFlo.port_b.C_outflow[1:0] = inStream(bui.terUniCoo.fan.senMasFlo.port_a.C_outflow[1:0]);
 bui.terUniCoo.fan.senRelPre.port_a.m_flow = 0;
 bui.terUniCoo.fan.senRelPre.port_b.m_flow = 0;
 bui.terUniCoo.fan.senRelPre.port_a.h_outflow = 0;
 bui.terUniCoo.fan.senRelPre.port_b.h_outflow = 0;
 bui.terUniCoo.fan.senRelPre.port_a.Xi_outflow[1:1] = zeros(1);
 bui.terUniCoo.fan.senRelPre.port_b.Xi_outflow[1:1] = zeros(1);
 bui.terUniCoo.fan.senRelPre.port_a.C_outflow[1:0] = zeros(0);
 bui.terUniCoo.fan.senRelPre.port_b.C_outflow[1:0] = zeros(0);
 bui.terUniCoo.fan.senRelPre.p_rel = bui.terUniCoo.fan.senRelPre.port_a.p - bui.terUniCoo.fan.senRelPre.port_b.p;
 bui.terUniCoo.fan.eff.y_out = bui.terUniCoo.fan.eff.r_N;
 bui.terUniCoo.fan.eff.V_flow = bui.terUniCoo.fan.eff.m_flow / bui.terUniCoo.fan.eff.rho;
 bui.terUniCoo.fan.eff.r_V = bui.terUniCoo.fan.eff.V_flow / 12.07115211491579;
 if false == false and Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate <> Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed then
  bui.terUniCoo.fan.eff.r_N = 1;
 else
  if 1 == 1 then
   if true then
    bui.terUniCoo.fan.eff.V_flow * 0.008284213391399023 + bui.terUniCoo.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.r_N, bui.terUniCoo.fan.eff.preDer1[1:2], 400.0, 12.07115211491579, bui.terUniCoo.fan.eff.pCur1);
   else
    bui.terUniCoo.fan.eff.V_flow * 0.008284213391399023 + bui.terUniCoo.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.r_N, bui.terUniCoo.fan.eff.preDer1[1:2], 400.0, 12.07115211491579, bui.terUniCoo.fan.eff.pCur1);
   end if;
  elseif 1 == 2 then
   if true then
    bui.terUniCoo.fan.eff.V_flow * 0.008284213391399023 + bui.terUniCoo.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.r_N, bui.terUniCoo.fan.eff.preDer2[1:3], 400.0, 12.07115211491579, bui.terUniCoo.fan.eff.pCur2);
   else
    bui.terUniCoo.fan.eff.V_flow * 0.008284213391399023 + bui.terUniCoo.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.r_N, bui.terUniCoo.fan.eff.preDer2[1:3], 400.0, 12.07115211491579, bui.terUniCoo.fan.eff.pCur2);
   end if;
  else
   if true then
    bui.terUniCoo.fan.eff.V_flow * 0.008284213391399023 + bui.terUniCoo.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.r_N, bui.terUniCoo.fan.eff.preDer3[1:4], 400.0, 12.07115211491579, bui.terUniCoo.fan.eff.pCur3);
   else
    bui.terUniCoo.fan.eff.V_flow * 0.008284213391399023 + bui.terUniCoo.fan.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.r_N, bui.terUniCoo.fan.eff.preDer3[1:4], 400.0, 12.07115211491579, bui.terUniCoo.fan.eff.pCur3);
   end if;
  end if;
 end if;
 bui.terUniCoo.fan.eff.WFlo = bui.terUniCoo.fan.eff.dp_internal * bui.terUniCoo.fan.eff.V_flow;
 if false then
  if true then
   bui.terUniCoo.fan.eff.PEle = Buildings.Fluid.Movers.BaseClasses.Characteristics.power(bui.terUniCoo.fan.eff.per.power, bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.r_N, bui.terUniCoo.fan.eff.powDer[1:1], 0.05);
  else
   bui.terUniCoo.fan.eff.PEle = bui.terUniCoo.fan.eff.rho / 1.2 * Buildings.Fluid.Movers.BaseClasses.Characteristics.power(bui.terUniCoo.fan.eff.per.power, bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.r_N, bui.terUniCoo.fan.eff.powDer[1:1], 0.05);
  end if;
  bui.terUniCoo.fan.eff.eta = bui.terUniCoo.fan.eff.WFlo / Buildings.Utilities.Math.Functions.smoothMax(bui.terUniCoo.fan.eff.PEle, 1.0E-5, 1.0E-6);
  bui.terUniCoo.fan.eff.etaHyd = 1;
  bui.terUniCoo.fan.eff.etaMot = bui.terUniCoo.fan.eff.eta;
 else
  if true then
   bui.terUniCoo.fan.eff.etaHyd = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(bui.terUniCoo.fan.eff.per.hydraulicEfficiency, bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.hydDer[1:1], bui.terUniCoo.fan.eff.r_N, 0.05);
   bui.terUniCoo.fan.eff.etaMot = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(bui.terUniCoo.fan.eff.per.motorEfficiency, bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.motDer[1:1], bui.terUniCoo.fan.eff.r_N, 0.05);
  else
   bui.terUniCoo.fan.eff.etaHyd = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(bui.terUniCoo.fan.eff.per.hydraulicEfficiency, bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.hydDer[1:1], bui.terUniCoo.fan.eff.r_N, 0.05);
   bui.terUniCoo.fan.eff.etaMot = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(bui.terUniCoo.fan.eff.per.motorEfficiency, bui.terUniCoo.fan.eff.V_flow, bui.terUniCoo.fan.eff.motDer[1:1], bui.terUniCoo.fan.eff.r_N, 0.05);
  end if;
  bui.terUniCoo.fan.eff.PEle = bui.terUniCoo.fan.eff.WFlo / Buildings.Utilities.Math.Functions.smoothMax(bui.terUniCoo.fan.eff.eta, 1.0E-5, 1.0E-6);
  bui.terUniCoo.fan.eff.eta = bui.terUniCoo.fan.eff.etaHyd * bui.terUniCoo.fan.eff.etaMot;
 end if;
 bui.terUniCoo.hex.hA.m1_flow = bui.terUniCoo.hex.m1_flow;
 bui.terUniCoo.hex.hA.m2_flow = bui.terUniCoo.hex.m2_flow;
 bui.terUniCoo.hex.hA.T_1 = bui.terUniCoo.hex.T_in1;
 bui.terUniCoo.hex.hA.T_2 = bui.terUniCoo.hex.T_in2;
 bui.terUniCoo.hex.hA.fm_w = bui.terUniCoo.hex.hA.m1_flow / bui.terUniCoo.hex.hA.m_flow_nominal_w;
 bui.terUniCoo.hex.hA.fm_a = bui.terUniCoo.hex.hA.m2_flow / 14.485382537898948;
 bui.terUniCoo.hex.hA.x_w = 1;
 bui.terUniCoo.hex.hA.x_a = 1;
 if true then
  bui.terUniCoo.hex.hA.hA_1 = bui.terUniCoo.hex.hA.x_w * bui.terUniCoo.hex.hA.hA_nominal_w * Buildings.Utilities.Math.Functions.regNonZeroPower(bui.terUniCoo.hex.hA.fm_w, bui.terUniCoo.hex.hA.n_w, 0.1);
 else
  bui.terUniCoo.hex.hA.hA_1 = bui.terUniCoo.hex.hA.x_w * bui.terUniCoo.hex.hA.hA_nominal_w;
 end if;
 if true then
  bui.terUniCoo.hex.hA.hA_2 = bui.terUniCoo.hex.hA.x_a * bui.terUniCoo.hex.hA.hA_nominal_a * Buildings.Utilities.Math.Functions.regNonZeroPower(bui.terUniCoo.hex.hA.fm_a, bui.terUniCoo.hex.hA.n_a, 0.1);
 else
  bui.terUniCoo.hex.hA.hA_2 = bui.terUniCoo.hex.hA.x_a * bui.terUniCoo.hex.hA.hA_nominal_a;
 end if;
 if Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.ParallelFlow then
  bui.terUniCoo.hex.flowRegime = if bui.terUniCoo.hex.C1_flow * bui.terUniCoo.hex.C2_flow >= 0 then Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow else Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow then
  bui.terUniCoo.hex.flowRegime = if bui.terUniCoo.hex.C1_flow * bui.terUniCoo.hex.C2_flow >= 0 then Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow else Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowUnmixed then
  bui.terUniCoo.hex.flowRegime = Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed;
 elseif Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow == Buildings.Fluid.Types.HeatExchangerConfiguration.CrossFlowStream1MixedStream2Unmixed then
  bui.terUniCoo.hex.flowRegime = if bui.terUniCoo.hex.C1_flow < bui.terUniCoo.hex.C2_flow then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed;
 else
  bui.terUniCoo.hex.flowRegime = if bui.terUniCoo.hex.C1_flow < bui.terUniCoo.hex.C2_flow then Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed else Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed;
 end if;
 bui.terUniCoo.hex.eps = Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C(bui.terUniCoo.hex.UA, bui.terUniCoo.hex.C1_flow, bui.terUniCoo.hex.C2_flow, Integer(bui.terUniCoo.hex.flowRegime), bui.terUniCoo.hex.CMin_flow_nominal, bui.terUniCoo.hex.CMax_flow_nominal, bui.terUniCoo.hex.delta);
 if not false then
  bui.terUniCoo.hex.bal1.vol.mWat_flow_internal = 0;
 end if;
 if not false then
  bui.terUniCoo.hex.bal1.vol.C_flow_internal[1:0] = zeros(0);
 end if;
 bui.terUniCoo.hex.bal1.vol.mXi_flow[1:0] = bui.terUniCoo.hex.bal1.vol.mWat_flow_internal * fill(0.0, 0);
 if true then
  bui.terUniCoo.hex.bal1.vol.m_flowInv = Buildings.Utilities.Math.Functions.inverseXRegularized(bui.terUniCoo.hex.bal1.vol.port_a.m_flow, bui.terUniCoo.hex.bal1.vol.deltaReg, bui.terUniCoo.hex.bal1.vol.deltaInvReg, bui.terUniCoo.hex.bal1.vol.aReg, bui.terUniCoo.hex.bal1.vol.bReg, bui.terUniCoo.hex.bal1.vol.cReg, bui.terUniCoo.hex.bal1.vol.dReg, bui.terUniCoo.hex.bal1.vol.eReg, bui.terUniCoo.hex.bal1.vol.fReg);
 else
  bui.terUniCoo.hex.bal1.vol.m_flowInv = 0;
 end if;
 if true then
  assert(noEvent(abs(bui.terUniCoo.hex.bal1.vol.Q_flow) < 200.0 * bui.terUniCoo.hex.bal1.vol.cp_default * max(bui.terUniCoo.hex.bal1.vol.m_flow_small / 1000.0, abs(bui.terUniCoo.hex.bal1.vol.m_flow))), "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal1.vol" + ":
   The heat flow rate equals " + String(bui.terUniCoo.hex.bal1.vol.Q_flow) + " W and the mass flow rate equals " + String(bui.terUniCoo.hex.bal1.vol.m_flow) + " kg/s,
   which results in a temperature difference " + String(abs(bui.terUniCoo.hex.bal1.vol.Q_flow) / (bui.terUniCoo.hex.bal1.vol.cp_default * max(bui.terUniCoo.hex.bal1.vol.m_flow_small / 1000.0, abs(bui.terUniCoo.hex.bal1.vol.m_flow)))) + " K > dTMax=" + String(200.0) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
 end if;
 if false then
  bui.terUniCoo.hex.bal1.vol.hOut = Buildings.Utilities.Math.Functions.regStep(bui.terUniCoo.hex.bal1.vol.port_a.m_flow, bui.terUniCoo.hex.bal1.vol.port_b.h_outflow, bui.terUniCoo.hex.bal1.vol.port_a.h_outflow, bui.terUniCoo.hex.bal1.vol.m_flow_small / 1000.0);
  bui.terUniCoo.hex.bal1.vol.XiOut[1:0] = Buildings.Utilities.Math.Functions.regStep(bui.terUniCoo.hex.bal1.vol.port_a.m_flow, bui.terUniCoo.hex.bal1.vol.port_b.Xi_outflow[1:0], bui.terUniCoo.hex.bal1.vol.port_a.Xi_outflow[1:0], bui.terUniCoo.hex.bal1.vol.m_flow_small / 1000.0);
  bui.terUniCoo.hex.bal1.vol.COut[1:0] = Buildings.Utilities.Math.Functions.regStep(bui.terUniCoo.hex.bal1.vol.port_a.m_flow, bui.terUniCoo.hex.bal1.vol.port_b.C_outflow[1:0], bui.terUniCoo.hex.bal1.vol.port_a.C_outflow[1:0], bui.terUniCoo.hex.bal1.vol.m_flow_small / 1000.0);
 else
  bui.terUniCoo.hex.bal1.vol.hOut = bui.terUniCoo.hex.bal1.vol.port_b.h_outflow;
  bui.terUniCoo.hex.bal1.vol.XiOut[1:0] = bui.terUniCoo.hex.bal1.vol.port_b.Xi_outflow[1:0];
  bui.terUniCoo.hex.bal1.vol.COut[1:0] = bui.terUniCoo.hex.bal1.vol.port_b.C_outflow[1:0];
 end if;
 bui.terUniCoo.hex.bal1.vol.port_a.m_flow + bui.terUniCoo.hex.bal1.vol.port_b.m_flow = 0;
 if true then
  bui.terUniCoo.hex.bal1.vol.port_b.Xi_outflow[1:0] = inStream(bui.terUniCoo.hex.bal1.vol.port_a.Xi_outflow[1:0]) + bui.terUniCoo.hex.bal1.vol.mXi_flow[1:0] * bui.terUniCoo.hex.bal1.vol.m_flowInv;
 else
  assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal1.vol" + ": Wrong implementation for forward flow.");
  bui.terUniCoo.hex.bal1.vol.port_b.Xi_outflow[1:0] = inStream(bui.terUniCoo.hex.bal1.vol.port_a.Xi_outflow[1:0]);
 end if;
 if false then
  if true then
   bui.terUniCoo.hex.bal1.vol.port_a.Xi_outflow[1:0] = inStream(bui.terUniCoo.hex.bal1.vol.port_b.Xi_outflow[1:0]) - bui.terUniCoo.hex.bal1.vol.mXi_flow[1:0] * bui.terUniCoo.hex.bal1.vol.m_flowInv;
  else
   assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal1.vol" + ": Wrong implementation for reverse flow.");
   bui.terUniCoo.hex.bal1.vol.port_a.Xi_outflow[1:0] = inStream(bui.terUniCoo.hex.bal1.vol.port_b.Xi_outflow[1:0]);
  end if;
 else
  bui.terUniCoo.hex.bal1.vol.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 end if;
 if true then
  bui.terUniCoo.hex.bal1.vol.port_b.h_outflow = inStream(bui.terUniCoo.hex.bal1.vol.port_a.h_outflow) + bui.terUniCoo.hex.bal1.vol.Q_flow * bui.terUniCoo.hex.bal1.vol.m_flowInv;
  if false then
   bui.terUniCoo.hex.bal1.vol.port_a.h_outflow = inStream(bui.terUniCoo.hex.bal1.vol.port_b.h_outflow) - bui.terUniCoo.hex.bal1.vol.Q_flow * bui.terUniCoo.hex.bal1.vol.m_flowInv;
  else
   bui.terUniCoo.hex.bal1.vol.port_a.h_outflow = 83680.0;
  end if;
 else
  bui.terUniCoo.hex.bal1.vol.port_a.m_flow * (inStream(bui.terUniCoo.hex.bal1.vol.port_a.h_outflow) - bui.terUniCoo.hex.bal1.vol.port_b.h_outflow) = - bui.terUniCoo.hex.bal1.vol.Q_flow;
  if false then
   bui.terUniCoo.hex.bal1.vol.port_a.m_flow * (inStream(bui.terUniCoo.hex.bal1.vol.port_b.h_outflow) - bui.terUniCoo.hex.bal1.vol.port_a.h_outflow) = bui.terUniCoo.hex.bal1.vol.Q_flow;
  else
   bui.terUniCoo.hex.bal1.vol.port_a.h_outflow = 83680.0;
  end if;
 end if;
 if true and false then
  bui.terUniCoo.hex.bal1.vol.port_b.C_outflow[1:0] = inStream(bui.terUniCoo.hex.bal1.vol.port_a.C_outflow[1:0]) + bui.terUniCoo.hex.bal1.vol.C_flow_internal[1:0] * bui.terUniCoo.hex.bal1.vol.m_flowInv;
 else
  assert(not false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal1.vol" + ": Wrong implementation of trace substance balance for forward flow.");
  bui.terUniCoo.hex.bal1.vol.port_b.C_outflow[1:0] = inStream(bui.terUniCoo.hex.bal1.vol.port_a.C_outflow[1:0]);
 end if;
 if false then
  if false then
   bui.terUniCoo.hex.bal1.vol.port_a.C_outflow[1:0] = inStream(bui.terUniCoo.hex.bal1.vol.port_b.C_outflow[1:0]) - bui.terUniCoo.hex.bal1.vol.C_flow_internal[1:0] * bui.terUniCoo.hex.bal1.vol.m_flowInv;
  else
   bui.terUniCoo.hex.bal1.vol.port_a.C_outflow[1:0] = inStream(bui.terUniCoo.hex.bal1.vol.port_b.C_outflow[1:0]);
  end if;
 else
  bui.terUniCoo.hex.bal1.vol.port_a.C_outflow[1:0] = zeros(0);
 end if;
 bui.terUniCoo.hex.bal1.vol.port_a.p = bui.terUniCoo.hex.bal1.vol.port_b.p;
 if false then
  if false then
   if false then
    bui.terUniCoo.hex.bal1.preDro.m_flow = bui.terUniCoo.hex.bal1.preDro.dp * bui.terUniCoo.hex.bal1.preDro.coeff;
   else
    bui.terUniCoo.hex.bal1.preDro.dp = bui.terUniCoo.hex.bal1.preDro.m_flow * bui.terUniCoo.hex.bal1.preDro.coeff;
   end if;
  else
   if true then
    if false then
     bui.terUniCoo.hex.bal1.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.terUniCoo.hex.bal1.preDro.dp, bui.terUniCoo.hex.bal1.preDro.k, bui.terUniCoo.hex.bal1.preDro.m_flow_turbulent);
    else
     bui.terUniCoo.hex.bal1.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.terUniCoo.hex.bal1.preDro.m_flow, bui.terUniCoo.hex.bal1.preDro.k, bui.terUniCoo.hex.bal1.preDro.m_flow_turbulent);
    end if;
   else
    if false then
     bui.terUniCoo.hex.bal1.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.terUniCoo.hex.bal1.preDro.dp, bui.terUniCoo.hex.bal1.preDro.k, bui.terUniCoo.hex.bal1.preDro.m_flow_turbulent);
    else
     bui.terUniCoo.hex.bal1.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.terUniCoo.hex.bal1.preDro.m_flow, bui.terUniCoo.hex.bal1.preDro.k, bui.terUniCoo.hex.bal1.preDro.m_flow_turbulent);
    end if;
   end if;
  end if;
 else
  bui.terUniCoo.hex.bal1.preDro.dp = 0;
 end if;
 bui.terUniCoo.hex.bal1.preDro.port_a.h_outflow = 83680.0;
 bui.terUniCoo.hex.bal1.preDro.port_b.h_outflow = inStream(bui.terUniCoo.hex.bal1.preDro.port_a.h_outflow);
 bui.terUniCoo.hex.bal1.preDro.port_a.m_flow + bui.terUniCoo.hex.bal1.preDro.port_b.m_flow = 0;
 bui.terUniCoo.hex.bal1.preDro.port_a.Xi_outflow[1:0] = fill(0.0, 0);
 bui.terUniCoo.hex.bal1.preDro.port_b.Xi_outflow[1:0] = inStream(bui.terUniCoo.hex.bal1.preDro.port_a.Xi_outflow[1:0]);
 bui.terUniCoo.hex.bal1.preDro.port_a.C_outflow[1:0] = zeros(0);
 bui.terUniCoo.hex.bal1.preDro.port_b.C_outflow[1:0] = inStream(bui.terUniCoo.hex.bal1.preDro.port_a.C_outflow[1:0]);
 if not false then
  bui.terUniCoo.hex.bal2.vol.mWat_flow_internal = 0;
 end if;
 if not false then
  bui.terUniCoo.hex.bal2.vol.C_flow_internal[1:0] = zeros(0);
 end if;
 bui.terUniCoo.hex.bal2.vol.mXi_flow[1:1] = bui.terUniCoo.hex.bal2.vol.mWat_flow_internal * {1.0};
 if true then
  bui.terUniCoo.hex.bal2.vol.m_flowInv = Buildings.Utilities.Math.Functions.inverseXRegularized(bui.terUniCoo.hex.bal2.vol.port_a.m_flow, 1.4485382537898948E-6, 690351.1159499184, -1.0355266739248777E7, 5.671357493190242E13, -1.1877288224784105E20, 1.2128899064693008E26, -5.958456220469665E31, 1.1257799939962011E37);
 else
  bui.terUniCoo.hex.bal2.vol.m_flowInv = 0;
 end if;
 if true then
  assert(noEvent(abs(bui.terUniCoo.hex.bal2.vol.Q_flow) < 200.0 * bui.terUniCoo.hex.bal2.vol.cp_default * max(0.0014485382537898948 / 1000.0, abs(bui.terUniCoo.hex.bal2.vol.m_flow))), "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal2.vol" + ":
   The heat flow rate equals " + String(bui.terUniCoo.hex.bal2.vol.Q_flow) + " W and the mass flow rate equals " + String(bui.terUniCoo.hex.bal2.vol.m_flow) + " kg/s,
   which results in a temperature difference " + String(abs(bui.terUniCoo.hex.bal2.vol.Q_flow) / (bui.terUniCoo.hex.bal2.vol.cp_default * max(0.0014485382537898948 / 1000.0, abs(bui.terUniCoo.hex.bal2.vol.m_flow)))) + " K > dTMax=" + String(200.0) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
 end if;
 if false then
  bui.terUniCoo.hex.bal2.vol.hOut = Buildings.Utilities.Math.Functions.regStep(bui.terUniCoo.hex.bal2.vol.port_a.m_flow, bui.terUniCoo.hex.bal2.vol.port_b.h_outflow, bui.terUniCoo.hex.bal2.vol.port_a.h_outflow, 0.0014485382537898948 / 1000.0);
  bui.terUniCoo.hex.bal2.vol.XiOut[1:1] = Buildings.Utilities.Math.Functions.regStep(bui.terUniCoo.hex.bal2.vol.port_a.m_flow, bui.terUniCoo.hex.bal2.vol.port_b.Xi_outflow[1:1], bui.terUniCoo.hex.bal2.vol.port_a.Xi_outflow[1:1], 0.0014485382537898948 / 1000.0);
  bui.terUniCoo.hex.bal2.vol.COut[1:0] = Buildings.Utilities.Math.Functions.regStep(bui.terUniCoo.hex.bal2.vol.port_a.m_flow, bui.terUniCoo.hex.bal2.vol.port_b.C_outflow[1:0], bui.terUniCoo.hex.bal2.vol.port_a.C_outflow[1:0], 0.0014485382537898948 / 1000.0);
 else
  bui.terUniCoo.hex.bal2.vol.hOut = bui.terUniCoo.hex.bal2.vol.port_b.h_outflow;
  bui.terUniCoo.hex.bal2.vol.XiOut[1:1] = bui.terUniCoo.hex.bal2.vol.port_b.Xi_outflow[1:1];
  bui.terUniCoo.hex.bal2.vol.COut[1:0] = bui.terUniCoo.hex.bal2.vol.port_b.C_outflow[1:0];
 end if;
 bui.terUniCoo.hex.bal2.vol.port_a.m_flow + bui.terUniCoo.hex.bal2.vol.port_b.m_flow = 0;
 if true then
  bui.terUniCoo.hex.bal2.vol.port_b.Xi_outflow[1:1] = inStream(bui.terUniCoo.hex.bal2.vol.port_a.Xi_outflow[1:1]) + bui.terUniCoo.hex.bal2.vol.mXi_flow[1:1] * bui.terUniCoo.hex.bal2.vol.m_flowInv;
 else
  assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal2.vol" + ": Wrong implementation for forward flow.");
  bui.terUniCoo.hex.bal2.vol.port_b.Xi_outflow[1:1] = inStream(bui.terUniCoo.hex.bal2.vol.port_a.Xi_outflow[1:1]);
 end if;
 if false then
  if true then
   bui.terUniCoo.hex.bal2.vol.port_a.Xi_outflow[1:1] = inStream(bui.terUniCoo.hex.bal2.vol.port_b.Xi_outflow[1:1]) - bui.terUniCoo.hex.bal2.vol.mXi_flow[1:1] * bui.terUniCoo.hex.bal2.vol.m_flowInv;
  else
   assert(false == false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal2.vol" + ": Wrong implementation for reverse flow.");
   bui.terUniCoo.hex.bal2.vol.port_a.Xi_outflow[1:1] = inStream(bui.terUniCoo.hex.bal2.vol.port_b.Xi_outflow[1:1]);
  end if;
 else
  bui.terUniCoo.hex.bal2.vol.port_a.Xi_outflow[1:1] = {0.01};
 end if;
 if true then
  bui.terUniCoo.hex.bal2.vol.port_b.h_outflow = inStream(bui.terUniCoo.hex.bal2.vol.port_a.h_outflow) + bui.terUniCoo.hex.bal2.vol.Q_flow * bui.terUniCoo.hex.bal2.vol.m_flowInv;
  if false then
   bui.terUniCoo.hex.bal2.vol.port_a.h_outflow = inStream(bui.terUniCoo.hex.bal2.vol.port_b.h_outflow) - bui.terUniCoo.hex.bal2.vol.Q_flow * bui.terUniCoo.hex.bal2.vol.m_flowInv;
  else
   bui.terUniCoo.hex.bal2.vol.port_a.h_outflow = 45300.945;
  end if;
 else
  bui.terUniCoo.hex.bal2.vol.port_a.m_flow * (inStream(bui.terUniCoo.hex.bal2.vol.port_a.h_outflow) - bui.terUniCoo.hex.bal2.vol.port_b.h_outflow) = - bui.terUniCoo.hex.bal2.vol.Q_flow;
  if false then
   bui.terUniCoo.hex.bal2.vol.port_a.m_flow * (inStream(bui.terUniCoo.hex.bal2.vol.port_b.h_outflow) - bui.terUniCoo.hex.bal2.vol.port_a.h_outflow) = bui.terUniCoo.hex.bal2.vol.Q_flow;
  else
   bui.terUniCoo.hex.bal2.vol.port_a.h_outflow = 45300.945;
  end if;
 end if;
 if true and false then
  bui.terUniCoo.hex.bal2.vol.port_b.C_outflow[1:0] = inStream(bui.terUniCoo.hex.bal2.vol.port_a.C_outflow[1:0]) + bui.terUniCoo.hex.bal2.vol.C_flow_internal[1:0] * bui.terUniCoo.hex.bal2.vol.m_flowInv;
 else
  assert(not false, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.hex.bal2.vol" + ": Wrong implementation of trace substance balance for forward flow.");
  bui.terUniCoo.hex.bal2.vol.port_b.C_outflow[1:0] = inStream(bui.terUniCoo.hex.bal2.vol.port_a.C_outflow[1:0]);
 end if;
 if false then
  if false then
   bui.terUniCoo.hex.bal2.vol.port_a.C_outflow[1:0] = inStream(bui.terUniCoo.hex.bal2.vol.port_b.C_outflow[1:0]) - bui.terUniCoo.hex.bal2.vol.C_flow_internal[1:0] * bui.terUniCoo.hex.bal2.vol.m_flowInv;
  else
   bui.terUniCoo.hex.bal2.vol.port_a.C_outflow[1:0] = inStream(bui.terUniCoo.hex.bal2.vol.port_b.C_outflow[1:0]);
  end if;
 else
  bui.terUniCoo.hex.bal2.vol.port_a.C_outflow[1:0] = zeros(0);
 end if;
 bui.terUniCoo.hex.bal2.vol.port_a.p = bui.terUniCoo.hex.bal2.vol.port_b.p;
 if true then
  if false then
   if false then
    bui.terUniCoo.hex.bal2.preDro.m_flow = bui.terUniCoo.hex.bal2.preDro.dp * bui.terUniCoo.hex.bal2.preDro.coeff;
   else
    bui.terUniCoo.hex.bal2.preDro.dp = bui.terUniCoo.hex.bal2.preDro.m_flow * bui.terUniCoo.hex.bal2.preDro.coeff;
   end if;
  else
   if true then
    if false then
     bui.terUniCoo.hex.bal2.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.terUniCoo.hex.bal2.preDro.dp, bui.terUniCoo.hex.bal2.preDro.k, 1.448538253789895);
    else
     bui.terUniCoo.hex.bal2.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.terUniCoo.hex.bal2.preDro.m_flow, bui.terUniCoo.hex.bal2.preDro.k, 1.448538253789895);
    end if;
   else
    if false then
     bui.terUniCoo.hex.bal2.preDro.m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(bui.terUniCoo.hex.bal2.preDro.dp, bui.terUniCoo.hex.bal2.preDro.k, 1.448538253789895);
    else
     bui.terUniCoo.hex.bal2.preDro.dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(bui.terUniCoo.hex.bal2.preDro.m_flow, bui.terUniCoo.hex.bal2.preDro.k, 1.448538253789895);
    end if;
   end if;
  end if;
 else
  bui.terUniCoo.hex.bal2.preDro.dp = 0;
 end if;
 bui.terUniCoo.hex.bal2.preDro.port_a.h_outflow = 45300.945;
 bui.terUniCoo.hex.bal2.preDro.port_b.h_outflow = inStream(bui.terUniCoo.hex.bal2.preDro.port_a.h_outflow);
 bui.terUniCoo.hex.bal2.preDro.port_a.m_flow + bui.terUniCoo.hex.bal2.preDro.port_b.m_flow = 0;
 bui.terUniCoo.hex.bal2.preDro.port_a.Xi_outflow[1:1] = {0.01};
 bui.terUniCoo.hex.bal2.preDro.port_b.Xi_outflow[1:1] = inStream(bui.terUniCoo.hex.bal2.preDro.port_a.Xi_outflow[1:1]);
 bui.terUniCoo.hex.bal2.preDro.port_a.C_outflow[1:0] = zeros(0);
 bui.terUniCoo.hex.bal2.preDro.port_b.C_outflow[1:0] = inStream(bui.terUniCoo.hex.bal2.preDro.port_a.C_outflow[1:0]);
 bui.terUniCoo.gaiMasFlo.y = bui.terUniCoo.gaiMasFlo.k * bui.terUniCoo.gaiMasFlo.u;
 bui.terUniCoo.gaiFloNom2.y = 14.485382537898948 * bui.terUniCoo.gaiFloNom2.u;
 if false then
  if false then
   assert(bui.terUniCoo.sinAir.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.sinAir" + ": The value of p_in=" + String(bui.terUniCoo.sinAir.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if true then
   assert(bui.terUniCoo.sinAir.p_in_internal > 50000.0 and bui.terUniCoo.sinAir.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.sinAir" + ": The value of p_in=" + String(bui.terUniCoo.sinAir.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 if not false then
  bui.terUniCoo.sinAir.p_in_internal = bui.terUniCoo.sinAir.p;
 end if;
 bui.terUniCoo.sinAir.ports[1].p = bui.terUniCoo.sinAir.p_in_internal;
 if not false then
  bui.terUniCoo.sinAir.T_in_internal = bui.terUniCoo.sinAir.T;
 end if;
 bui.terUniCoo.sinAir.ports[1].h_outflow = bui.terUniCoo.sinAir.h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("Air", {"water", "air"}, false, true, bui.terUniCoo.sinAir.X_in_internal[1:2], "Boundary_pT");
 end if;
 if false then
  bui.terUniCoo.sinAir.X_in_internal[1:1] = bui.terUniCoo.sinAir.Xi_in_internal[1:1];
  if true then
   bui.terUniCoo.sinAir.X_in_internal[2] = 1 - sum(bui.terUniCoo.sinAir.Xi_in_internal[1:1]);
  end if;
 elseif false then
  bui.terUniCoo.sinAir.X_in_internal[1:1] = bui.terUniCoo.sinAir.Xi_in_internal[1:1];
 else
  bui.terUniCoo.sinAir.X_in_internal[1:2] = bui.terUniCoo.sinAir.X[1:2];
  bui.terUniCoo.sinAir.Xi_in_internal[1:1] = bui.terUniCoo.sinAir.X[1:1];
 end if;
 if not false then
  bui.terUniCoo.sinAir.C_in_internal[1:0] = bui.terUniCoo.sinAir.C[1:0];
 end if;
 bui.terUniCoo.sinAir.ports[1].Xi_outflow[1:1] = bui.terUniCoo.sinAir.Xi_in_internal[1:1];
 bui.terUniCoo.sinAir.ports[1].C_outflow[1:0] = bui.terUniCoo.sinAir.C_in_internal[1:0];
 if false then
  if false then
   assert(bui.terUniCoo.retAir.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.retAir" + ": The value of p_in=" + String(bui.terUniCoo.retAir.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if true then
   assert(bui.terUniCoo.retAir.p_in_internal > 50000.0 and bui.terUniCoo.retAir.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.retAir" + ": The value of p_in=" + String(bui.terUniCoo.retAir.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 if not false then
  bui.terUniCoo.retAir.p_in_internal = bui.terUniCoo.retAir.p;
 end if;
 bui.terUniCoo.retAir.ports[1].p = bui.terUniCoo.retAir.p_in_internal;
 if not true then
  bui.terUniCoo.retAir.T_in_internal = bui.terUniCoo.retAir.T;
 end if;
 bui.terUniCoo.retAir.ports[1].h_outflow = bui.terUniCoo.retAir.h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("Air", {"water", "air"}, false, true, bui.terUniCoo.retAir.X_in_internal[1:2], "Boundary_pT");
 end if;
 if false then
  bui.terUniCoo.retAir.X_in_internal[1:1] = bui.terUniCoo.retAir.Xi_in_internal[1:1];
  if true then
   bui.terUniCoo.retAir.X_in_internal[2] = 1 - sum(bui.terUniCoo.retAir.Xi_in_internal[1:1]);
  end if;
 elseif false then
  bui.terUniCoo.retAir.X_in_internal[1:1] = bui.terUniCoo.retAir.Xi_in_internal[1:1];
 else
  bui.terUniCoo.retAir.X_in_internal[1:2] = bui.terUniCoo.retAir.X[1:2];
  bui.terUniCoo.retAir.Xi_in_internal[1:1] = bui.terUniCoo.retAir.X[1:1];
 end if;
 if not false then
  bui.terUniCoo.retAir.C_in_internal[1:0] = bui.terUniCoo.retAir.C[1:0];
 end if;
 bui.terUniCoo.retAir.ports[1].Xi_outflow[1:1] = bui.terUniCoo.retAir.Xi_in_internal[1:1];
 bui.terUniCoo.retAir.ports[1].C_outflow[1:0] = bui.terUniCoo.retAir.C_in_internal[1:0];
 der(bui.terUniCoo.TLoaODE.TAir) * bui.terUniCoo.TLoaODE.tau = (bui.terUniCoo.TLoaODE.QAct_flow - bui.terUniCoo.TLoaODE.QReq_flow) / bui.terUniCoo.TLoaODE.G + bui.terUniCoo.TLoaODE.TSet - bui.terUniCoo.TLoaODE.TAir;
 assert(bui.terUniCoo.TLoaODE.TAir >= 273.15, "In " + "CouplingETS_TimeSeriesBuilding.bui.terUniCoo.TLoaODE" + ": The computed indoor temperature is below 0°C.");
 bui.terUniCoo.gaiHeaFlo.y = -6.804572672836146E-6 * bui.terUniCoo.gaiHeaFlo.u;
 bui.terUniCoo.gaiHeaFlo1.y = -6.804572672836146E-6 * bui.terUniCoo.gaiHeaFlo1.u;
 bui.terUniCoo.scaQReqCoo_flow.y = bui.terUniCoo.scaQReqCoo_flow.k * bui.terUniCoo.scaQReqCoo_flow.u;
 bui.terUniCoo.scaQActCoo_flow.y = bui.terUniCoo.scaQActCoo_flow.k * bui.terUniCoo.scaQActCoo_flow.u;
 bui.terUniCoo.scaPFan.y = bui.terUniCoo.scaPFan.k * bui.terUniCoo.scaPFan.u;
 bui.terUniCoo.scaMasFloReqChiWat.y = bui.terUniCoo.scaMasFloReqChiWat.k * bui.terUniCoo.scaMasFloReqChiWat.u;
 bui.terUniCoo.scaChiWatFloInl.port_a.p = bui.terUniCoo.scaChiWatFloInl.port_b.p;
 bui.terUniCoo.scaChiWatFloInl.port_b.m_flow = (- bui.terUniCoo.scaChiWatFloInl.k) * bui.terUniCoo.scaChiWatFloInl.port_a.m_flow;
 bui.terUniCoo.scaChiWatFloInl.port_a.h_outflow = inStream(bui.terUniCoo.scaChiWatFloInl.port_b.h_outflow);
 bui.terUniCoo.scaChiWatFloInl.port_b.h_outflow = inStream(bui.terUniCoo.scaChiWatFloInl.port_a.h_outflow);
 bui.terUniCoo.scaChiWatFloInl.port_a.Xi_outflow[1:0] = inStream(bui.terUniCoo.scaChiWatFloInl.port_b.Xi_outflow[1:0]);
 bui.terUniCoo.scaChiWatFloInl.port_b.Xi_outflow[1:0] = inStream(bui.terUniCoo.scaChiWatFloInl.port_a.Xi_outflow[1:0]);
 bui.terUniCoo.scaChiWatFloInl.port_a.C_outflow[1:0] = inStream(bui.terUniCoo.scaChiWatFloInl.port_b.C_outflow[1:0]);
 bui.terUniCoo.scaChiWatFloInl.port_b.C_outflow[1:0] = inStream(bui.terUniCoo.scaChiWatFloInl.port_a.C_outflow[1:0]);
 bui.terUniCoo.scaChiWatFloOut.port_a.p = bui.terUniCoo.scaChiWatFloOut.port_b.p;
 bui.terUniCoo.scaChiWatFloOut.port_b.m_flow = (- bui.terUniCoo.scaChiWatFloOut.k) * bui.terUniCoo.scaChiWatFloOut.port_a.m_flow;
 bui.terUniCoo.scaChiWatFloOut.port_a.h_outflow = inStream(bui.terUniCoo.scaChiWatFloOut.port_b.h_outflow);
 bui.terUniCoo.scaChiWatFloOut.port_b.h_outflow = inStream(bui.terUniCoo.scaChiWatFloOut.port_a.h_outflow);
 bui.terUniCoo.scaChiWatFloOut.port_a.Xi_outflow[1:0] = inStream(bui.terUniCoo.scaChiWatFloOut.port_b.Xi_outflow[1:0]);
 bui.terUniCoo.scaChiWatFloOut.port_b.Xi_outflow[1:0] = inStream(bui.terUniCoo.scaChiWatFloOut.port_a.Xi_outflow[1:0]);
 bui.terUniCoo.scaChiWatFloOut.port_a.C_outflow[1:0] = inStream(bui.terUniCoo.scaChiWatFloOut.port_b.C_outflow[1:0]);
 bui.terUniCoo.scaChiWatFloOut.port_b.C_outflow[1:0] = inStream(bui.terUniCoo.scaChiWatFloOut.port_a.C_outflow[1:0]);
 bui.minTSet.y = bui.minTSet.k;
 bui.maxTSet.y = bui.maxTSet.k;
 if not true then
  supChiWat.m_flow_in_internal = supChiWat.m_flow;
 end if;
 supChiWat.ports[1].p = supChiWat.p_in_internal;
 sum({supChiWat.ports[1].m_flow}) = - supChiWat.m_flow_in_internal;
 if not false then
  supChiWat.T_in_internal = supChiWat.T;
 end if;
 supChiWat.ports[1].h_outflow = supChiWat.h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, supChiWat.X_in_internal[1:1], "Boundary_pT");
 end if;
 if false then
  supChiWat.X_in_internal[1:0] = supChiWat.Xi_in_internal[1:0];
  if true then
   supChiWat.X_in_internal[1] = 1 - sum(supChiWat.Xi_in_internal[1:0]);
  end if;
 elseif false then
  supChiWat.X_in_internal[1:0] = supChiWat.Xi_in_internal[1:0];
 else
  supChiWat.X_in_internal[1:1] = supChiWat.X[1:1];
  supChiWat.Xi_in_internal[1:0] = supChiWat.X[1:0];
 end if;
 if not false then
  supChiWat.C_in_internal[1:0] = supChiWat.C[1:0];
 end if;
 supChiWat.ports[1].Xi_outflow[1:0] = supChiWat.Xi_in_internal[1:0];
 supChiWat.ports[1].C_outflow[1:0] = supChiWat.C_in_internal[1:0];
 if not false then
  supHeaWat.m_flow_in_internal = 8.015774378585085;
 end if;
 supHeaWat.ports[1].p = supHeaWat.p_in_internal;
 sum({supHeaWat.ports[1].m_flow}) = - supHeaWat.m_flow_in_internal;
 if not true then
  supHeaWat.T_in_internal = supHeaWat.T;
 end if;
 supHeaWat.ports[1].h_outflow = supHeaWat.h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, supHeaWat.X_in_internal[1:1], "Boundary_pT");
 end if;
 if false then
  supHeaWat.X_in_internal[1:0] = supHeaWat.Xi_in_internal[1:0];
  if true then
   supHeaWat.X_in_internal[1] = 1 - sum(supHeaWat.Xi_in_internal[1:0]);
  end if;
 elseif false then
  supHeaWat.X_in_internal[1:0] = supHeaWat.Xi_in_internal[1:0];
 else
  supHeaWat.X_in_internal[1:1] = supHeaWat.X[1:1];
  supHeaWat.Xi_in_internal[1:0] = supHeaWat.X[1:0];
 end if;
 if not false then
  supHeaWat.C_in_internal[1:0] = supHeaWat.C[1:0];
 end if;
 supHeaWat.ports[1].Xi_outflow[1:0] = supHeaWat.Xi_in_internal[1:0];
 supHeaWat.ports[1].C_outflow[1:0] = supHeaWat.C_in_internal[1:0];
 if false then
  if true then
   assert(sinChiWat.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.sinChiWat" + ": The value of p_in=" + String(sinChiWat.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if false then
   assert(sinChiWat.p_in_internal > 50000.0 and sinChiWat.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.sinChiWat" + ": The value of p_in=" + String(sinChiWat.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 if not false then
  sinChiWat.p_in_internal = sinChiWat.p;
 end if;
 sinChiWat.ports[1].p = sinChiWat.p_in_internal;
 if not false then
  sinChiWat.T_in_internal = sinChiWat.T;
 end if;
 sinChiWat.ports[1].h_outflow = sinChiWat.h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, sinChiWat.X_in_internal[1:1], "Boundary_pT");
 end if;
 if false then
  sinChiWat.X_in_internal[1:0] = sinChiWat.Xi_in_internal[1:0];
  if true then
   sinChiWat.X_in_internal[1] = 1 - sum(sinChiWat.Xi_in_internal[1:0]);
  end if;
 elseif false then
  sinChiWat.X_in_internal[1:0] = sinChiWat.Xi_in_internal[1:0];
 else
  sinChiWat.X_in_internal[1:1] = sinChiWat.X[1:1];
  sinChiWat.Xi_in_internal[1:0] = sinChiWat.X[1:0];
 end if;
 if not false then
  sinChiWat.C_in_internal[1:0] = sinChiWat.C[1:0];
 end if;
 sinChiWat.ports[1].Xi_outflow[1:0] = sinChiWat.Xi_in_internal[1:0];
 sinChiWat.ports[1].C_outflow[1:0] = sinChiWat.C_in_internal[1:0];
 if false then
  if true then
   assert(sinHeaWat.p_in_internal > 10000.0, "In " + "CouplingETS_TimeSeriesBuilding.sinHeaWat" + ": The value of p_in=" + String(sinHeaWat.p_in_internal) + " is low for water. This is likely an error.");
  end if;
  if false then
   assert(sinHeaWat.p_in_internal > 50000.0 and sinHeaWat.p_in_internal < 150000.0, "In " + "CouplingETS_TimeSeriesBuilding.sinHeaWat" + ": The value of p_in=" + String(sinHeaWat.p_in_internal) + " is not within a realistic range for air. This is likely an error.");
  end if;
 end if;
 if not false then
  sinHeaWat.p_in_internal = sinHeaWat.p;
 end if;
 sinHeaWat.ports[1].p = sinHeaWat.p_in_internal;
 if not false then
  sinHeaWat.T_in_internal = sinHeaWat.T;
 end if;
 sinHeaWat.ports[1].h_outflow = sinHeaWat.h_internal;
 if false or false then
  Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, sinHeaWat.X_in_internal[1:1], "Boundary_pT");
 end if;
 if false then
  sinHeaWat.X_in_internal[1:0] = sinHeaWat.Xi_in_internal[1:0];
  if true then
   sinHeaWat.X_in_internal[1] = 1 - sum(sinHeaWat.Xi_in_internal[1:0]);
  end if;
 elseif false then
  sinHeaWat.X_in_internal[1:0] = sinHeaWat.Xi_in_internal[1:0];
 else
  sinHeaWat.X_in_internal[1:1] = sinHeaWat.X[1:1];
  sinHeaWat.Xi_in_internal[1:0] = sinHeaWat.X[1:0];
 end if;
 if not false then
  sinHeaWat.C_in_internal[1:0] = sinHeaWat.C[1:0];
 end if;
 sinHeaWat.ports[1].Xi_outflow[1:0] = sinHeaWat.Xi_in_internal[1:0];
 sinHeaWat.ports[1].C_outflow[1:0] = sinHeaWat.C_in_internal[1:0];
 pumBui.inputSwitch.y = pumBui.inputSwitch.u;
 if not true then
  assert(pumBui.vol.ports[1].m_flow > -7.024856596558318E-4, "In " + "CouplingETS_TimeSeriesBuilding.pumBui.vol" + ": Model has flow reversal,
  but the parameter allowFlowReversal is set to false.
  m_flow_small    = " + String(7.024856596558318E-4) + "
  ports[1].m_flow = " + String(pumBui.vol.ports[1].m_flow) + "
");
 end if;
 if false then
  pumBui.vol.U = 0;
  pumBui.vol.mXi[1:0] = zeros(0);
  pumBui.vol.m = 0;
  pumBui.vol.mC[1:0] = zeros(0);
 end if;
 if not false then
  pumBui.vol.dynBal.mWat_flow_internal = 0;
 end if;
 if not false then
  pumBui.vol.dynBal.C_flow_internal[1:0] = zeros(0);
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  pumBui.vol.dynBal.m = pumBui.vol.dynBal.fluidVolume * pumBui.vol.dynBal.rho_start;
 else
  if false then
   pumBui.vol.dynBal.m = pumBui.vol.dynBal.fluidVolume * Buildings.Media.Water.density(Buildings.Media.Water.setState_phX(pumBui.vol.dynBal.medium.p, pumBui.vol.dynBal.hOut, {1.0}));
  else
   pumBui.vol.dynBal.m = pumBui.vol.dynBal.fluidVolume * pumBui.vol.dynBal.medium.d;
  end if;
 end if;
 pumBui.vol.dynBal.mXi[1:0] = pumBui.vol.dynBal.m * pumBui.vol.dynBal.medium.Xi[1:0];
 if false then
  pumBui.vol.dynBal.U = pumBui.vol.dynBal.m * pumBui.vol.dynBal.medium.u + pumBui.vol.dynBal.CSen * (pumBui.vol.dynBal.medium.T - 273.15);
 else
  pumBui.vol.dynBal.U = pumBui.vol.dynBal.m * pumBui.vol.dynBal.medium.u;
 end if;
 pumBui.vol.dynBal.mC[1:0] = pumBui.vol.dynBal.m * pumBui.vol.dynBal.C[1:0];
 pumBui.vol.dynBal.hOut = pumBui.vol.dynBal.medium.h;
 pumBui.vol.dynBal.XiOut[1:0] = pumBui.vol.dynBal.medium.Xi[1:0];
 pumBui.vol.dynBal.COut[1:0] = pumBui.vol.dynBal.C[1:0];
 pumBui.vol.dynBal.ports_H_flow[1] = semiLinear(pumBui.vol.dynBal.ports[1].m_flow, inStream(pumBui.vol.dynBal.ports[1].h_outflow), pumBui.vol.dynBal.ports[1].h_outflow);
 pumBui.vol.dynBal.ports_H_flow[2] = semiLinear(pumBui.vol.dynBal.ports[2].m_flow, inStream(pumBui.vol.dynBal.ports[2].h_outflow), pumBui.vol.dynBal.ports[2].h_outflow);
 pumBui.vol.dynBal.mb_flow = sum({pumBui.vol.dynBal.ports[1].m_flow, pumBui.vol.dynBal.ports[2].m_flow});
 pumBui.vol.dynBal.Hb_flow = sum(pumBui.vol.dynBal.ports_H_flow[1:2]);
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  0 = pumBui.vol.dynBal.Hb_flow + pumBui.vol.dynBal.Q_flow;
 else
  der(pumBui.vol.dynBal.U) = pumBui.vol.dynBal.Hb_flow + pumBui.vol.dynBal.Q_flow;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  0 = pumBui.vol.dynBal.mb_flow;
 else
  der(pumBui.vol.dynBal.m) = pumBui.vol.dynBal.mb_flow;
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  zeros(0) = pumBui.vol.dynBal.mbXi_flow[1:0] + pumBui.vol.dynBal.mWat_flow_internal * fill(0.0, 0);
 else
  der(pumBui.vol.dynBal.mXi[1:0]) = pumBui.vol.dynBal.mbXi_flow[1:0] + pumBui.vol.dynBal.mWat_flow_internal * fill(0.0, 0);
 end if;
 if Modelica.Fluid.Types.Dynamics.FixedInitial == Modelica.Fluid.Types.Dynamics.SteadyState then
  zeros(0) = pumBui.vol.dynBal.mbC_flow[1:0] + pumBui.vol.dynBal.C_flow_internal[1:0];
 else
  der(pumBui.vol.dynBal.mC[1:0]) = pumBui.vol.dynBal.mbC_flow[1:0] + pumBui.vol.dynBal.C_flow_internal[1:0];
 end if;
 pumBui.vol.dynBal.ports[1].p = pumBui.vol.dynBal.medium.p;
 pumBui.vol.dynBal.ports[1].h_outflow = pumBui.vol.dynBal.medium.h;
 pumBui.vol.dynBal.ports[1].Xi_outflow[1:0] = pumBui.vol.dynBal.medium.Xi[1:0];
 pumBui.vol.dynBal.ports[1].C_outflow[1:0] = pumBui.vol.dynBal.C[1:0];
 pumBui.vol.dynBal.ports[2].p = pumBui.vol.dynBal.medium.p;
 pumBui.vol.dynBal.ports[2].h_outflow = pumBui.vol.dynBal.medium.h;
 pumBui.vol.dynBal.ports[2].Xi_outflow[1:0] = pumBui.vol.dynBal.medium.Xi[1:0];
 pumBui.vol.dynBal.ports[2].C_outflow[1:0] = pumBui.vol.dynBal.C[1:0];
 pumBui.vol.dynBal.UOut = pumBui.vol.dynBal.U;
 pumBui.vol.dynBal.mXiOut[1:0] = pumBui.vol.dynBal.mXi[1:0];
 pumBui.vol.dynBal.mOut = pumBui.vol.dynBal.m;
 pumBui.vol.dynBal.mCOut[1:0] = pumBui.vol.dynBal.mC[1:0];
 assert(pumBui.vol.dynBal.medium.T >= 272.15, "
  In " + "CouplingETS_TimeSeriesBuilding.pumBui.vol.dynBal.medium" + ": Temperature T = " + String(pumBui.vol.dynBal.medium.T) + " K exceeded its minimum allowed value of " + String(272.15 - 273.15) + " degC (" + String(272.15) + " Kelvin)
as required from medium model \"" + "SimpleLiquidWater" + "\".");
 assert(pumBui.vol.dynBal.medium.T <= 403.15, "
  In " + "CouplingETS_TimeSeriesBuilding.pumBui.vol.dynBal.medium" + ": Temperature T = " + String(pumBui.vol.dynBal.medium.T) + " K exceeded its maximum allowed value of " + String(403.15 - 273.15) + " degC (" + String(403.15) + " Kelvin)
as required from medium model \"" + "SimpleLiquidWater" + "\".");
 pumBui.vol.dynBal.medium.h = 4184.0 * (pumBui.vol.dynBal.medium.T - 273.15);
 pumBui.vol.dynBal.medium.u = pumBui.vol.dynBal.medium.h;
 pumBui.vol.dynBal.medium.state.T = pumBui.vol.dynBal.medium.T;
 pumBui.vol.dynBal.medium.state.p = pumBui.vol.dynBal.medium.p;
 pumBui.vol.preTem.port.T = pumBui.vol.preTem.T;
 pumBui.vol.heaFloSen.port_a.T = pumBui.vol.heaFloSen.port_b.T;
 pumBui.vol.heaFloSen.port_a.Q_flow + pumBui.vol.heaFloSen.port_b.Q_flow = 0;
 pumBui.vol.heaFloSen.Q_flow = pumBui.vol.heaFloSen.port_a.Q_flow;
 if true then
  pumBui.preSou.m_flow = pumBui.preSou.m_flow_internal;
 else
  pumBui.preSou.m_flow_internal = 0;
 end if;
 if false then
  pumBui.preSou.dp = pumBui.preSou.dp_internal;
 else
  pumBui.preSou.dp_internal = 0;
 end if;
 pumBui.preSou.port_a.h_outflow = inStream(pumBui.preSou.port_b.h_outflow);
 pumBui.preSou.port_b.h_outflow = inStream(pumBui.preSou.port_a.h_outflow);
 pumBui.preSou.dp = pumBui.preSou.port_a.p - pumBui.preSou.port_b.p;
 pumBui.preSou.m_flow = pumBui.preSou.port_a.m_flow;
 assert(pumBui.preSou.m_flow > -7.024856596558318E-4 or true, "Reverting flow occurs even though allowFlowReversal is false");
 pumBui.preSou.port_a.m_flow + pumBui.preSou.port_b.m_flow = 0;
 pumBui.preSou.port_a.Xi_outflow[1:0] = inStream(pumBui.preSou.port_b.Xi_outflow[1:0]);
 pumBui.preSou.port_b.Xi_outflow[1:0] = inStream(pumBui.preSou.port_a.Xi_outflow[1:0]);
 pumBui.preSou.port_a.C_outflow[1:0] = inStream(pumBui.preSou.port_b.C_outflow[1:0]);
 pumBui.preSou.port_b.C_outflow[1:0] = inStream(pumBui.preSou.port_a.C_outflow[1:0]);
 pumBui.heaDis.etaHyd * pumBui.heaDis.WHyd = pumBui.heaDis.WFlo;
 pumBui.heaDis.QThe_flow + pumBui.heaDis.WFlo = if pumBui.heaDis.motorCooledByFluid then pumBui.heaDis.PEle else pumBui.heaDis.WHyd;
 pumBui.heaDis.Q_flow = Buildings.Utilities.Math.Functions.regStep(noEvent(abs(pumBui.heaDis.V_flow)) - 2 * 7.056001788452547E-6, pumBui.heaDis.QThe_flow, 0, 7.056001788452547E-6);
 pumBui.PToMed.y = pumBui.PToMed.u1 + pumBui.PToMed.u2;
 pumBui.prePow.port.Q_flow = (- pumBui.prePow.Q_flow) * 1;
 pumBui.senMasFlo.m_flow = pumBui.senMasFlo.port_a.m_flow;
 pumBui.senMasFlo.port_b.m_flow = - pumBui.senMasFlo.port_a.m_flow;
 pumBui.senMasFlo.port_a.p = pumBui.senMasFlo.port_b.p;
 pumBui.senMasFlo.port_a.h_outflow = inStream(pumBui.senMasFlo.port_b.h_outflow);
 pumBui.senMasFlo.port_b.h_outflow = inStream(pumBui.senMasFlo.port_a.h_outflow);
 pumBui.senMasFlo.port_a.Xi_outflow[1:0] = inStream(pumBui.senMasFlo.port_b.Xi_outflow[1:0]);
 pumBui.senMasFlo.port_b.Xi_outflow[1:0] = inStream(pumBui.senMasFlo.port_a.Xi_outflow[1:0]);
 pumBui.senMasFlo.port_a.C_outflow[1:0] = inStream(pumBui.senMasFlo.port_b.C_outflow[1:0]);
 pumBui.senMasFlo.port_b.C_outflow[1:0] = inStream(pumBui.senMasFlo.port_a.C_outflow[1:0]);
 pumBui.senRelPre.port_a.m_flow = 0;
 pumBui.senRelPre.port_b.m_flow = 0;
 pumBui.senRelPre.port_a.h_outflow = 0;
 pumBui.senRelPre.port_b.h_outflow = 0;
 pumBui.senRelPre.port_a.Xi_outflow[1:0] = zeros(0);
 pumBui.senRelPre.port_b.Xi_outflow[1:0] = zeros(0);
 pumBui.senRelPre.port_a.C_outflow[1:0] = zeros(0);
 pumBui.senRelPre.port_b.C_outflow[1:0] = zeros(0);
 pumBui.senRelPre.p_rel = pumBui.senRelPre.port_a.p - pumBui.senRelPre.port_b.p;
 pumBui.eff.y_out = pumBui.eff.r_N;
 pumBui.eff.V_flow = pumBui.eff.m_flow / pumBui.eff.rho;
 pumBui.eff.r_V = pumBui.eff.V_flow / 0.007056001788452546;
 if false == false and Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate <> Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed then
  pumBui.eff.r_N = 1;
 else
  if 1 == 1 then
   if true then
    pumBui.eff.V_flow * 10629.249006532391 + pumBui.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(pumBui.eff.V_flow, pumBui.eff.r_N, pumBui.eff.preDer1[1:2], 300000.0, 0.007056001788452546, pumBui.eff.pCur1);
   else
    pumBui.eff.V_flow * 10629.249006532391 + pumBui.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(pumBui.eff.V_flow, pumBui.eff.r_N, pumBui.eff.preDer1[1:2], 300000.0, 0.007056001788452546, pumBui.eff.pCur1);
   end if;
  elseif 1 == 2 then
   if true then
    pumBui.eff.V_flow * 10629.249006532391 + pumBui.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(pumBui.eff.V_flow, pumBui.eff.r_N, pumBui.eff.preDer2[1:3], 300000.0, 0.007056001788452546, pumBui.eff.pCur2);
   else
    pumBui.eff.V_flow * 10629.249006532391 + pumBui.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(pumBui.eff.V_flow, pumBui.eff.r_N, pumBui.eff.preDer2[1:3], 300000.0, 0.007056001788452546, pumBui.eff.pCur2);
   end if;
  else
   if true then
    pumBui.eff.V_flow * 10629.249006532391 + pumBui.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(pumBui.eff.V_flow, pumBui.eff.r_N, pumBui.eff.preDer3[1:4], 300000.0, 0.007056001788452546, pumBui.eff.pCur3);
   else
    pumBui.eff.V_flow * 10629.249006532391 + pumBui.eff.dp_internal = Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure(pumBui.eff.V_flow, pumBui.eff.r_N, pumBui.eff.preDer3[1:4], 300000.0, 0.007056001788452546, pumBui.eff.pCur3);
   end if;
  end if;
 end if;
 pumBui.eff.WFlo = pumBui.eff.dp_internal * pumBui.eff.V_flow;
 if false then
  if true then
   pumBui.eff.PEle = Buildings.Fluid.Movers.BaseClasses.Characteristics.power(pumBui.eff.per.power, pumBui.eff.V_flow, pumBui.eff.r_N, pumBui.eff.powDer[1:1], 0.05);
  else
   pumBui.eff.PEle = pumBui.eff.rho / 995.586 * Buildings.Fluid.Movers.BaseClasses.Characteristics.power(pumBui.eff.per.power, pumBui.eff.V_flow, pumBui.eff.r_N, pumBui.eff.powDer[1:1], 0.05);
  end if;
  pumBui.eff.eta = pumBui.eff.WFlo / Buildings.Utilities.Math.Functions.smoothMax(pumBui.eff.PEle, 1.0E-5, 1.0E-6);
  pumBui.eff.etaHyd = 1;
  pumBui.eff.etaMot = pumBui.eff.eta;
 else
  if true then
   pumBui.eff.etaHyd = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(pumBui.eff.per.hydraulicEfficiency, pumBui.eff.V_flow, pumBui.eff.hydDer[1:1], pumBui.eff.r_N, 0.05);
   pumBui.eff.etaMot = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(pumBui.eff.per.motorEfficiency, pumBui.eff.V_flow, pumBui.eff.motDer[1:1], pumBui.eff.r_N, 0.05);
  else
   pumBui.eff.etaHyd = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(pumBui.eff.per.hydraulicEfficiency, pumBui.eff.V_flow, pumBui.eff.hydDer[1:1], pumBui.eff.r_N, 0.05);
   pumBui.eff.etaMot = Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(pumBui.eff.per.motorEfficiency, pumBui.eff.V_flow, pumBui.eff.motDer[1:1], pumBui.eff.r_N, 0.05);
  end if;
  pumBui.eff.PEle = pumBui.eff.WFlo / Buildings.Utilities.Math.Functions.smoothMax(pumBui.eff.eta, 1.0E-5, 1.0E-6);
  pumBui.eff.eta = pumBui.eff.etaHyd * pumBui.eff.etaMot;
 end if;
 Modelica.Fluid.Utilities.checkBoundary("SimpleLiquidWater", {"SimpleLiquidWater"}, true, true, pre.X[1:1], "FixedBoundary");
 if true or true then
  if false then
   pre.state = Buildings.Media.Water.setState_pTX(pre.p, pre.T, pre.X[1:1]);
  else
   pre.state = Buildings.Media.Water.setState_phX(pre.p, pre.h, pre.X[1:1]);
  end if;
  if Modelica.Media.Interfaces.Choices.IndependentVariables.pT == Modelica.Media.Interfaces.Choices.IndependentVariables.dTX then
   pre.medium.d = Buildings.Media.Water.density(pre.state);
  else
   pre.medium.p = Buildings.Media.Water.pressure(pre.state);
  end if;
  if Modelica.Media.Interfaces.Choices.IndependentVariables.pT == Modelica.Media.Interfaces.Choices.IndependentVariables.ph or Modelica.Media.Interfaces.Choices.IndependentVariables.pT == Modelica.Media.Interfaces.Choices.IndependentVariables.phX then
   pre.medium.h = Buildings.Media.Water.specificEnthalpy(pre.state);
  else
   pre.medium.T = Buildings.Media.Water.temperature(pre.state);
  end if;
 else
  if false then
   pre.state = Buildings.Media.Water.setState_dTX(995.586, pre.T, pre.X[1:1]);
   if Modelica.Media.Interfaces.Choices.IndependentVariables.pT == Modelica.Media.Interfaces.Choices.IndependentVariables.dTX then
    pre.medium.d = Buildings.Media.Water.density(pre.state);
   else
    pre.medium.p = Buildings.Media.Water.pressure(pre.state);
   end if;
   if Modelica.Media.Interfaces.Choices.IndependentVariables.pT == Modelica.Media.Interfaces.Choices.IndependentVariables.ph or Modelica.Media.Interfaces.Choices.IndependentVariables.pT == Modelica.Media.Interfaces.Choices.IndependentVariables.phX then
    pre.medium.h = Buildings.Media.Water.specificEnthalpy(pre.state);
   else
    pre.medium.T = Buildings.Media.Water.temperature(pre.state);
   end if;
  else
   pre.medium.d = 995.586;
   pre.medium.h = pre.h;
   pre.state = Buildings.Media.Water.setState_dTX(995.586, pre.T, pre.X[1:1]);
  end if;
 end if;
 pre.medium.Xi[1:0] = pre.X[1:0];
 fill(0.0, 1, 0) = fill(pre.C[1:0], 1);
 assert(cardinality(pre.ports[1]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
 pre.ports[1].p = pre.medium.p;
 pre.ports[1].h_outflow = pre.medium.h;
 pre.ports[1].Xi_outflow[1:0] = pre.medium.Xi[1:0];
 assert(pre.medium.T >= 272.15, "
  In " + "CouplingETS_TimeSeriesBuilding.pre.medium" + ": Temperature T = " + String(pre.medium.T) + " K exceeded its minimum allowed value of " + String(272.15 - 273.15) + " degC (" + String(272.15) + " Kelvin)
as required from medium model \"" + "SimpleLiquidWater" + "\".");
 assert(pre.medium.T <= 403.15, "
  In " + "CouplingETS_TimeSeriesBuilding.pre.medium" + ": Temperature T = " + String(pre.medium.T) + " K exceeded its maximum allowed value of " + String(403.15 - 273.15) + " degC (" + String(403.15) + " Kelvin)
as required from medium model \"" + "SimpleLiquidWater" + "\".");
 pre.medium.h = 4184.0 * (pre.medium.T - 273.15);
 pre.medium.u = pre.medium.h;
 pre.medium.state.T = pre.medium.T;
 pre.medium.state.p = pre.medium.p;
 TChiWatSet.y = coo.TSet;
 THeaWatSup.y = supHeaWat.T_in;
 pumBui.m_flow_in = secMasFloRat.y;
 coo.port_a1.m_flow + supChiWat.ports[1].m_flow = 0.0;
 coo.port_a1.p = supChiWat.ports[1].p;
 coo.port_b2.m_flow + pre.ports[1].m_flow + pumBui.port_a.m_flow = 0.0;
 coo.port_b2.p = pre.ports[1].p;
 pre.ports[1].p = pumBui.port_a.p;
 priMasFloRat.y = supChiWat.m_flow_in;
 coo.port_b1.m_flow + sinChiWat.ports[1].m_flow = 0.0;
 coo.port_b1.p = sinChiWat.ports[1].p;
 bui.secHeaSup[1].m_flow + supHeaWat.ports[1].m_flow = 0.0;
 bui.secHeaSup[1].p = supHeaWat.ports[1].p;
 bui.secHeaRet[1].m_flow + sinHeaWat.ports[1].m_flow = 0.0;
 bui.secHeaRet[1].p = sinHeaWat.ports[1].p;
 bui.secCooSup[1].m_flow + pumBui.port_b.m_flow = 0.0;
 bui.secCooSup[1].p = pumBui.port_b.p;
 bui.secCooRet[1].m_flow + coo.port_a2.m_flow = 0.0;
 bui.secCooRet[1].p = coo.port_a2.p;
 coo.hex.port_b1.m_flow + coo.senTDisRet.port_a.m_flow = 0.0;
 coo.hex.port_b1.p = coo.senTDisRet.port_a.p;
 coo.hex.port_a1.m_flow + coo.val.port_b.m_flow = 0.0;
 coo.hex.port_a1.p = coo.val.port_b.p;
 coo.senMasFlo.port_b.m_flow + coo.val.port_a.m_flow = 0.0;
 coo.senMasFlo.port_b.p = coo.val.port_a.p;
 coo.port_a1.C_outflow[1:0] = coo.senTDisSup.port_a.C_outflow[1:0];
 coo.port_a1.Xi_outflow[1:0] = coo.senTDisSup.port_a.Xi_outflow[1:0];
 coo.port_a1.h_outflow = coo.senTDisSup.port_a.h_outflow;
 - coo.port_a1.m_flow + coo.senTDisSup.port_a.m_flow = 0.0;
 coo.port_a1.p = coo.senTDisSup.port_a.p;
 coo.senMasFlo.port_a.m_flow + coo.senTDisSup.port_b.m_flow = 0.0;
 coo.senMasFlo.port_a.p = coo.senTDisSup.port_b.p;
 coo.port_b2.C_outflow[1:0] = coo.TBuiSup.port_b.C_outflow[1:0];
 coo.port_b2.Xi_outflow[1:0] = coo.TBuiSup.port_b.Xi_outflow[1:0];
 coo.port_b2.h_outflow = coo.TBuiSup.port_b.h_outflow;
 coo.TBuiSup.port_b.m_flow - coo.port_b2.m_flow = 0.0;
 coo.TBuiSup.port_b.p = coo.port_b2.p;
 coo.port_b1.C_outflow[1:0] = coo.senTDisRet.port_b.C_outflow[1:0];
 coo.port_b1.Xi_outflow[1:0] = coo.senTDisRet.port_b.Xi_outflow[1:0];
 coo.port_b1.h_outflow = coo.senTDisRet.port_b.h_outflow;
 - coo.port_b1.m_flow + coo.senTDisRet.port_b.m_flow = 0.0;
 coo.port_b1.p = coo.senTDisRet.port_b.p;
 coo.TSet = coo.con.u_s;
 coo.TBuiSup.T = coo.con.u_m;
 coo.con.y = coo.val.y;
 coo.TBuiSup.port_a.m_flow + coo.hex.port_b2.m_flow = 0.0;
 coo.TBuiSup.port_a.p = coo.hex.port_b2.p;
 coo.cp.u = coo.pro.y;
 coo.pro.u2 = coo.senMasFlo.m_flow;
 coo.dTDis.u1 = coo.senTDisSup.T;
 coo.dTDis.u2 = coo.senTDisRet.T;
 coo.dTDis.y = coo.pro.u1;
 coo.Q_flow = coo.cp.y;
 coo.cp.y = coo.int.u;
 coo.Q = coo.int.y;
 coo.TBuiRet.port_b.m_flow + coo.hex.port_a2.m_flow = 0.0;
 coo.TBuiRet.port_b.p = coo.hex.port_a2.p;
 coo.port_a2.C_outflow[1:0] = coo.TBuiRet.port_a.C_outflow[1:0];
 coo.port_a2.Xi_outflow[1:0] = coo.TBuiRet.port_a.Xi_outflow[1:0];
 coo.port_a2.h_outflow = coo.TBuiRet.port_a.h_outflow;
 coo.TBuiRet.port_a.m_flow - coo.port_a2.m_flow = 0.0;
 coo.TBuiRet.port_a.p = coo.port_a2.p;
 coo.hex.port_a1.C_outflow[1:0] = coo.hex.bal1.port_a.C_outflow[1:0];
 coo.hex.port_a1.Xi_outflow[1:0] = coo.hex.bal1.port_a.Xi_outflow[1:0];
 coo.hex.port_a1.h_outflow = coo.hex.bal1.port_a.h_outflow;
 coo.hex.bal1.port_a.m_flow - coo.hex.port_a1.m_flow = 0.0;
 coo.hex.bal1.port_a.p = coo.hex.port_a1.p;
 coo.hex.port_b1.C_outflow[1:0] = coo.hex.bal1.port_b.C_outflow[1:0];
 coo.hex.port_b1.Xi_outflow[1:0] = coo.hex.bal1.port_b.Xi_outflow[1:0];
 coo.hex.port_b1.h_outflow = coo.hex.bal1.port_b.h_outflow;
 coo.hex.bal1.port_b.m_flow - coo.hex.port_b1.m_flow = 0.0;
 coo.hex.bal1.port_b.p = coo.hex.port_b1.p;
 coo.hex.port_a2.C_outflow[1:0] = coo.hex.bal2.port_a.C_outflow[1:0];
 coo.hex.port_a2.Xi_outflow[1:0] = coo.hex.bal2.port_a.Xi_outflow[1:0];
 coo.hex.port_a2.h_outflow = coo.hex.bal2.port_a.h_outflow;
 coo.hex.bal2.port_a.m_flow - coo.hex.port_a2.m_flow = 0.0;
 coo.hex.bal2.port_a.p = coo.hex.port_a2.p;
 coo.hex.port_b2.C_outflow[1:0] = coo.hex.bal2.port_b.C_outflow[1:0];
 coo.hex.port_b2.Xi_outflow[1:0] = coo.hex.bal2.port_b.Xi_outflow[1:0];
 coo.hex.port_b2.h_outflow = coo.hex.bal2.port_b.h_outflow;
 coo.hex.bal2.port_b.m_flow - coo.hex.port_b2.m_flow = 0.0;
 coo.hex.bal2.port_b.p = coo.hex.port_b2.p;
 coo.hex.bal1.hOut = coo.hex.bal1.vol.hOut;
 coo.hex.bal1.port_a.C_outflow[1:0] = coo.hex.bal1.preDro.port_a.C_outflow[1:0];
 coo.hex.bal1.port_a.Xi_outflow[1:0] = coo.hex.bal1.preDro.port_a.Xi_outflow[1:0];
 coo.hex.bal1.port_a.h_outflow = coo.hex.bal1.preDro.port_a.h_outflow;
 - coo.hex.bal1.port_a.m_flow + coo.hex.bal1.preDro.port_a.m_flow = 0.0;
 coo.hex.bal1.port_a.p = coo.hex.bal1.preDro.port_a.p;
 coo.hex.bal1.preDro.port_b.m_flow + coo.hex.bal1.vol.port_a.m_flow = 0.0;
 coo.hex.bal1.preDro.port_b.p = coo.hex.bal1.vol.port_a.p;
 coo.hex.bal1.port_b.C_outflow[1:0] = coo.hex.bal1.vol.port_b.C_outflow[1:0];
 coo.hex.bal1.port_b.Xi_outflow[1:0] = coo.hex.bal1.vol.port_b.Xi_outflow[1:0];
 coo.hex.bal1.port_b.h_outflow = coo.hex.bal1.vol.port_b.h_outflow;
 - coo.hex.bal1.port_b.m_flow + coo.hex.bal1.vol.port_b.m_flow = 0.0;
 coo.hex.bal1.port_b.p = coo.hex.bal1.vol.port_b.p;
 coo.hex.bal1.heaInp.y = coo.hex.bal1.vol.Q_flow;
 coo.hex.bal2.hOut = coo.hex.bal2.vol.hOut;
 coo.hex.bal2.port_a.C_outflow[1:0] = coo.hex.bal2.preDro.port_a.C_outflow[1:0];
 coo.hex.bal2.port_a.Xi_outflow[1:0] = coo.hex.bal2.preDro.port_a.Xi_outflow[1:0];
 coo.hex.bal2.port_a.h_outflow = coo.hex.bal2.preDro.port_a.h_outflow;
 - coo.hex.bal2.port_a.m_flow + coo.hex.bal2.preDro.port_a.m_flow = 0.0;
 coo.hex.bal2.port_a.p = coo.hex.bal2.preDro.port_a.p;
 coo.hex.bal2.preDro.port_b.m_flow + coo.hex.bal2.vol.port_a.m_flow = 0.0;
 coo.hex.bal2.preDro.port_b.p = coo.hex.bal2.vol.port_a.p;
 coo.hex.bal2.port_b.C_outflow[1:0] = coo.hex.bal2.vol.port_b.C_outflow[1:0];
 coo.hex.bal2.port_b.Xi_outflow[1:0] = coo.hex.bal2.vol.port_b.Xi_outflow[1:0];
 coo.hex.bal2.port_b.h_outflow = coo.hex.bal2.vol.port_b.h_outflow;
 - coo.hex.bal2.port_b.m_flow + coo.hex.bal2.vol.port_b.m_flow = 0.0;
 coo.hex.bal2.port_b.p = coo.hex.bal2.vol.port_b.p;
 coo.hex.bal2.heaInp.y = coo.hex.bal2.vol.Q_flow;
 coo.con.addD.u1 = coo.con.addI.u1;
 coo.con.addI.u1 = coo.con.addP.u1;
 coo.con.addP.u1 = coo.con.u_s;
 coo.con.P.u = coo.con.addP.y;
 coo.con.D.u = coo.con.addD.y;
 coo.con.I.u = coo.con.addI.y;
 coo.con.P.y = coo.con.addPID.u1;
 coo.con.D.y = coo.con.addPID.u2;
 coo.con.I.y = coo.con.addPID.u3;
 coo.con.addPID.y = coo.con.gainPID.u;
 coo.con.addSat.u2 = coo.con.gainPID.y;
 coo.con.gainPID.y = coo.con.limiter.u;
 coo.con.addSat.u1 = coo.con.limiter.y;
 coo.con.limiter.y = coo.con.y;
 coo.con.addSat.y = coo.con.gainTrack.u;
 coo.con.addI.u3 = coo.con.gainTrack.y;
 coo.con.addD.u2 = coo.con.addI.u2;
 coo.con.addI.u2 = coo.con.addP.u2;
 coo.con.addP.u2 = coo.con.u_m;
 coo.val.y = coo.val.y_actual;
 bui.disFloHea.ports_a1[1].m_flow + bui.terUniHea.port_bHeaWat.m_flow = 0.0;
 bui.disFloHea.ports_a1[1].p = bui.terUniHea.port_bHeaWat.p;
 bui.disFloHea.ports_b1[1].m_flow + bui.terUniHea.port_aHeaWat.m_flow = 0.0;
 bui.disFloHea.ports_b1[1].p = bui.terUniHea.port_aHeaWat.p;
 bui.disFloHea.mReq_flow[1] = bui.terUniHea.mReqHeaWat_flow;
 bui.disFloCoo.mReq_flow[1] = bui.terUniCoo.mReqChiWat_flow;
 bui.QHea_flow = bui.disFloHea.QActTot_flow;
 bui.QCoo_flow = bui.disFloCoo.QActTot_flow;
 bui.loa.y[1] = bui.terUniCoo.QReqCoo_flow;
 bui.loa.y[2] = bui.terUniHea.QReqHea_flow;
 bui.maxTSet.y = bui.terUniCoo.TSetCoo;
 bui.minTSet.y = bui.terUniHea.TSetHea;
 bui.disFloCoo.ports_a1[1].m_flow + bui.terUniCoo.port_bChiWat.m_flow = 0.0;
 bui.disFloCoo.ports_a1[1].p = bui.terUniCoo.port_bChiWat.p;
 bui.disFloCoo.ports_b1[1].m_flow + bui.terUniCoo.port_aChiWat.m_flow = 0.0;
 bui.disFloCoo.ports_b1[1].p = bui.terUniCoo.port_aChiWat.p;
 bui.secHeaSup[1].C_outflow[1:0] = bui.disFloHea.port_a.C_outflow[1:0];
 bui.secHeaSup[1].Xi_outflow[1:0] = bui.disFloHea.port_a.Xi_outflow[1:0];
 bui.secHeaSup[1].h_outflow = bui.disFloHea.port_a.h_outflow;
 bui.disFloHea.port_a.m_flow - bui.secHeaSup[1].m_flow = 0.0;
 bui.disFloHea.port_a.p = bui.secHeaSup[1].p;
 bui.secHeaRet[1].C_outflow[1:0] = bui.disFloHea.port_b.C_outflow[1:0];
 bui.secHeaRet[1].Xi_outflow[1:0] = bui.disFloHea.port_b.Xi_outflow[1:0];
 bui.secHeaRet[1].h_outflow = bui.disFloHea.port_b.h_outflow;
 bui.disFloHea.port_b.m_flow - bui.secHeaRet[1].m_flow = 0.0;
 bui.disFloHea.port_b.p = bui.secHeaRet[1].p;
 bui.secCooRet[1].C_outflow[1:0] = bui.disFloCoo.port_b.C_outflow[1:0];
 bui.secCooRet[1].Xi_outflow[1:0] = bui.disFloCoo.port_b.Xi_outflow[1:0];
 bui.secCooRet[1].h_outflow = bui.disFloCoo.port_b.h_outflow;
 bui.disFloCoo.port_b.m_flow - bui.secCooRet[1].m_flow = 0.0;
 bui.disFloCoo.port_b.p = bui.secCooRet[1].p;
 bui.secCooSup[1].C_outflow[1:0] = bui.disFloCoo.port_a.C_outflow[1:0];
 bui.secCooSup[1].Xi_outflow[1:0] = bui.disFloCoo.port_a.Xi_outflow[1:0];
 bui.secCooSup[1].h_outflow = bui.disFloCoo.port_a.h_outflow;
 bui.disFloCoo.port_a.m_flow - bui.secCooSup[1].m_flow = 0.0;
 bui.disFloCoo.port_a.p = bui.secCooSup[1].p;
 bui.terUniHea.fan.m_flow_in = bui.terUniHea.gaiFloNom2.y;
 bui.terUniHea.con.y = bui.terUniHea.gaiMasFlo.u;
 bui.terUniHea.gaiMasFlo.u = bui.terUniHea.swi.u1;
 bui.terUniHea.gaiMasFlo.y = bui.terUniHea.scaMasFloReqHeaWat.u;
 bui.terUniHea.fan.P = bui.terUniHea.scaPFan.u;
 bui.terUniHea.Q_flowHea.y = bui.terUniHea.TLoaODE.QAct_flow;
 bui.terUniHea.TLoaODE.QAct_flow = bui.terUniHea.gaiHeaFlo1.u;
 bui.terUniHea.gaiHeaFlo1.u = bui.terUniHea.scaQActHea_flow.u;
 bui.terUniHea.fan.port_b.m_flow + bui.terUniHea.hex.port_a2.m_flow = 0.0;
 bui.terUniHea.fan.port_b.p = bui.terUniHea.hex.port_a2.p;
 bui.terUniHea.hex.port_b2.m_flow + bui.terUniHea.sinAir.ports[1].m_flow = 0.0;
 bui.terUniHea.hex.port_b2.p = bui.terUniHea.sinAir.ports[1].p;
 bui.terUniHea.TLoaODE.TSet = bui.terUniHea.TSetHea;
 bui.terUniHea.TLoaODE.TAir = bui.terUniHea.retAir.T_in;
 bui.terUniHea.con.u_s = bui.terUniHea.gaiHeaFlo.y;
 bui.terUniHea.con.u_m = bui.terUniHea.gaiHeaFlo1.y;
 bui.terUniHea.fan.port_a.m_flow + bui.terUniHea.retAir.ports[1].m_flow = 0.0;
 bui.terUniHea.fan.port_a.p = bui.terUniHea.retAir.ports[1].p;
 bui.terUniHea.gaiFloNom2.u = bui.terUniHea.swi.y;
 bui.terUniHea.one.y = bui.terUniHea.swi.u3;
 bui.terUniHea.con1.y = bui.terUniHea.swi.u2;
 bui.terUniHea.TLoaODE.QReq_flow = bui.terUniHea.gaiHeaFlo.u;
 bui.terUniHea.gaiHeaFlo.u = bui.terUniHea.scaQReqHea_flow.y;
 bui.terUniHea.hex.port_a1.m_flow + bui.terUniHea.scaHeaWatFloInl.port_b.m_flow = 0.0;
 bui.terUniHea.hex.port_a1.p = bui.terUniHea.scaHeaWatFloInl.port_b.p;
 bui.terUniHea.hex.port_b1.m_flow + bui.terUniHea.scaHeaWatFloOut.port_a.m_flow = 0.0;
 bui.terUniHea.hex.port_b1.p = bui.terUniHea.scaHeaWatFloOut.port_a.p;
 bui.terUniHea.fan.filter.y = bui.terUniHea.fan.m_flow_actual;
 bui.terUniHea.fan.m_flow_actual = bui.terUniHea.fan.preSou.m_flow_in;
 bui.terUniHea.fan.inputSwitch.u = bui.terUniHea.fan.m_flow_in;
 - bui.terUniHea.fan.heatPort.Q_flow + bui.terUniHea.fan.prePow.port.Q_flow + bui.terUniHea.fan.vol.heatPort.Q_flow = 0.0;
 bui.terUniHea.fan.heatPort.T = bui.terUniHea.fan.prePow.port.T;
 bui.terUniHea.fan.prePow.port.T = bui.terUniHea.fan.vol.heatPort.T;
 bui.terUniHea.fan.port_b.C_outflow[1:0] = inStreamExpansion(zeros(0), _inStreamEpsilon, bui.terUniHea.fan.preSou.port_b.m_flow, bui.terUniHea.fan.preSou.port_b.C_outflow[1:0], false, bui.terUniHea.fan.senRelPre.port_a.m_flow, bui.terUniHea.fan.senRelPre.port_a.C_outflow[1:0], false);
 bui.terUniHea.fan.port_b.Xi_outflow[1:1] = inStreamExpansion(zeros(1), _inStreamEpsilon, bui.terUniHea.fan.preSou.port_b.m_flow, bui.terUniHea.fan.preSou.port_b.Xi_outflow[1:1], false, bui.terUniHea.fan.senRelPre.port_a.m_flow, bui.terUniHea.fan.senRelPre.port_a.Xi_outflow[1:1], false);
 bui.terUniHea.fan.port_b.h_outflow = inStreamExpansion(0.0, _inStreamEpsilon, bui.terUniHea.fan.preSou.port_b.m_flow, bui.terUniHea.fan.preSou.port_b.h_outflow, false, bui.terUniHea.fan.senRelPre.port_a.m_flow, bui.terUniHea.fan.senRelPre.port_a.h_outflow, false);
 - bui.terUniHea.fan.port_b.m_flow + bui.terUniHea.fan.preSou.port_b.m_flow + bui.terUniHea.fan.senRelPre.port_a.m_flow = 0.0;
 bui.terUniHea.fan.port_b.p = bui.terUniHea.fan.preSou.port_b.p;
 bui.terUniHea.fan.preSou.port_b.p = bui.terUniHea.fan.senRelPre.port_a.p;
 bui.terUniHea.fan.PToMed.y = bui.terUniHea.fan.prePow.Q_flow;
 bui.terUniHea.fan.PToMed.u1 = bui.terUniHea.fan.heaDis.Q_flow;
 bui.terUniHea.fan.preSou.port_a.m_flow + bui.terUniHea.fan.senMasFlo.port_b.m_flow + bui.terUniHea.fan.senRelPre.port_b.m_flow = 0.0;
 bui.terUniHea.fan.preSou.port_a.p = bui.terUniHea.fan.senMasFlo.port_b.p;
 bui.terUniHea.fan.senMasFlo.port_b.p = bui.terUniHea.fan.senRelPre.port_b.p;
 bui.terUniHea.fan.eff.etaHyd = bui.terUniHea.fan.heaDis.etaHyd;
 bui.terUniHea.fan.eff.V_flow = bui.terUniHea.fan.heaDis.V_flow;
 bui.terUniHea.fan.P = bui.terUniHea.fan.eff.PEle;
 bui.terUniHea.fan.eff.PEle = bui.terUniHea.fan.heaDis.PEle;
 bui.terUniHea.fan.PToMed.u2 = bui.terUniHea.fan.eff.WFlo;
 bui.terUniHea.fan.eff.WFlo = bui.terUniHea.fan.heaDis.WFlo;
 bui.terUniHea.fan.eff.rho = bui.terUniHea.fan.rho_inlet.y;
 bui.terUniHea.fan.eff.m_flow = bui.terUniHea.fan.senMasFlo.m_flow;
 bui.terUniHea.fan.filter.u = bui.terUniHea.fan.inputSwitch.y;
 bui.terUniHea.fan.eff.dp_in = bui.terUniHea.fan.senRelPre.p_rel;
 bui.terUniHea.fan.eff.y_out = bui.terUniHea.fan.y_actual;
 bui.terUniHea.fan.port_a.C_outflow[1:0] = bui.terUniHea.fan.vol.ports[1].C_outflow[1:0];
 bui.terUniHea.fan.port_a.Xi_outflow[1:1] = bui.terUniHea.fan.vol.ports[1].Xi_outflow[1:1];
 bui.terUniHea.fan.port_a.h_outflow = bui.terUniHea.fan.vol.ports[1].h_outflow;
 - bui.terUniHea.fan.port_a.m_flow + bui.terUniHea.fan.vol.ports[1].m_flow = 0.0;
 bui.terUniHea.fan.port_a.p = bui.terUniHea.fan.vol.ports[1].p;
 bui.terUniHea.fan.senMasFlo.port_a.m_flow + bui.terUniHea.fan.vol.ports[2].m_flow = 0.0;
 bui.terUniHea.fan.senMasFlo.port_a.p = bui.terUniHea.fan.vol.ports[2].p;
 bui.terUniHea.fan.heatPort.Q_flow = 0.0;
 bui.terUniHea.fan.vol.heaFloSen.port_a.Q_flow - bui.terUniHea.fan.vol.heatPort.Q_flow = 0.0;
 bui.terUniHea.fan.vol.heaFloSen.port_a.T = bui.terUniHea.fan.vol.heatPort.T;
 bui.terUniHea.fan.vol.ports[1].C_outflow[1:0] = bui.terUniHea.fan.vol.dynBal.ports[1].C_outflow[1:0];
 bui.terUniHea.fan.vol.ports[1].Xi_outflow[1:1] = bui.terUniHea.fan.vol.dynBal.ports[1].Xi_outflow[1:1];
 bui.terUniHea.fan.vol.ports[1].h_outflow = bui.terUniHea.fan.vol.dynBal.ports[1].h_outflow;
 bui.terUniHea.fan.vol.dynBal.ports[1].m_flow - bui.terUniHea.fan.vol.ports[1].m_flow = 0.0;
 bui.terUniHea.fan.vol.dynBal.ports[1].p = bui.terUniHea.fan.vol.ports[1].p;
 bui.terUniHea.fan.vol.ports[2].C_outflow[1:0] = bui.terUniHea.fan.vol.dynBal.ports[2].C_outflow[1:0];
 bui.terUniHea.fan.vol.ports[2].Xi_outflow[1:1] = bui.terUniHea.fan.vol.dynBal.ports[2].Xi_outflow[1:1];
 bui.terUniHea.fan.vol.ports[2].h_outflow = bui.terUniHea.fan.vol.dynBal.ports[2].h_outflow;
 bui.terUniHea.fan.vol.dynBal.ports[2].m_flow - bui.terUniHea.fan.vol.ports[2].m_flow = 0.0;
 bui.terUniHea.fan.vol.dynBal.ports[2].p = bui.terUniHea.fan.vol.ports[2].p;
 bui.terUniHea.fan.vol.U = bui.terUniHea.fan.vol.dynBal.UOut;
 bui.terUniHea.fan.vol.dynBal.mXiOut[1] = bui.terUniHea.fan.vol.mXi[1];
 bui.terUniHea.fan.vol.dynBal.mOut = bui.terUniHea.fan.vol.m;
 bui.terUniHea.fan.vol.dynBal.hOut = bui.terUniHea.fan.vol.hOut_internal;
 bui.terUniHea.fan.vol.XiOut_internal[1] = bui.terUniHea.fan.vol.dynBal.XiOut[1];
 bui.terUniHea.fan.vol.portT.y = bui.terUniHea.fan.vol.preTem.T;
 bui.terUniHea.fan.vol.heaFloSen.port_b.Q_flow + bui.terUniHea.fan.vol.preTem.port.Q_flow = 0.0;
 bui.terUniHea.fan.vol.heaFloSen.port_b.T = bui.terUniHea.fan.vol.preTem.port.T;
 bui.terUniHea.fan.vol.dynBal.Q_flow = bui.terUniHea.fan.vol.heaFloSen.Q_flow;
 bui.terUniHea.fan.preSou.m_flow_in = bui.terUniHea.fan.preSou.m_flow_internal;
 bui.terUniHea.fan.eff.dp_in = bui.terUniHea.fan.eff.dp_internal;
 bui.terUniHea.con.controlError.u1 = bui.terUniHea.con.uS_revAct.u;
 bui.terUniHea.con.uS_revAct.u = bui.terUniHea.con.u_s;
 bui.terUniHea.con.errI1.u1 = bui.terUniHea.con.uS_revAct.y;
 bui.terUniHea.con.uS_revAct.y = bui.terUniHea.con.uSetWp.u;
 bui.terUniHea.con.controlError.u2 = bui.terUniHea.con.uMea_revAct.u;
 bui.terUniHea.con.uMea_revAct.u = bui.terUniHea.con.u_m;
 bui.terUniHea.con.errP.u1 = bui.terUniHea.con.uSetWp.y;
 bui.terUniHea.con.errI1.u2 = bui.terUniHea.con.errP.u2;
 bui.terUniHea.con.errP.u2 = bui.terUniHea.con.uMea_revAct.y;
 bui.terUniHea.con.addPD.u1 = bui.terUniHea.con.errP.y;
 bui.terUniHea.con.addPD.y = bui.terUniHea.con.addPID.u1;
 bui.terUniHea.con.addPID.y = bui.terUniHea.con.gainPID.u;
 bui.terUniHea.con.antWinErr.u1 = bui.terUniHea.con.gainPID.y;
 bui.terUniHea.con.gainPID.y = bui.terUniHea.con.lim.u;
 bui.terUniHea.con.antWinErr.u2 = bui.terUniHea.con.lim.y;
 bui.terUniHea.con.lim.y = bui.terUniHea.con.y;
 bui.terUniHea.con.antWinErr.y = bui.terUniHea.con.antWinGai.u;
 bui.terUniHea.con.Dzero.y = bui.terUniHea.con.addPD.u2;
 bui.terUniHea.con.I.y = bui.terUniHea.con.addPID.u2;
 bui.terUniHea.con.I.u = bui.terUniHea.con.errI2.y;
 bui.terUniHea.con.errI1.y = bui.terUniHea.con.errI2.u1;
 bui.terUniHea.con.antWinGai.y = bui.terUniHea.con.errI2.u2;
 bui.terUniHea.con.assMesYMinMax.u = bui.terUniHea.con.cheYMinMax.y;
 bui.terUniHea.hex.port_a1.C_outflow[1:0] = bui.terUniHea.hex.bal1.port_a.C_outflow[1:0];
 bui.terUniHea.hex.port_a1.Xi_outflow[1:0] = bui.terUniHea.hex.bal1.port_a.Xi_outflow[1:0];
 bui.terUniHea.hex.port_a1.h_outflow = bui.terUniHea.hex.bal1.port_a.h_outflow;
 bui.terUniHea.hex.bal1.port_a.m_flow - bui.terUniHea.hex.port_a1.m_flow = 0.0;
 bui.terUniHea.hex.bal1.port_a.p = bui.terUniHea.hex.port_a1.p;
 bui.terUniHea.hex.port_b1.C_outflow[1:0] = bui.terUniHea.hex.bal1.port_b.C_outflow[1:0];
 bui.terUniHea.hex.port_b1.Xi_outflow[1:0] = bui.terUniHea.hex.bal1.port_b.Xi_outflow[1:0];
 bui.terUniHea.hex.port_b1.h_outflow = bui.terUniHea.hex.bal1.port_b.h_outflow;
 bui.terUniHea.hex.bal1.port_b.m_flow - bui.terUniHea.hex.port_b1.m_flow = 0.0;
 bui.terUniHea.hex.bal1.port_b.p = bui.terUniHea.hex.port_b1.p;
 bui.terUniHea.hex.port_a2.C_outflow[1:0] = bui.terUniHea.hex.bal2.port_a.C_outflow[1:0];
 bui.terUniHea.hex.port_a2.Xi_outflow[1:1] = bui.terUniHea.hex.bal2.port_a.Xi_outflow[1:1];
 bui.terUniHea.hex.port_a2.h_outflow = bui.terUniHea.hex.bal2.port_a.h_outflow;
 bui.terUniHea.hex.bal2.port_a.m_flow - bui.terUniHea.hex.port_a2.m_flow = 0.0;
 bui.terUniHea.hex.bal2.port_a.p = bui.terUniHea.hex.port_a2.p;
 bui.terUniHea.hex.port_b2.C_outflow[1:0] = bui.terUniHea.hex.bal2.port_b.C_outflow[1:0];
 bui.terUniHea.hex.port_b2.Xi_outflow[1:1] = bui.terUniHea.hex.bal2.port_b.Xi_outflow[1:1];
 bui.terUniHea.hex.port_b2.h_outflow = bui.terUniHea.hex.bal2.port_b.h_outflow;
 bui.terUniHea.hex.bal2.port_b.m_flow - bui.terUniHea.hex.port_b2.m_flow = 0.0;
 bui.terUniHea.hex.bal2.port_b.p = bui.terUniHea.hex.port_b2.p;
 bui.terUniHea.hex.bal1.hOut = bui.terUniHea.hex.bal1.vol.hOut;
 bui.terUniHea.hex.bal1.port_a.C_outflow[1:0] = bui.terUniHea.hex.bal1.preDro.port_a.C_outflow[1:0];
 bui.terUniHea.hex.bal1.port_a.Xi_outflow[1:0] = bui.terUniHea.hex.bal1.preDro.port_a.Xi_outflow[1:0];
 bui.terUniHea.hex.bal1.port_a.h_outflow = bui.terUniHea.hex.bal1.preDro.port_a.h_outflow;
 - bui.terUniHea.hex.bal1.port_a.m_flow + bui.terUniHea.hex.bal1.preDro.port_a.m_flow = 0.0;
 bui.terUniHea.hex.bal1.port_a.p = bui.terUniHea.hex.bal1.preDro.port_a.p;
 bui.terUniHea.hex.bal1.preDro.port_b.m_flow + bui.terUniHea.hex.bal1.vol.port_a.m_flow = 0.0;
 bui.terUniHea.hex.bal1.preDro.port_b.p = bui.terUniHea.hex.bal1.vol.port_a.p;
 bui.terUniHea.hex.bal1.port_b.C_outflow[1:0] = bui.terUniHea.hex.bal1.vol.port_b.C_outflow[1:0];
 bui.terUniHea.hex.bal1.port_b.Xi_outflow[1:0] = bui.terUniHea.hex.bal1.vol.port_b.Xi_outflow[1:0];
 bui.terUniHea.hex.bal1.port_b.h_outflow = bui.terUniHea.hex.bal1.vol.port_b.h_outflow;
 - bui.terUniHea.hex.bal1.port_b.m_flow + bui.terUniHea.hex.bal1.vol.port_b.m_flow = 0.0;
 bui.terUniHea.hex.bal1.port_b.p = bui.terUniHea.hex.bal1.vol.port_b.p;
 bui.terUniHea.hex.bal1.heaInp.y = bui.terUniHea.hex.bal1.vol.Q_flow;
 bui.terUniHea.hex.bal2.hOut = bui.terUniHea.hex.bal2.vol.hOut;
 bui.terUniHea.hex.bal2.XiOut[1] = bui.terUniHea.hex.bal2.vol.XiOut[1];
 bui.terUniHea.hex.bal2.port_a.C_outflow[1:0] = bui.terUniHea.hex.bal2.preDro.port_a.C_outflow[1:0];
 bui.terUniHea.hex.bal2.port_a.Xi_outflow[1:1] = bui.terUniHea.hex.bal2.preDro.port_a.Xi_outflow[1:1];
 bui.terUniHea.hex.bal2.port_a.h_outflow = bui.terUniHea.hex.bal2.preDro.port_a.h_outflow;
 - bui.terUniHea.hex.bal2.port_a.m_flow + bui.terUniHea.hex.bal2.preDro.port_a.m_flow = 0.0;
 bui.terUniHea.hex.bal2.port_a.p = bui.terUniHea.hex.bal2.preDro.port_a.p;
 bui.terUniHea.hex.bal2.preDro.port_b.m_flow + bui.terUniHea.hex.bal2.vol.port_a.m_flow = 0.0;
 bui.terUniHea.hex.bal2.preDro.port_b.p = bui.terUniHea.hex.bal2.vol.port_a.p;
 bui.terUniHea.hex.bal2.port_b.C_outflow[1:0] = bui.terUniHea.hex.bal2.vol.port_b.C_outflow[1:0];
 bui.terUniHea.hex.bal2.port_b.Xi_outflow[1:1] = bui.terUniHea.hex.bal2.vol.port_b.Xi_outflow[1:1];
 bui.terUniHea.hex.bal2.port_b.h_outflow = bui.terUniHea.hex.bal2.vol.port_b.h_outflow;
 - bui.terUniHea.hex.bal2.port_b.m_flow + bui.terUniHea.hex.bal2.vol.port_b.m_flow = 0.0;
 bui.terUniHea.hex.bal2.port_b.p = bui.terUniHea.hex.bal2.vol.port_b.p;
 bui.terUniHea.hex.bal2.heaInp.y = bui.terUniHea.hex.bal2.vol.Q_flow;
 bui.terUniHea.retAir.T_in = bui.terUniHea.retAir.T_in_internal;
 bui.terUniHea.QReqHea_flow = bui.terUniHea.scaQReqHea_flow.u;
 bui.terUniHea.QActHea_flow = bui.terUniHea.scaQActHea_flow.y;
 bui.terUniHea.PFan = bui.terUniHea.scaPFan.y;
 bui.terUniHea.mReqHeaWat_flow = bui.terUniHea.scaMasFloReqHeaWat.y;
 bui.terUniHea.port_aHeaWat.C_outflow[1:0] = bui.terUniHea.scaHeaWatFloInl.port_a.C_outflow[1:0];
 bui.terUniHea.port_aHeaWat.Xi_outflow[1:0] = bui.terUniHea.scaHeaWatFloInl.port_a.Xi_outflow[1:0];
 bui.terUniHea.port_aHeaWat.h_outflow = bui.terUniHea.scaHeaWatFloInl.port_a.h_outflow;
 - bui.terUniHea.port_aHeaWat.m_flow + bui.terUniHea.scaHeaWatFloInl.port_a.m_flow = 0.0;
 bui.terUniHea.port_aHeaWat.p = bui.terUniHea.scaHeaWatFloInl.port_a.p;
 bui.terUniHea.port_bHeaWat.C_outflow[1:0] = bui.terUniHea.scaHeaWatFloOut.port_b.C_outflow[1:0];
 bui.terUniHea.port_bHeaWat.Xi_outflow[1:0] = bui.terUniHea.scaHeaWatFloOut.port_b.Xi_outflow[1:0];
 bui.terUniHea.port_bHeaWat.h_outflow = bui.terUniHea.scaHeaWatFloOut.port_b.h_outflow;
 - bui.terUniHea.port_bHeaWat.m_flow + bui.terUniHea.scaHeaWatFloOut.port_b.m_flow = 0.0;
 bui.terUniHea.port_bHeaWat.p = bui.terUniHea.scaHeaWatFloOut.port_b.p;
 bui.disFloHea.port_b.C_outflow[1:0] = bui.disFloHea.heaCoo.port_b.C_outflow[1:0];
 bui.disFloHea.port_b.Xi_outflow[1:0] = bui.disFloHea.heaCoo.port_b.Xi_outflow[1:0];
 bui.disFloHea.port_b.h_outflow = bui.disFloHea.heaCoo.port_b.h_outflow;
 bui.disFloHea.heaCoo.port_b.m_flow - bui.disFloHea.port_b.m_flow = 0.0;
 bui.disFloHea.heaCoo.port_b.p = bui.disFloHea.port_b.p;
 bui.disFloHea.port_a.C_outflow[1:0] = bui.disFloHea.pipPre.port_a.C_outflow[1:0];
 bui.disFloHea.port_a.Xi_outflow[1:0] = bui.disFloHea.pipPre.port_a.Xi_outflow[1:0];
 bui.disFloHea.port_a.h_outflow = bui.disFloHea.pipPre.port_a.h_outflow;
 bui.disFloHea.pipPre.port_a.m_flow - bui.disFloHea.port_a.m_flow = 0.0;
 bui.disFloHea.pipPre.port_a.p = bui.disFloHea.port_a.p;
 bui.disFloHea.mReqTot_flow = bui.disFloHea.sumMasFloReq.y;
 bui.disFloHea.mReq_flow[1] = bui.disFloHea.sumMasFloReq.u[1];
 bui.disFloHea.mAct_flow[1].y = bui.disFloHea.sou_m_flow[1].m_flow_in;
 bui.disFloHea.ports_a1[1].C_outflow[1:0] = bui.disFloHea.sin.ports[1].C_outflow[1:0];
 bui.disFloHea.ports_a1[1].Xi_outflow[1:0] = bui.disFloHea.sin.ports[1].Xi_outflow[1:0];
 bui.disFloHea.ports_a1[1].h_outflow = bui.disFloHea.sin.ports[1].h_outflow;
 - bui.disFloHea.ports_a1[1].m_flow + bui.disFloHea.sin.ports[1].m_flow = 0.0;
 bui.disFloHea.ports_a1[1].p = bui.disFloHea.sin.ports[1].p;
 bui.disFloHea.ports_b1[1].C_outflow[1:0] = bui.disFloHea.sou_m_flow[1].ports[1].C_outflow[1:0];
 bui.disFloHea.ports_b1[1].Xi_outflow[1:0] = bui.disFloHea.sou_m_flow[1].ports[1].Xi_outflow[1:0];
 bui.disFloHea.ports_b1[1].h_outflow = bui.disFloHea.sou_m_flow[1].ports[1].h_outflow;
 - bui.disFloHea.ports_b1[1].m_flow + bui.disFloHea.sou_m_flow[1].ports[1].m_flow = 0.0;
 bui.disFloHea.ports_b1[1].p = bui.disFloHea.sou_m_flow[1].ports[1].p;
 bui.disFloHea.pipPre.port_b.m_flow + bui.disFloHea.senMasFlo.port_a.m_flow = 0.0;
 bui.disFloHea.pipPre.port_b.p = bui.disFloHea.senMasFlo.port_a.p;
 bui.disFloHea.heaCoo.port_a.m_flow + bui.disFloHea.senMasFlo.port_b.m_flow = 0.0;
 bui.disFloHea.heaCoo.port_a.p = bui.disFloHea.senMasFlo.port_b.p;
 bui.disFloHea.QActTot_flow = bui.disFloHea.Q_flowSum.y;
 bui.disFloHea.Q_flowSum.y = bui.disFloHea.heaCoo.u;
 bui.disFloHea.QAct_flow[1].y = bui.disFloHea.Q_flowSum.u[1];
 bui.disFloHea.TSupVal.y = bui.disFloHea.reaRep.u;
 bui.disFloHea.reaRep.y[1] = bui.disFloHea.sou_m_flow[1].T_in;
 bui.disFloHea.dpNetVal.y = bui.disFloHea.pipPre.dp_in;
 bui.disFloHea.sou_m_flow[1].m_flow_in = bui.disFloHea.sou_m_flow[1].m_flow_in_internal;
 bui.disFloHea.sou_m_flow[1].T_in = bui.disFloHea.sou_m_flow[1].T_in_internal;
 bui.disFloHea.pipPre.dp_in = bui.disFloHea.pipPre.dp_internal;
 bui.disFloHea.heaCoo.gai.u = bui.disFloHea.heaCoo.u;
 bui.disFloHea.heaCoo.Q_flow = bui.disFloHea.heaCoo.gai.y;
 bui.disFloHea.heaCoo.gai.y = bui.disFloHea.heaCoo.preHea.Q_flow;
 bui.disFloHea.heaCoo.preHea.port.Q_flow + bui.disFloHea.heaCoo.vol.heatPort.Q_flow = 0.0;
 bui.disFloHea.heaCoo.preHea.port.T = bui.disFloHea.heaCoo.vol.heatPort.T;
 bui.disFloHea.heaCoo.port_b.C_outflow[1:0] = bui.disFloHea.heaCoo.vol.ports[2].C_outflow[1:0];
 bui.disFloHea.heaCoo.port_b.Xi_outflow[1:0] = bui.disFloHea.heaCoo.vol.ports[2].Xi_outflow[1:0];
 bui.disFloHea.heaCoo.port_b.h_outflow = bui.disFloHea.heaCoo.vol.ports[2].h_outflow;
 - bui.disFloHea.heaCoo.port_b.m_flow + bui.disFloHea.heaCoo.vol.ports[2].m_flow = 0.0;
 bui.disFloHea.heaCoo.port_b.p = bui.disFloHea.heaCoo.vol.ports[2].p;
 bui.disFloHea.heaCoo.port_a.C_outflow[1:0] = bui.disFloHea.heaCoo.preDro.port_a.C_outflow[1:0];
 bui.disFloHea.heaCoo.port_a.Xi_outflow[1:0] = bui.disFloHea.heaCoo.preDro.port_a.Xi_outflow[1:0];
 bui.disFloHea.heaCoo.port_a.h_outflow = bui.disFloHea.heaCoo.preDro.port_a.h_outflow;
 - bui.disFloHea.heaCoo.port_a.m_flow + bui.disFloHea.heaCoo.preDro.port_a.m_flow = 0.0;
 bui.disFloHea.heaCoo.port_a.p = bui.disFloHea.heaCoo.preDro.port_a.p;
 bui.disFloHea.heaCoo.preDro.port_b.m_flow + bui.disFloHea.heaCoo.vol.ports[1].m_flow = 0.0;
 bui.disFloHea.heaCoo.preDro.port_b.p = bui.disFloHea.heaCoo.vol.ports[1].p;
 bui.disFloHea.heaCoo.vol.heaFloSen.port_a.Q_flow - bui.disFloHea.heaCoo.vol.heatPort.Q_flow = 0.0;
 bui.disFloHea.heaCoo.vol.heaFloSen.port_a.T = bui.disFloHea.heaCoo.vol.heatPort.T;
 bui.disFloHea.heaCoo.vol.ports[1].C_outflow[1:0] = bui.disFloHea.heaCoo.vol.dynBal.ports[1].C_outflow[1:0];
 bui.disFloHea.heaCoo.vol.ports[1].Xi_outflow[1:0] = bui.disFloHea.heaCoo.vol.dynBal.ports[1].Xi_outflow[1:0];
 bui.disFloHea.heaCoo.vol.ports[1].h_outflow = bui.disFloHea.heaCoo.vol.dynBal.ports[1].h_outflow;
 bui.disFloHea.heaCoo.vol.dynBal.ports[1].m_flow - bui.disFloHea.heaCoo.vol.ports[1].m_flow = 0.0;
 bui.disFloHea.heaCoo.vol.dynBal.ports[1].p = bui.disFloHea.heaCoo.vol.ports[1].p;
 bui.disFloHea.heaCoo.vol.ports[2].C_outflow[1:0] = bui.disFloHea.heaCoo.vol.dynBal.ports[2].C_outflow[1:0];
 bui.disFloHea.heaCoo.vol.ports[2].Xi_outflow[1:0] = bui.disFloHea.heaCoo.vol.dynBal.ports[2].Xi_outflow[1:0];
 bui.disFloHea.heaCoo.vol.ports[2].h_outflow = bui.disFloHea.heaCoo.vol.dynBal.ports[2].h_outflow;
 bui.disFloHea.heaCoo.vol.dynBal.ports[2].m_flow - bui.disFloHea.heaCoo.vol.ports[2].m_flow = 0.0;
 bui.disFloHea.heaCoo.vol.dynBal.ports[2].p = bui.disFloHea.heaCoo.vol.ports[2].p;
 bui.disFloHea.heaCoo.vol.U = bui.disFloHea.heaCoo.vol.dynBal.UOut;
 bui.disFloHea.heaCoo.vol.dynBal.mOut = bui.disFloHea.heaCoo.vol.m;
 bui.disFloHea.heaCoo.vol.dynBal.hOut = bui.disFloHea.heaCoo.vol.hOut_internal;
 bui.disFloHea.heaCoo.vol.portT.y = bui.disFloHea.heaCoo.vol.preTem.T;
 bui.disFloHea.heaCoo.vol.heaFloSen.port_b.Q_flow + bui.disFloHea.heaCoo.vol.preTem.port.Q_flow = 0.0;
 bui.disFloHea.heaCoo.vol.heaFloSen.port_b.T = bui.disFloHea.heaCoo.vol.preTem.port.T;
 bui.disFloHea.heaCoo.vol.dynBal.Q_flow = bui.disFloHea.heaCoo.vol.heaFloSen.Q_flow;
 bui.disFloCoo.port_b.C_outflow[1:0] = bui.disFloCoo.heaCoo.port_b.C_outflow[1:0];
 bui.disFloCoo.port_b.Xi_outflow[1:0] = bui.disFloCoo.heaCoo.port_b.Xi_outflow[1:0];
 bui.disFloCoo.port_b.h_outflow = bui.disFloCoo.heaCoo.port_b.h_outflow;
 bui.disFloCoo.heaCoo.port_b.m_flow - bui.disFloCoo.port_b.m_flow = 0.0;
 bui.disFloCoo.heaCoo.port_b.p = bui.disFloCoo.port_b.p;
 bui.disFloCoo.port_a.C_outflow[1:0] = bui.disFloCoo.pipPre.port_a.C_outflow[1:0];
 bui.disFloCoo.port_a.Xi_outflow[1:0] = bui.disFloCoo.pipPre.port_a.Xi_outflow[1:0];
 bui.disFloCoo.port_a.h_outflow = bui.disFloCoo.pipPre.port_a.h_outflow;
 bui.disFloCoo.pipPre.port_a.m_flow - bui.disFloCoo.port_a.m_flow = 0.0;
 bui.disFloCoo.pipPre.port_a.p = bui.disFloCoo.port_a.p;
 bui.disFloCoo.mReqTot_flow = bui.disFloCoo.sumMasFloReq.y;
 bui.disFloCoo.mReq_flow[1] = bui.disFloCoo.sumMasFloReq.u[1];
 bui.disFloCoo.mAct_flow[1].y = bui.disFloCoo.sou_m_flow[1].m_flow_in;
 bui.disFloCoo.ports_a1[1].C_outflow[1:0] = bui.disFloCoo.sin.ports[1].C_outflow[1:0];
 bui.disFloCoo.ports_a1[1].Xi_outflow[1:0] = bui.disFloCoo.sin.ports[1].Xi_outflow[1:0];
 bui.disFloCoo.ports_a1[1].h_outflow = bui.disFloCoo.sin.ports[1].h_outflow;
 - bui.disFloCoo.ports_a1[1].m_flow + bui.disFloCoo.sin.ports[1].m_flow = 0.0;
 bui.disFloCoo.ports_a1[1].p = bui.disFloCoo.sin.ports[1].p;
 bui.disFloCoo.ports_b1[1].C_outflow[1:0] = bui.disFloCoo.sou_m_flow[1].ports[1].C_outflow[1:0];
 bui.disFloCoo.ports_b1[1].Xi_outflow[1:0] = bui.disFloCoo.sou_m_flow[1].ports[1].Xi_outflow[1:0];
 bui.disFloCoo.ports_b1[1].h_outflow = bui.disFloCoo.sou_m_flow[1].ports[1].h_outflow;
 - bui.disFloCoo.ports_b1[1].m_flow + bui.disFloCoo.sou_m_flow[1].ports[1].m_flow = 0.0;
 bui.disFloCoo.ports_b1[1].p = bui.disFloCoo.sou_m_flow[1].ports[1].p;
 bui.disFloCoo.pipPre.port_b.m_flow + bui.disFloCoo.senMasFlo.port_a.m_flow = 0.0;
 bui.disFloCoo.pipPre.port_b.p = bui.disFloCoo.senMasFlo.port_a.p;
 bui.disFloCoo.heaCoo.port_a.m_flow + bui.disFloCoo.senMasFlo.port_b.m_flow = 0.0;
 bui.disFloCoo.heaCoo.port_a.p = bui.disFloCoo.senMasFlo.port_b.p;
 bui.disFloCoo.QActTot_flow = bui.disFloCoo.Q_flowSum.y;
 bui.disFloCoo.Q_flowSum.y = bui.disFloCoo.heaCoo.u;
 bui.disFloCoo.QAct_flow[1].y = bui.disFloCoo.Q_flowSum.u[1];
 bui.disFloCoo.TSupVal.y = bui.disFloCoo.reaRep.u;
 bui.disFloCoo.reaRep.y[1] = bui.disFloCoo.sou_m_flow[1].T_in;
 bui.disFloCoo.dpNetVal.y = bui.disFloCoo.pipPre.dp_in;
 bui.disFloCoo.sou_m_flow[1].m_flow_in = bui.disFloCoo.sou_m_flow[1].m_flow_in_internal;
 bui.disFloCoo.sou_m_flow[1].T_in = bui.disFloCoo.sou_m_flow[1].T_in_internal;
 bui.disFloCoo.pipPre.dp_in = bui.disFloCoo.pipPre.dp_internal;
 bui.disFloCoo.heaCoo.gai.u = bui.disFloCoo.heaCoo.u;
 bui.disFloCoo.heaCoo.Q_flow = bui.disFloCoo.heaCoo.gai.y;
 bui.disFloCoo.heaCoo.gai.y = bui.disFloCoo.heaCoo.preHea.Q_flow;
 bui.disFloCoo.heaCoo.preHea.port.Q_flow + bui.disFloCoo.heaCoo.vol.heatPort.Q_flow = 0.0;
 bui.disFloCoo.heaCoo.preHea.port.T = bui.disFloCoo.heaCoo.vol.heatPort.T;
 bui.disFloCoo.heaCoo.port_b.C_outflow[1:0] = bui.disFloCoo.heaCoo.vol.ports[2].C_outflow[1:0];
 bui.disFloCoo.heaCoo.port_b.Xi_outflow[1:0] = bui.disFloCoo.heaCoo.vol.ports[2].Xi_outflow[1:0];
 bui.disFloCoo.heaCoo.port_b.h_outflow = bui.disFloCoo.heaCoo.vol.ports[2].h_outflow;
 - bui.disFloCoo.heaCoo.port_b.m_flow + bui.disFloCoo.heaCoo.vol.ports[2].m_flow = 0.0;
 bui.disFloCoo.heaCoo.port_b.p = bui.disFloCoo.heaCoo.vol.ports[2].p;
 bui.disFloCoo.heaCoo.port_a.C_outflow[1:0] = bui.disFloCoo.heaCoo.preDro.port_a.C_outflow[1:0];
 bui.disFloCoo.heaCoo.port_a.Xi_outflow[1:0] = bui.disFloCoo.heaCoo.preDro.port_a.Xi_outflow[1:0];
 bui.disFloCoo.heaCoo.port_a.h_outflow = bui.disFloCoo.heaCoo.preDro.port_a.h_outflow;
 - bui.disFloCoo.heaCoo.port_a.m_flow + bui.disFloCoo.heaCoo.preDro.port_a.m_flow = 0.0;
 bui.disFloCoo.heaCoo.port_a.p = bui.disFloCoo.heaCoo.preDro.port_a.p;
 bui.disFloCoo.heaCoo.preDro.port_b.m_flow + bui.disFloCoo.heaCoo.vol.ports[1].m_flow = 0.0;
 bui.disFloCoo.heaCoo.preDro.port_b.p = bui.disFloCoo.heaCoo.vol.ports[1].p;
 bui.disFloCoo.heaCoo.vol.heaFloSen.port_a.Q_flow - bui.disFloCoo.heaCoo.vol.heatPort.Q_flow = 0.0;
 bui.disFloCoo.heaCoo.vol.heaFloSen.port_a.T = bui.disFloCoo.heaCoo.vol.heatPort.T;
 bui.disFloCoo.heaCoo.vol.ports[1].C_outflow[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.ports[1].C_outflow[1:0];
 bui.disFloCoo.heaCoo.vol.ports[1].Xi_outflow[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.ports[1].Xi_outflow[1:0];
 bui.disFloCoo.heaCoo.vol.ports[1].h_outflow = bui.disFloCoo.heaCoo.vol.dynBal.ports[1].h_outflow;
 bui.disFloCoo.heaCoo.vol.dynBal.ports[1].m_flow - bui.disFloCoo.heaCoo.vol.ports[1].m_flow = 0.0;
 bui.disFloCoo.heaCoo.vol.dynBal.ports[1].p = bui.disFloCoo.heaCoo.vol.ports[1].p;
 bui.disFloCoo.heaCoo.vol.ports[2].C_outflow[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.ports[2].C_outflow[1:0];
 bui.disFloCoo.heaCoo.vol.ports[2].Xi_outflow[1:0] = bui.disFloCoo.heaCoo.vol.dynBal.ports[2].Xi_outflow[1:0];
 bui.disFloCoo.heaCoo.vol.ports[2].h_outflow = bui.disFloCoo.heaCoo.vol.dynBal.ports[2].h_outflow;
 bui.disFloCoo.heaCoo.vol.dynBal.ports[2].m_flow - bui.disFloCoo.heaCoo.vol.ports[2].m_flow = 0.0;
 bui.disFloCoo.heaCoo.vol.dynBal.ports[2].p = bui.disFloCoo.heaCoo.vol.ports[2].p;
 bui.disFloCoo.heaCoo.vol.U = bui.disFloCoo.heaCoo.vol.dynBal.UOut;
 bui.disFloCoo.heaCoo.vol.dynBal.mOut = bui.disFloCoo.heaCoo.vol.m;
 bui.disFloCoo.heaCoo.vol.dynBal.hOut = bui.disFloCoo.heaCoo.vol.hOut_internal;
 bui.disFloCoo.heaCoo.vol.portT.y = bui.disFloCoo.heaCoo.vol.preTem.T;
 bui.disFloCoo.heaCoo.vol.heaFloSen.port_b.Q_flow + bui.disFloCoo.heaCoo.vol.preTem.port.Q_flow = 0.0;
 bui.disFloCoo.heaCoo.vol.heaFloSen.port_b.T = bui.disFloCoo.heaCoo.vol.preTem.port.T;
 bui.disFloCoo.heaCoo.vol.dynBal.Q_flow = bui.disFloCoo.heaCoo.vol.heaFloSen.Q_flow;
 bui.terUniCoo.fan.m_flow_in = bui.terUniCoo.gaiFloNom2.y;
 bui.terUniCoo.con.y = bui.terUniCoo.gaiFloNom2.u;
 bui.terUniCoo.gaiFloNom2.u = bui.terUniCoo.gaiMasFlo.u;
 bui.terUniCoo.fan.P = bui.terUniCoo.scaPFan.u;
 bui.terUniCoo.Q_flowCoo.y = bui.terUniCoo.TLoaODE.QAct_flow;
 bui.terUniCoo.TLoaODE.QAct_flow = bui.terUniCoo.gaiHeaFlo1.u;
 bui.terUniCoo.gaiHeaFlo1.u = bui.terUniCoo.scaQActCoo_flow.u;
 bui.terUniCoo.TLoaODE.TAir = bui.terUniCoo.retAir.T_in;
 bui.terUniCoo.gaiMasFlo.y = bui.terUniCoo.scaMasFloReqChiWat.u;
 bui.terUniCoo.TLoaODE.QReq_flow = bui.terUniCoo.gaiHeaFlo.u;
 bui.terUniCoo.gaiHeaFlo.u = bui.terUniCoo.scaQReqCoo_flow.y;
 bui.terUniCoo.TLoaODE.TSet = bui.terUniCoo.TSetCoo;
 bui.terUniCoo.con.u_s = bui.terUniCoo.gaiHeaFlo.y;
 bui.terUniCoo.con.u_m = bui.terUniCoo.gaiHeaFlo1.y;
 bui.terUniCoo.hex.port_b1.m_flow + bui.terUniCoo.scaChiWatFloOut.port_a.m_flow = 0.0;
 bui.terUniCoo.hex.port_b1.p = bui.terUniCoo.scaChiWatFloOut.port_a.p;
 bui.terUniCoo.hex.port_a1.m_flow + bui.terUniCoo.scaChiWatFloInl.port_b.m_flow = 0.0;
 bui.terUniCoo.hex.port_a1.p = bui.terUniCoo.scaChiWatFloInl.port_b.p;
 bui.terUniCoo.fan.port_b.m_flow + bui.terUniCoo.hex.port_a2.m_flow = 0.0;
 bui.terUniCoo.fan.port_b.p = bui.terUniCoo.hex.port_a2.p;
 bui.terUniCoo.hex.port_b2.m_flow + bui.terUniCoo.sinAir.ports[1].m_flow = 0.0;
 bui.terUniCoo.hex.port_b2.p = bui.terUniCoo.sinAir.ports[1].p;
 bui.terUniCoo.fan.port_a.m_flow + bui.terUniCoo.retAir.ports[1].m_flow = 0.0;
 bui.terUniCoo.fan.port_a.p = bui.terUniCoo.retAir.ports[1].p;
 bui.terUniCoo.con.controlError.u1 = bui.terUniCoo.con.uS_revAct.u;
 bui.terUniCoo.con.uS_revAct.u = bui.terUniCoo.con.u_s;
 bui.terUniCoo.con.errI1.u1 = bui.terUniCoo.con.uS_revAct.y;
 bui.terUniCoo.con.uS_revAct.y = bui.terUniCoo.con.uSetWp.u;
 bui.terUniCoo.con.controlError.u2 = bui.terUniCoo.con.uMea_revAct.u;
 bui.terUniCoo.con.uMea_revAct.u = bui.terUniCoo.con.u_m;
 bui.terUniCoo.con.errP.u1 = bui.terUniCoo.con.uSetWp.y;
 bui.terUniCoo.con.errI1.u2 = bui.terUniCoo.con.errP.u2;
 bui.terUniCoo.con.errP.u2 = bui.terUniCoo.con.uMea_revAct.y;
 bui.terUniCoo.con.addPD.u1 = bui.terUniCoo.con.errP.y;
 bui.terUniCoo.con.addPD.y = bui.terUniCoo.con.addPID.u1;
 bui.terUniCoo.con.addPID.y = bui.terUniCoo.con.gainPID.u;
 bui.terUniCoo.con.antWinErr.u1 = bui.terUniCoo.con.gainPID.y;
 bui.terUniCoo.con.gainPID.y = bui.terUniCoo.con.lim.u;
 bui.terUniCoo.con.antWinErr.u2 = bui.terUniCoo.con.lim.y;
 bui.terUniCoo.con.lim.y = bui.terUniCoo.con.y;
 bui.terUniCoo.con.antWinErr.y = bui.terUniCoo.con.antWinGai.u;
 bui.terUniCoo.con.Dzero.y = bui.terUniCoo.con.addPD.u2;
 bui.terUniCoo.con.I.y = bui.terUniCoo.con.addPID.u2;
 bui.terUniCoo.con.I.u = bui.terUniCoo.con.errI2.y;
 bui.terUniCoo.con.errI1.y = bui.terUniCoo.con.errI2.u1;
 bui.terUniCoo.con.antWinGai.y = bui.terUniCoo.con.errI2.u2;
 bui.terUniCoo.con.assMesYMinMax.u = bui.terUniCoo.con.cheYMinMax.y;
 bui.terUniCoo.fan.filter.y = bui.terUniCoo.fan.m_flow_actual;
 bui.terUniCoo.fan.m_flow_actual = bui.terUniCoo.fan.preSou.m_flow_in;
 bui.terUniCoo.fan.inputSwitch.u = bui.terUniCoo.fan.m_flow_in;
 - bui.terUniCoo.fan.heatPort.Q_flow + bui.terUniCoo.fan.vol.heatPort.Q_flow = 0.0;
 bui.terUniCoo.fan.heatPort.T = bui.terUniCoo.fan.vol.heatPort.T;
 bui.terUniCoo.fan.port_b.C_outflow[1:0] = inStreamExpansion(zeros(0), _inStreamEpsilon, bui.terUniCoo.fan.preSou.port_b.m_flow, bui.terUniCoo.fan.preSou.port_b.C_outflow[1:0], false, bui.terUniCoo.fan.senRelPre.port_a.m_flow, bui.terUniCoo.fan.senRelPre.port_a.C_outflow[1:0], false);
 bui.terUniCoo.fan.port_b.Xi_outflow[1:1] = inStreamExpansion(zeros(1), _inStreamEpsilon, bui.terUniCoo.fan.preSou.port_b.m_flow, bui.terUniCoo.fan.preSou.port_b.Xi_outflow[1:1], false, bui.terUniCoo.fan.senRelPre.port_a.m_flow, bui.terUniCoo.fan.senRelPre.port_a.Xi_outflow[1:1], false);
 bui.terUniCoo.fan.port_b.h_outflow = inStreamExpansion(0.0, _inStreamEpsilon, bui.terUniCoo.fan.preSou.port_b.m_flow, bui.terUniCoo.fan.preSou.port_b.h_outflow, false, bui.terUniCoo.fan.senRelPre.port_a.m_flow, bui.terUniCoo.fan.senRelPre.port_a.h_outflow, false);
 - bui.terUniCoo.fan.port_b.m_flow + bui.terUniCoo.fan.preSou.port_b.m_flow + bui.terUniCoo.fan.senRelPre.port_a.m_flow = 0.0;
 bui.terUniCoo.fan.port_b.p = bui.terUniCoo.fan.preSou.port_b.p;
 bui.terUniCoo.fan.preSou.port_b.p = bui.terUniCoo.fan.senRelPre.port_a.p;
 bui.terUniCoo.fan.preSou.port_a.m_flow + bui.terUniCoo.fan.senMasFlo.port_b.m_flow + bui.terUniCoo.fan.senRelPre.port_b.m_flow = 0.0;
 bui.terUniCoo.fan.preSou.port_a.p = bui.terUniCoo.fan.senMasFlo.port_b.p;
 bui.terUniCoo.fan.senMasFlo.port_b.p = bui.terUniCoo.fan.senRelPre.port_b.p;
 bui.terUniCoo.fan.eff.rho = bui.terUniCoo.fan.rho_inlet.y;
 bui.terUniCoo.fan.eff.m_flow = bui.terUniCoo.fan.senMasFlo.m_flow;
 bui.terUniCoo.fan.P = bui.terUniCoo.fan.eff.PEle;
 bui.terUniCoo.fan.filter.u = bui.terUniCoo.fan.inputSwitch.y;
 bui.terUniCoo.fan.eff.dp_in = bui.terUniCoo.fan.senRelPre.p_rel;
 bui.terUniCoo.fan.eff.y_out = bui.terUniCoo.fan.y_actual;
 bui.terUniCoo.fan.port_a.C_outflow[1:0] = bui.terUniCoo.fan.vol.ports[1].C_outflow[1:0];
 bui.terUniCoo.fan.port_a.Xi_outflow[1:1] = bui.terUniCoo.fan.vol.ports[1].Xi_outflow[1:1];
 bui.terUniCoo.fan.port_a.h_outflow = bui.terUniCoo.fan.vol.ports[1].h_outflow;
 - bui.terUniCoo.fan.port_a.m_flow + bui.terUniCoo.fan.vol.ports[1].m_flow = 0.0;
 bui.terUniCoo.fan.port_a.p = bui.terUniCoo.fan.vol.ports[1].p;
 bui.terUniCoo.fan.senMasFlo.port_a.m_flow + bui.terUniCoo.fan.vol.ports[2].m_flow = 0.0;
 bui.terUniCoo.fan.senMasFlo.port_a.p = bui.terUniCoo.fan.vol.ports[2].p;
 bui.terUniCoo.fan.heatPort.Q_flow = 0.0;
 bui.terUniCoo.fan.vol.heaFloSen.port_a.Q_flow - bui.terUniCoo.fan.vol.heatPort.Q_flow = 0.0;
 bui.terUniCoo.fan.vol.heaFloSen.port_a.T = bui.terUniCoo.fan.vol.heatPort.T;
 bui.terUniCoo.fan.vol.ports[1].C_outflow[1:0] = bui.terUniCoo.fan.vol.dynBal.ports[1].C_outflow[1:0];
 bui.terUniCoo.fan.vol.ports[1].Xi_outflow[1:1] = bui.terUniCoo.fan.vol.dynBal.ports[1].Xi_outflow[1:1];
 bui.terUniCoo.fan.vol.ports[1].h_outflow = bui.terUniCoo.fan.vol.dynBal.ports[1].h_outflow;
 bui.terUniCoo.fan.vol.dynBal.ports[1].m_flow - bui.terUniCoo.fan.vol.ports[1].m_flow = 0.0;
 bui.terUniCoo.fan.vol.dynBal.ports[1].p = bui.terUniCoo.fan.vol.ports[1].p;
 bui.terUniCoo.fan.vol.ports[2].C_outflow[1:0] = bui.terUniCoo.fan.vol.dynBal.ports[2].C_outflow[1:0];
 bui.terUniCoo.fan.vol.ports[2].Xi_outflow[1:1] = bui.terUniCoo.fan.vol.dynBal.ports[2].Xi_outflow[1:1];
 bui.terUniCoo.fan.vol.ports[2].h_outflow = bui.terUniCoo.fan.vol.dynBal.ports[2].h_outflow;
 bui.terUniCoo.fan.vol.dynBal.ports[2].m_flow - bui.terUniCoo.fan.vol.ports[2].m_flow = 0.0;
 bui.terUniCoo.fan.vol.dynBal.ports[2].p = bui.terUniCoo.fan.vol.ports[2].p;
 bui.terUniCoo.fan.vol.U = bui.terUniCoo.fan.vol.dynBal.UOut;
 bui.terUniCoo.fan.vol.dynBal.mXiOut[1] = bui.terUniCoo.fan.vol.mXi[1];
 bui.terUniCoo.fan.vol.dynBal.mOut = bui.terUniCoo.fan.vol.m;
 bui.terUniCoo.fan.vol.dynBal.hOut = bui.terUniCoo.fan.vol.hOut_internal;
 bui.terUniCoo.fan.vol.XiOut_internal[1] = bui.terUniCoo.fan.vol.dynBal.XiOut[1];
 bui.terUniCoo.fan.vol.portT.y = bui.terUniCoo.fan.vol.preTem.T;
 bui.terUniCoo.fan.vol.heaFloSen.port_b.Q_flow + bui.terUniCoo.fan.vol.preTem.port.Q_flow = 0.0;
 bui.terUniCoo.fan.vol.heaFloSen.port_b.T = bui.terUniCoo.fan.vol.preTem.port.T;
 bui.terUniCoo.fan.vol.dynBal.Q_flow = bui.terUniCoo.fan.vol.heaFloSen.Q_flow;
 bui.terUniCoo.fan.preSou.m_flow_in = bui.terUniCoo.fan.preSou.m_flow_internal;
 bui.terUniCoo.fan.eff.dp_in = bui.terUniCoo.fan.eff.dp_internal;
 bui.terUniCoo.hex.port_a1.C_outflow[1:0] = bui.terUniCoo.hex.bal1.port_a.C_outflow[1:0];
 bui.terUniCoo.hex.port_a1.Xi_outflow[1:0] = bui.terUniCoo.hex.bal1.port_a.Xi_outflow[1:0];
 bui.terUniCoo.hex.port_a1.h_outflow = bui.terUniCoo.hex.bal1.port_a.h_outflow;
 bui.terUniCoo.hex.bal1.port_a.m_flow - bui.terUniCoo.hex.port_a1.m_flow = 0.0;
 bui.terUniCoo.hex.bal1.port_a.p = bui.terUniCoo.hex.port_a1.p;
 bui.terUniCoo.hex.port_b1.C_outflow[1:0] = bui.terUniCoo.hex.bal1.port_b.C_outflow[1:0];
 bui.terUniCoo.hex.port_b1.Xi_outflow[1:0] = bui.terUniCoo.hex.bal1.port_b.Xi_outflow[1:0];
 bui.terUniCoo.hex.port_b1.h_outflow = bui.terUniCoo.hex.bal1.port_b.h_outflow;
 bui.terUniCoo.hex.bal1.port_b.m_flow - bui.terUniCoo.hex.port_b1.m_flow = 0.0;
 bui.terUniCoo.hex.bal1.port_b.p = bui.terUniCoo.hex.port_b1.p;
 bui.terUniCoo.hex.port_a2.C_outflow[1:0] = bui.terUniCoo.hex.bal2.port_a.C_outflow[1:0];
 bui.terUniCoo.hex.port_a2.Xi_outflow[1:1] = bui.terUniCoo.hex.bal2.port_a.Xi_outflow[1:1];
 bui.terUniCoo.hex.port_a2.h_outflow = bui.terUniCoo.hex.bal2.port_a.h_outflow;
 bui.terUniCoo.hex.bal2.port_a.m_flow - bui.terUniCoo.hex.port_a2.m_flow = 0.0;
 bui.terUniCoo.hex.bal2.port_a.p = bui.terUniCoo.hex.port_a2.p;
 bui.terUniCoo.hex.port_b2.C_outflow[1:0] = bui.terUniCoo.hex.bal2.port_b.C_outflow[1:0];
 bui.terUniCoo.hex.port_b2.Xi_outflow[1:1] = bui.terUniCoo.hex.bal2.port_b.Xi_outflow[1:1];
 bui.terUniCoo.hex.port_b2.h_outflow = bui.terUniCoo.hex.bal2.port_b.h_outflow;
 bui.terUniCoo.hex.bal2.port_b.m_flow - bui.terUniCoo.hex.port_b2.m_flow = 0.0;
 bui.terUniCoo.hex.bal2.port_b.p = bui.terUniCoo.hex.port_b2.p;
 bui.terUniCoo.hex.bal1.hOut = bui.terUniCoo.hex.bal1.vol.hOut;
 bui.terUniCoo.hex.bal1.port_a.C_outflow[1:0] = bui.terUniCoo.hex.bal1.preDro.port_a.C_outflow[1:0];
 bui.terUniCoo.hex.bal1.port_a.Xi_outflow[1:0] = bui.terUniCoo.hex.bal1.preDro.port_a.Xi_outflow[1:0];
 bui.terUniCoo.hex.bal1.port_a.h_outflow = bui.terUniCoo.hex.bal1.preDro.port_a.h_outflow;
 - bui.terUniCoo.hex.bal1.port_a.m_flow + bui.terUniCoo.hex.bal1.preDro.port_a.m_flow = 0.0;
 bui.terUniCoo.hex.bal1.port_a.p = bui.terUniCoo.hex.bal1.preDro.port_a.p;
 bui.terUniCoo.hex.bal1.preDro.port_b.m_flow + bui.terUniCoo.hex.bal1.vol.port_a.m_flow = 0.0;
 bui.terUniCoo.hex.bal1.preDro.port_b.p = bui.terUniCoo.hex.bal1.vol.port_a.p;
 bui.terUniCoo.hex.bal1.port_b.C_outflow[1:0] = bui.terUniCoo.hex.bal1.vol.port_b.C_outflow[1:0];
 bui.terUniCoo.hex.bal1.port_b.Xi_outflow[1:0] = bui.terUniCoo.hex.bal1.vol.port_b.Xi_outflow[1:0];
 bui.terUniCoo.hex.bal1.port_b.h_outflow = bui.terUniCoo.hex.bal1.vol.port_b.h_outflow;
 - bui.terUniCoo.hex.bal1.port_b.m_flow + bui.terUniCoo.hex.bal1.vol.port_b.m_flow = 0.0;
 bui.terUniCoo.hex.bal1.port_b.p = bui.terUniCoo.hex.bal1.vol.port_b.p;
 bui.terUniCoo.hex.bal1.heaInp.y = bui.terUniCoo.hex.bal1.vol.Q_flow;
 bui.terUniCoo.hex.bal2.hOut = bui.terUniCoo.hex.bal2.vol.hOut;
 bui.terUniCoo.hex.bal2.XiOut[1] = bui.terUniCoo.hex.bal2.vol.XiOut[1];
 bui.terUniCoo.hex.bal2.port_a.C_outflow[1:0] = bui.terUniCoo.hex.bal2.preDro.port_a.C_outflow[1:0];
 bui.terUniCoo.hex.bal2.port_a.Xi_outflow[1:1] = bui.terUniCoo.hex.bal2.preDro.port_a.Xi_outflow[1:1];
 bui.terUniCoo.hex.bal2.port_a.h_outflow = bui.terUniCoo.hex.bal2.preDro.port_a.h_outflow;
 - bui.terUniCoo.hex.bal2.port_a.m_flow + bui.terUniCoo.hex.bal2.preDro.port_a.m_flow = 0.0;
 bui.terUniCoo.hex.bal2.port_a.p = bui.terUniCoo.hex.bal2.preDro.port_a.p;
 bui.terUniCoo.hex.bal2.preDro.port_b.m_flow + bui.terUniCoo.hex.bal2.vol.port_a.m_flow = 0.0;
 bui.terUniCoo.hex.bal2.preDro.port_b.p = bui.terUniCoo.hex.bal2.vol.port_a.p;
 bui.terUniCoo.hex.bal2.port_b.C_outflow[1:0] = bui.terUniCoo.hex.bal2.vol.port_b.C_outflow[1:0];
 bui.terUniCoo.hex.bal2.port_b.Xi_outflow[1:1] = bui.terUniCoo.hex.bal2.vol.port_b.Xi_outflow[1:1];
 bui.terUniCoo.hex.bal2.port_b.h_outflow = bui.terUniCoo.hex.bal2.vol.port_b.h_outflow;
 - bui.terUniCoo.hex.bal2.port_b.m_flow + bui.terUniCoo.hex.bal2.vol.port_b.m_flow = 0.0;
 bui.terUniCoo.hex.bal2.port_b.p = bui.terUniCoo.hex.bal2.vol.port_b.p;
 bui.terUniCoo.hex.bal2.heaInp.y = bui.terUniCoo.hex.bal2.vol.Q_flow;
 bui.terUniCoo.retAir.T_in = bui.terUniCoo.retAir.T_in_internal;
 bui.terUniCoo.QReqCoo_flow = bui.terUniCoo.scaQReqCoo_flow.u;
 bui.terUniCoo.QActCoo_flow = bui.terUniCoo.scaQActCoo_flow.y;
 bui.terUniCoo.PFan = bui.terUniCoo.scaPFan.y;
 bui.terUniCoo.mReqChiWat_flow = bui.terUniCoo.scaMasFloReqChiWat.y;
 bui.terUniCoo.port_aChiWat.C_outflow[1:0] = bui.terUniCoo.scaChiWatFloInl.port_a.C_outflow[1:0];
 bui.terUniCoo.port_aChiWat.Xi_outflow[1:0] = bui.terUniCoo.scaChiWatFloInl.port_a.Xi_outflow[1:0];
 bui.terUniCoo.port_aChiWat.h_outflow = bui.terUniCoo.scaChiWatFloInl.port_a.h_outflow;
 - bui.terUniCoo.port_aChiWat.m_flow + bui.terUniCoo.scaChiWatFloInl.port_a.m_flow = 0.0;
 bui.terUniCoo.port_aChiWat.p = bui.terUniCoo.scaChiWatFloInl.port_a.p;
 bui.terUniCoo.port_bChiWat.C_outflow[1:0] = bui.terUniCoo.scaChiWatFloOut.port_b.C_outflow[1:0];
 bui.terUniCoo.port_bChiWat.Xi_outflow[1:0] = bui.terUniCoo.scaChiWatFloOut.port_b.Xi_outflow[1:0];
 bui.terUniCoo.port_bChiWat.h_outflow = bui.terUniCoo.scaChiWatFloOut.port_b.h_outflow;
 - bui.terUniCoo.port_bChiWat.m_flow + bui.terUniCoo.scaChiWatFloOut.port_b.m_flow = 0.0;
 bui.terUniCoo.port_bChiWat.p = bui.terUniCoo.scaChiWatFloOut.port_b.p;
 supChiWat.m_flow_in = supChiWat.m_flow_in_internal;
 supHeaWat.T_in = supHeaWat.T_in_internal;
 pumBui.inputSwitch.y = pumBui.m_flow_actual;
 pumBui.m_flow_actual = pumBui.preSou.m_flow_in;
 pumBui.inputSwitch.u = pumBui.m_flow_in;
 - pumBui.heatPort.Q_flow + pumBui.prePow.port.Q_flow + pumBui.vol.heatPort.Q_flow = 0.0;
 pumBui.heatPort.T = pumBui.prePow.port.T;
 pumBui.prePow.port.T = pumBui.vol.heatPort.T;
 pumBui.port_b.C_outflow[1:0] = inStreamExpansion(zeros(0), _inStreamEpsilon, pumBui.preSou.port_b.m_flow, pumBui.preSou.port_b.C_outflow[1:0], false, pumBui.senRelPre.port_a.m_flow, pumBui.senRelPre.port_a.C_outflow[1:0], false);
 pumBui.port_b.Xi_outflow[1:0] = inStreamExpansion(zeros(0), _inStreamEpsilon, pumBui.preSou.port_b.m_flow, pumBui.preSou.port_b.Xi_outflow[1:0], false, pumBui.senRelPre.port_a.m_flow, pumBui.senRelPre.port_a.Xi_outflow[1:0], false);
 pumBui.port_b.h_outflow = inStreamExpansion(0.0, _inStreamEpsilon, pumBui.preSou.port_b.m_flow, pumBui.preSou.port_b.h_outflow, false, pumBui.senRelPre.port_a.m_flow, pumBui.senRelPre.port_a.h_outflow, false);
 - pumBui.port_b.m_flow + pumBui.preSou.port_b.m_flow + pumBui.senRelPre.port_a.m_flow = 0.0;
 pumBui.port_b.p = pumBui.preSou.port_b.p;
 pumBui.preSou.port_b.p = pumBui.senRelPre.port_a.p;
 pumBui.PToMed.y = pumBui.prePow.Q_flow;
 pumBui.PToMed.u1 = pumBui.heaDis.Q_flow;
 pumBui.preSou.port_a.m_flow + pumBui.senMasFlo.port_b.m_flow + pumBui.senRelPre.port_b.m_flow = 0.0;
 pumBui.preSou.port_a.p = pumBui.senMasFlo.port_b.p;
 pumBui.senMasFlo.port_b.p = pumBui.senRelPre.port_b.p;
 pumBui.eff.etaHyd = pumBui.heaDis.etaHyd;
 pumBui.eff.V_flow = pumBui.heaDis.V_flow;
 pumBui.P = pumBui.eff.PEle;
 pumBui.eff.PEle = pumBui.heaDis.PEle;
 pumBui.PToMed.u2 = pumBui.eff.WFlo;
 pumBui.eff.WFlo = pumBui.heaDis.WFlo;
 pumBui.eff.rho = pumBui.rho_inlet.y;
 pumBui.eff.m_flow = pumBui.senMasFlo.m_flow;
 pumBui.eff.dp_in = pumBui.senRelPre.p_rel;
 pumBui.eff.y_out = pumBui.y_actual;
 pumBui.port_a.C_outflow[1:0] = pumBui.vol.ports[1].C_outflow[1:0];
 pumBui.port_a.Xi_outflow[1:0] = pumBui.vol.ports[1].Xi_outflow[1:0];
 pumBui.port_a.h_outflow = pumBui.vol.ports[1].h_outflow;
 - pumBui.port_a.m_flow + pumBui.vol.ports[1].m_flow = 0.0;
 pumBui.port_a.p = pumBui.vol.ports[1].p;
 pumBui.senMasFlo.port_a.m_flow + pumBui.vol.ports[2].m_flow = 0.0;
 pumBui.senMasFlo.port_a.p = pumBui.vol.ports[2].p;
 pumBui.heatPort.Q_flow = 0.0;
 pumBui.vol.heaFloSen.port_a.Q_flow - pumBui.vol.heatPort.Q_flow = 0.0;
 pumBui.vol.heaFloSen.port_a.T = pumBui.vol.heatPort.T;
 pumBui.vol.ports[1].C_outflow[1:0] = pumBui.vol.dynBal.ports[1].C_outflow[1:0];
 pumBui.vol.ports[1].Xi_outflow[1:0] = pumBui.vol.dynBal.ports[1].Xi_outflow[1:0];
 pumBui.vol.ports[1].h_outflow = pumBui.vol.dynBal.ports[1].h_outflow;
 pumBui.vol.dynBal.ports[1].m_flow - pumBui.vol.ports[1].m_flow = 0.0;
 pumBui.vol.dynBal.ports[1].p = pumBui.vol.ports[1].p;
 pumBui.vol.ports[2].C_outflow[1:0] = pumBui.vol.dynBal.ports[2].C_outflow[1:0];
 pumBui.vol.ports[2].Xi_outflow[1:0] = pumBui.vol.dynBal.ports[2].Xi_outflow[1:0];
 pumBui.vol.ports[2].h_outflow = pumBui.vol.dynBal.ports[2].h_outflow;
 pumBui.vol.dynBal.ports[2].m_flow - pumBui.vol.ports[2].m_flow = 0.0;
 pumBui.vol.dynBal.ports[2].p = pumBui.vol.ports[2].p;
 pumBui.vol.U = pumBui.vol.dynBal.UOut;
 pumBui.vol.dynBal.mOut = pumBui.vol.m;
 pumBui.vol.dynBal.hOut = pumBui.vol.hOut_internal;
 pumBui.vol.portT.y = pumBui.vol.preTem.T;
 pumBui.vol.heaFloSen.port_b.Q_flow + pumBui.vol.preTem.port.Q_flow = 0.0;
 pumBui.vol.heaFloSen.port_b.T = pumBui.vol.preTem.port.T;
 pumBui.vol.dynBal.Q_flow = pumBui.vol.heaFloSen.Q_flow;
 pumBui.preSou.m_flow_in = pumBui.preSou.m_flow_internal;
 pumBui.eff.dp_in = pumBui.eff.dp_internal;

public
 function Buildings.Media.Water.temperature
  input Buildings.Media.Water.ThermodynamicState state;
  output Real T;
 algorithm
  T := state.T;
  return;
 end Buildings.Media.Water.temperature;

 function Buildings.Media.Water.specificHeatCapacityCp
  input Buildings.Media.Water.ThermodynamicState state;
  output Real cp;
 algorithm
  cp := 4184.0;
  return;
 end Buildings.Media.Water.specificHeatCapacityCp;

 function Modelica.Fluid.Utilities.regStep
  input Real x;
  input Real y1;
  input Real y2;
  input Real x_small;
  output Real y;
 algorithm
  y := smooth(1, if x > x_small then y1 elseif x < - x_small then y2 elseif x_small > 0 then x / x_small * ((x / x_small) ^ 2 - 3) * (y2 - y1) / 4 + (y1 + y2) / 2 else (y1 + y2) / 2);
  return;
 end Modelica.Fluid.Utilities.regStep;

 function Buildings.Media.Water.specificEnthalpy_pTX
  input Real p;
  input Real T;
  input Real[:] X;
  output Real h;
 algorithm
  assert(1 == size(X, 1), "Mismatching sizes in function 'Buildings.Media.Water.specificEnthalpy_pTX', component 'X', dimension '1'");
  h := 4184.0 * (T - 273.15);
  return;
 end Buildings.Media.Water.specificEnthalpy_pTX;

 function Modelica.Utilities.Strings.isEqual
  input String string1;
  input String string2;
  input Boolean caseSensitive;
  output Boolean identical;
 algorithm
  identical := Modelica.Utilities.Strings.compare(string1, string2, caseSensitive) == Modelica.Utilities.Types.Compare.Equal;
  return;
 end Modelica.Utilities.Strings.isEqual;

 function Modelica.Utilities.Strings.compare
  input String string1;
  input String string2;
  input Boolean caseSensitive;
  output Modelica.Utilities.Types.Compare result;
 algorithm
  external "C" result = ModelicaStrings_compare(string1, string2, caseSensitive);
  return;
 end Modelica.Utilities.Strings.compare;

 function Buildings.Media.Water.dynamicViscosity
  input Buildings.Media.Water.ThermodynamicState state;
  output Real eta;
 algorithm
  eta := 0.001;
  return;
 end Buildings.Media.Water.dynamicViscosity;

 function Modelica.Fluid.Utilities.regPow
  input Real x;
  input Real a;
  input Real delta;
  output Real y;
 algorithm
  y := x * (x * x + delta * delta) ^ ((a - 1) / 2);
  return;
 end Modelica.Fluid.Utilities.regPow;

 function Buildings.Media.Water.density_pTX
  input Real p;
  input Real T;
  input Real[:] X;
  output Real d;
 algorithm
  d := Buildings.Media.Water.density(Buildings.Media.Water.setState_pTX(p, T, X));
  return;
 end Buildings.Media.Water.density_pTX;

 function Buildings.Media.Water.density
  input Buildings.Media.Water.ThermodynamicState state;
  output Real d;
 algorithm
  d := 995.586;
  return;
 end Buildings.Media.Water.density;

 function Buildings.Media.Water.setState_pTX
  input Real p;
  input Real T;
  input Real[:] X;
  output Buildings.Media.Water.ThermodynamicState state;
 algorithm
  state := Buildings.Media.Water.ThermodynamicState(p, T);
  return;
 end Buildings.Media.Water.setState_pTX;

 function Buildings.Experimental.DistrictHeatingCooling.SubStations.VaporCompression.BaseClasses.getPeakLoad
  input String string;
  input String filNam;
  output Real number;
  String lin;
  Integer iLin;
  Integer index;
  Integer staInd;
  Integer nexInd;
  Boolean found;
  Boolean EOF;
  String del;
 algorithm
  index := 0;
  iLin := 0;
  EOF := false;
  while not EOF and index == 0 loop
   iLin := iLin + 1;
   (lin, EOF) := Modelica.Utilities.Streams.readLine(filNam, iLin);
   index := Modelica.Utilities.Strings.find(lin, string, 1, true);
  end while;
  assert(not EOF, "Error: Did not find '" + string + "' when scanning '" + filNam + "'." + "\n   Check for correct file syntax.");
  (del, nexInd) := Modelica.Utilities.Strings.scanDelimiter(lin, Modelica.Utilities.Strings.length(string) + 1, {"="}, "Failed to find '=' when reading peak load in '" + filNam + "'.");
  number := Modelica.Utilities.Strings.scanReal(lin, nexInd, false, "Failed to read double value when reading peak load in '" + filNam + "'.");
  return;
 end Buildings.Experimental.DistrictHeatingCooling.SubStations.VaporCompression.BaseClasses.getPeakLoad;

 function Modelica.Utilities.Streams.readLine
  input String fileName;
  input Integer lineNumber;
  output String string;
  output Boolean endOfFile;
 algorithm
  external "C" string = ModelicaInternal_readLine(fileName, lineNumber, endOfFile);
  return;
 end Modelica.Utilities.Streams.readLine;

 function Modelica.Utilities.Strings.find
  input String string;
  input String searchString;
  input Integer startIndex;
  input Boolean caseSensitive;
  output Integer index;
  Integer lengthSearchString;
  Integer len;
  Integer i;
  Integer i_max;
 algorithm
  lengthSearchString := Modelica.Utilities.Strings.length(searchString);
  len := lengthSearchString - 1;
  i := startIndex;
  i_max := Modelica.Utilities.Strings.length(string) - lengthSearchString + 1;
  index := 0;
  while i <= i_max loop
   if Modelica.Utilities.Strings.isEqual(Modelica.Utilities.Strings.substring(string, i, i + len), searchString, caseSensitive) then
    index := i;
    i := i_max + 1;
   else
    i := i + 1;
   end if;
  end while;
  return;
 end Modelica.Utilities.Strings.find;

 function Modelica.Utilities.Strings.length
  input String string;
  output Integer result;
 algorithm
  external "C" result = ModelicaStrings_length(string);
  return;
 end Modelica.Utilities.Strings.length;

 function Modelica.Utilities.Strings.substring
  input String string;
  input Integer startIndex;
  input Integer endIndex;
  output String result;
 algorithm
  external "C" result = ModelicaStrings_substring(string, startIndex, endIndex);
  return;
 end Modelica.Utilities.Strings.substring;

 function Modelica.Utilities.Strings.scanDelimiter
  input String string;
  input Integer startIndex;
  input String[:] requiredDelimiters;
  input String message;
  output String delimiter;
  output Integer nextIndex;
  Integer lenString;
  Integer lenDelimiter;
  Integer nDelimiters;
  Integer endIndex;
  Boolean found;
  Integer i;
 algorithm
  lenString := Modelica.Utilities.Strings.length(string);
  nDelimiters := size(requiredDelimiters, 1);
  nextIndex := Modelica.Utilities.Strings.Advanced.skipLineComments(string, startIndex);
  found := false;
  i := 1;
  while not found and i <= nDelimiters loop
   lenDelimiter := Modelica.Utilities.Strings.length(requiredDelimiters[i]);
   if lenDelimiter == 0 then
    found := true;
    delimiter := "";
   else
    endIndex := nextIndex + lenDelimiter - 1;
    if endIndex <= lenString then
     if Modelica.Utilities.Strings.substring(string, nextIndex, endIndex) == requiredDelimiters[i] then
      found := true;
      delimiter := requiredDelimiters[i];
     end if;
    end if;
    i := i + 1;
   end if;
  end while;
  if found then
   nextIndex := nextIndex + lenDelimiter;
  else
   if size(requiredDelimiters, 1) == 1 then
    Modelica.Utilities.Strings.syntaxError(string, nextIndex, "Expected delimiter \"" + requiredDelimiters[1] + "\"\n" + message);
   else
    Modelica.Utilities.Strings.syntaxError(string, nextIndex, "Expected a delimiter out of " + Modelica.Utilities.Strings.scanDelimiter.concatenate(requiredDelimiters) + "\n" + message);
   end if;
  end if;
  return;
 end Modelica.Utilities.Strings.scanDelimiter;

 function Modelica.Utilities.Strings.Advanced.skipLineComments
  input String string;
  input Integer startIndex;
  output Integer nextIndex;
  Integer lenString;
  Boolean scanning;
  Boolean lineComment;
 algorithm
  lenString := Modelica.Utilities.Strings.length(string);
  nextIndex := startIndex;
  scanning := true;
  while scanning loop
   nextIndex := Modelica.Utilities.Strings.Advanced.skipWhiteSpace(string, nextIndex);
   if nextIndex + 1 <= lenString then
    if Modelica.Utilities.Strings.substring(string, nextIndex, nextIndex + 1) == "//" then
     nextIndex := nextIndex + 2;
     if nextIndex <= lenString then
      lineComment := true;
      while lineComment loop
       if Modelica.Utilities.Strings.substring(string, nextIndex, nextIndex) == "\n" then
        lineComment := false;
       end if;
       nextIndex := nextIndex + 1;
       if nextIndex > lenString then
        lineComment := false;
        scanning := false;
       end if;
      end while;
     else
      scanning := false;
     end if;
    else
     scanning := false;
    end if;
   else
    scanning := false;
   end if;
  end while;
  return;
 end Modelica.Utilities.Strings.Advanced.skipLineComments;

 function Modelica.Utilities.Strings.Advanced.skipWhiteSpace
  input String string;
  input Integer startIndex;
  output Integer nextIndex;
 algorithm
  external "C" nextIndex = ModelicaStrings_skipWhiteSpace(string, startIndex);
  return;
 end Modelica.Utilities.Strings.Advanced.skipWhiteSpace;

 function Modelica.Utilities.Strings.syntaxError
  input String string;
  input Integer index;
  input String message;
  Integer maxIndex;
  Integer maxLenString;
  Integer lenString;
  String errString;
  Integer index2;
 algorithm
  maxIndex := 40;
  maxLenString := 60;
  lenString := Modelica.Utilities.Strings.length(string);
  index2 := if index < 1 then 1 elseif index > lenString then lenString else index;
  if index2 <= maxIndex then
   errString := string;
  else
   errString := "... " + Modelica.Utilities.Strings.substring(string, index2 - maxIndex, lenString);
   index2 := maxIndex + 5;
  end if;
  if Modelica.Utilities.Strings.length(errString) > maxLenString then
   errString := Modelica.Utilities.Strings.substring(errString, 1, maxLenString) + " ...";
  end if;
  Modelica.Utilities.Streams.error("Syntax error at character " + String(index) + " of\n" + errString + "\n" + Modelica.Utilities.Strings.repeat(index2 - 1, " ") + "*" + "\n" + message);
  return;
 end Modelica.Utilities.Strings.syntaxError;

 function Modelica.Utilities.Streams.error
  input String string;
 algorithm
  external "C" ModelicaError(string);
  return;
 end Modelica.Utilities.Streams.error;

 function Modelica.Utilities.Strings.repeat
  input Integer n;
  input String string;
  output String repeatedString;
 algorithm
  repeatedString := "";
  for i in 1:n loop
   repeatedString := repeatedString + string;
  end for;
  return;
 end Modelica.Utilities.Strings.repeat;

 function Modelica.Utilities.Strings.scanDelimiter.concatenate
  input String[:] strings;
  output String string;
 algorithm
  string := "{\"";
  for i in 1:size(strings, 1) loop
   if i == 1 then
    string := "{\"" + strings[1] + "\"";
   else
    string := string + ", \"" + strings[i] + "\"";
   end if;
  end for;
  string := string + "}";
  return;
 end Modelica.Utilities.Strings.scanDelimiter.concatenate;

 function Modelica.Utilities.Strings.scanReal
  input String string;
  input Integer startIndex;
  input Boolean unsigned;
  input String message;
  output Real number;
  output Integer nextIndex;
 algorithm
  (nextIndex, number) := Modelica.Utilities.Strings.Advanced.scanReal(string, startIndex, unsigned);
  if nextIndex == startIndex then
   nextIndex := Modelica.Utilities.Strings.Advanced.skipWhiteSpace(string, startIndex);
   if unsigned then
    Modelica.Utilities.Strings.syntaxError(string, nextIndex, "Expected a Real number without a sign " + message);
   else
    Modelica.Utilities.Strings.syntaxError(string, nextIndex, "Expected a Real number " + message);
   end if;
  end if;
  return;
 end Modelica.Utilities.Strings.scanReal;

 function Modelica.Utilities.Strings.Advanced.scanReal
  input String string;
  input Integer startIndex;
  input Boolean unsigned;
  output Integer nextIndex;
  output Real number;
 algorithm
  external "C" ModelicaStrings_scanReal(string, startIndex, unsigned, nextIndex, number);
  return;
 end Modelica.Utilities.Strings.Advanced.scanReal;

 function Buildings.Media.Air.specificHeatCapacityCp
  input Buildings.Media.Air.ThermodynamicState state;
  output Real cp;
 algorithm
  assert(2 == size(state.X, 1), "Mismatching sizes in function 'Buildings.Media.Air.specificHeatCapacityCp', component 'state.X', dimension '1'");
  cp := 1006.0 * (1 - state.X[1]) + 1860.0 * state.X[1];
  return;
 annotation(derivative = Buildings.Media.Air.der_specificHeatCapacityCp,Inline = true,smoothOrder = 99);
 end Buildings.Media.Air.specificHeatCapacityCp;

 function Buildings.Media.Air.der_specificHeatCapacityCp
  input Buildings.Media.Air.ThermodynamicState state;
  input Buildings.Media.Air.ThermodynamicState der_state;
  output Real der_cp;
 algorithm
  assert(2 == size(state.X, 1), "Mismatching sizes in function 'Buildings.Media.Air.der_specificHeatCapacityCp', component 'state.X', dimension '1'");
  assert(2 == size(der_state.X, 1), "Mismatching sizes in function 'Buildings.Media.Air.der_specificHeatCapacityCp', component 'der_state.X', dimension '1'");
  der_cp := (1860.0 - 1006.0) * der_state.X[1];
  return;
 annotation(Inline = true);
 end Buildings.Media.Air.der_specificHeatCapacityCp;

 function Buildings.Media.Air.setState_pTX
  input Real p;
  input Real T;
  input Real[:] X;
  output Buildings.Media.Air.ThermodynamicState state;
 algorithm
  state := if size(X, 1) == 2 then Buildings.Media.Air.ThermodynamicState(p, T, X) else Buildings.Media.Air.ThermodynamicState(p, T, cat(1, X[:], {1 - sum(X[:])}));
  return;
 annotation(Inline = true,smoothOrder = 2);
 end Buildings.Media.Air.setState_pTX;

 function Modelica.Blocks.Types.ExternalCombiTimeTable.destructor
  input Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;
 algorithm
  external "C" ModelicaStandardTables_CombiTimeTable_close(externalCombiTimeTable);
  return;
 end Modelica.Blocks.Types.ExternalCombiTimeTable.destructor;

 function Modelica.Blocks.Types.ExternalCombiTimeTable.constructor
  input String tableName;
  input String fileName;
  input Real[:,:] table;
  input Real startTime;
  input Integer[:] columns;
  input Modelica.Blocks.Types.Smoothness smoothness;
  input Modelica.Blocks.Types.Extrapolation extrapolation;
  output Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;
 algorithm
  external "C" externalCombiTimeTable = ModelicaStandardTables_CombiTimeTable_init(tableName, fileName, table, size(table, 1), size(table, 2), startTime, columns, size(columns, 1), smoothness, extrapolation);
  return;
 end Modelica.Blocks.Types.ExternalCombiTimeTable.constructor;

 function Modelica.Utilities.Strings.isEmpty
  input String string;
  output Boolean result;
  Integer nextIndex;
  Integer len;
 algorithm
  nextIndex := Modelica.Utilities.Strings.Advanced.skipWhiteSpace(string, 1);
  len := Modelica.Utilities.Strings.length(string);
  if len < 1 or nextIndex > len then
   result := true;
  else
   result := false;
  end if;
  return;
 end Modelica.Utilities.Strings.isEmpty;

 function Buildings.Media.Air.density_pTX
  input Real p;
  input Real T;
  input Real[:] X;
  output Real d;
 algorithm
  d := Buildings.Media.Air.density(Buildings.Media.Air.setState_pTX(p, T, X));
  return;
 end Buildings.Media.Air.density_pTX;

 function Buildings.Media.Air.density
  input Buildings.Media.Air.ThermodynamicState state;
  output Real d;
 algorithm
  assert(2 == size(state.X, 1), "Mismatching sizes in function 'Buildings.Media.Air.density', component 'state.X', dimension '1'");
  d := state.p * 1.2 / 101325.0;
  return;
 annotation(Inline = true,smoothOrder = 5);
 end Buildings.Media.Air.density;

 function Buildings.Media.Air.specificEnthalpy
  input Buildings.Media.Air.ThermodynamicState state;
  output Real h;
 algorithm
  assert(2 == size(state.X, 1), "Mismatching sizes in function 'Buildings.Media.Air.specificEnthalpy', component 'state.X', dimension '1'");
  h := (state.T - 273.15) * 1006.0 * (1 - state.X[1]) + ((state.T - 273.15) * 1860.0 + 2501014.5) * state.X[1];
  return;
 annotation(Inline = true,smoothOrder = 5);
 end Buildings.Media.Air.specificEnthalpy;

 function Buildings.Media.Air.temperature_phX
  input Real p;
  input Real h;
  input Real[:] X;
  output Real T;
 algorithm
  T := 273.15 + (h - 2501014.5 * X[1]) / ((1 - X[1]) * 1006.0 + X[1] * 1860.0);
  return;
 annotation(Inline = true,smoothOrder = 5);
 end Buildings.Media.Air.temperature_phX;

 function Modelica.SIunits.Conversions.to_degC
  input Real Kelvin;
  output Real Celsius;
 algorithm
  Celsius := Kelvin + -273.15;
  return;
 annotation(Inline = true);
 end Modelica.SIunits.Conversions.to_degC;

 function Modelica.SIunits.Conversions.to_bar
  input Real Pa;
  output Real bar;
 algorithm
  bar := Pa / 100000.0;
  return;
 annotation(Inline = true);
 end Modelica.SIunits.Conversions.to_bar;

 function Buildings.Media.Air.specificInternalEnergy
  input Buildings.Media.Air.ThermodynamicState state;
  output Real u;
 algorithm
  assert(2 == size(state.X, 1), "Mismatching sizes in function 'Buildings.Media.Air.specificInternalEnergy', component 'state.X', dimension '1'");
  u := Buildings.Media.Air.specificEnthalpy(state) - 101325.0 / 1.2;
  return;
 annotation(Inline = true);
 end Buildings.Media.Air.specificInternalEnergy;

 function Buildings.Media.Air.specificEnthalpy_pTX
  input Real p;
  input Real T;
  input Real[:] X;
  output Real h;
 algorithm
  h := Buildings.Media.Air.specificEnthalpy(Buildings.Media.Air.setState_pTX(p, T, X));
  return;
 annotation(Inline = true,smoothOrder = 5);
 end Buildings.Media.Air.specificEnthalpy_pTX;

 function Buildings.Media.Air.setState_phX
  input Real p;
  input Real h;
  input Real[:] X;
  output Buildings.Media.Air.ThermodynamicState state;
 algorithm
  state := if size(X, 1) == 2 then Buildings.Media.Air.ThermodynamicState(p, Buildings.Media.Air.temperature_phX(p, h, X), X) else Buildings.Media.Air.ThermodynamicState(p, Buildings.Media.Air.temperature_phX(p, h, X), cat(1, X[:], {1 - sum(X[:])}));
  return;
 annotation(Inline = true,smoothOrder = 2);
 end Buildings.Media.Air.setState_phX;

 function Buildings.Utilities.Math.Functions.splineDerivatives
  input Real[:] x;
  input Real[:] y;
  input Boolean ensureMonotonicity;
  output Real[:] d;
  Integer n;
  Real[:] delta;
  Real alpha;
  Real beta;
  Real tau;
 algorithm
  assert(size(x, 1) == size(y, 1), "Mismatching sizes in function 'Buildings.Utilities.Math.Functions.splineDerivatives', component 'y', dimension '1'");
  init d as Real[size(x, 1)];
  n := size(x, 1);
  init delta as Real[n - 1];
  if n > 1 then
   assert(x[1] < x[n], "x must be strictly increasing.
  Received x[1] = " + String(x[1]) + "
           x[" + String(n) + "] = " + String(x[n]));
   assert(Buildings.Utilities.Math.Functions.isMonotonic(x, true), "x-values must be strictly monontone increasing or decreasing.");
   if ensureMonotonicity then
    assert(Buildings.Utilities.Math.Functions.isMonotonic(y, false), "If ensureMonotonicity=true, y-values must be monontone increasing or decreasing.");
   end if;
  end if;
  if n == 1 then
   d[1] := 0;
  elseif n == 2 then
   d[1] := (y[2] - y[1]) / (x[2] - x[1]);
   d[2] := d[1];
  else
   for i in 1:n - 1 loop
    delta[i] := (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
   end for;
   d[1] := delta[1];
   d[n] := delta[n - 1];
   for i in 2:n - 1 loop
    d[i] := (delta[i - 1] + delta[i]) / 2;
   end for;
  end if;
  if n > 2 and ensureMonotonicity then
   for i in 1:n - 1 loop
    if abs(delta[i]) < 1.0E-60 then
     d[i] := 0;
     d[i + 1] := 0;
    else
     alpha := d[i] / delta[i];
     beta := d[i + 1] / delta[i];
     if alpha ^ 2 + beta ^ 2 > 9 then
      tau := 3 / (alpha ^ 2 + beta ^ 2) ^ (1 / 2);
      d[i] := delta[i] * alpha * tau;
      d[i + 1] := delta[i] * beta * tau;
     end if;
    end if;
   end for;
  end if;
  return;
 end Buildings.Utilities.Math.Functions.splineDerivatives;

 function Buildings.Utilities.Math.Functions.isMonotonic
  input Real[:] x;
  input Boolean strict;
  output Boolean monotonic;
  Integer n;
 algorithm
  n := size(x, 1);
  if n == 1 then
   monotonic := true;
  else
   monotonic := true;
   if strict then
    if x[1] >= x[n] then
     for i in 1:n - 1 loop
      if not x[i] > x[i + 1] then
       monotonic := false;
      end if;
     end for;
    else
     for i in 1:n - 1 loop
      if not x[i] < x[i + 1] then
       monotonic := false;
      end if;
     end for;
    end if;
   else
    if x[1] >= x[n] then
     for i in 1:n - 1 loop
      if not x[i] >= x[i + 1] then
       monotonic := false;
      end if;
     end for;
    else
     for i in 1:n - 1 loop
      if not x[i] <= x[i + 1] then
       monotonic := false;
      end if;
     end for;
    end if;
   end if;
  end if;
  return;
 end Buildings.Utilities.Math.Functions.isMonotonic;

 function Modelica.Math.BooleanVectors.allTrue
  input Boolean[:] b;
  output Boolean result;
 algorithm
  result := size(b, 1) > 0;
  for i in 1:size(b, 1) loop
   result := result and b[i];
  end for;
  return;
 end Modelica.Math.BooleanVectors.allTrue;

 function Modelica.SIunits.Conversions.from_degC
  input Real Celsius;
  output Real Kelvin;
 algorithm
  Kelvin := Celsius - -273.15;
  return;
 annotation(Inline = true);
 end Modelica.SIunits.Conversions.from_degC;

 function Buildings.Media.Air.temperature
  input Buildings.Media.Air.ThermodynamicState state;
  output Real T;
 algorithm
  assert(2 == size(state.X, 1), "Mismatching sizes in function 'Buildings.Media.Air.temperature', component 'state.X', dimension '1'");
  T := state.T;
  return;
 annotation(Inline = true,smoothOrder = 2);
 end Buildings.Media.Air.temperature;

 function Buildings.Media.Air.dynamicViscosity
  input Buildings.Media.Air.ThermodynamicState state;
  output Real eta;
 algorithm
  assert(2 == size(state.X, 1), "Mismatching sizes in function 'Buildings.Media.Air.dynamicViscosity', component 'state.X', dimension '1'");
  eta := 4.89493640395E-8 * state.T + 3.88335940547E-6;
  return;
 annotation(Inline = true,smoothOrder = 99);
 end Buildings.Media.Air.dynamicViscosity;

 function Buildings.Media.Water.specificEnthalpy
  input Buildings.Media.Water.ThermodynamicState state;
  output Real h;
 algorithm
  h := 4184.0 * (state.T - 273.15);
  return;
 end Buildings.Media.Water.specificEnthalpy;

 function Buildings.Utilities.Math.Functions.smoothMin
  input Real x1;
  input Real x2;
  input Real deltaX;
  output Real y;
 algorithm
  y := Buildings.Utilities.Math.Functions.regStep(x2 - x1, x1, x2, deltaX);
  return;
 annotation(Inline = true,smoothOrder = 1);
 end Buildings.Utilities.Math.Functions.smoothMin;

 function Buildings.Utilities.Math.Functions.regStep
  input Real x;
  input Real y1;
  input Real y2;
  input Real x_small;
  output Real y;
 algorithm
  y := smooth(1, if x > x_small then y1 elseif x < - x_small then y2 elseif x_small > 0 then x / x_small * ((x / x_small) ^ 2 - 3) * (y2 - y1) / 4 + (y1 + y2) / 2 else (y1 + y2) / 2);
  return;
 annotation(Inline = true);
 end Buildings.Utilities.Math.Functions.regStep;

 function Buildings.Utilities.Math.Functions.smoothMax
  input Real x1;
  input Real x2;
  input Real deltaX;
  output Real y;
 algorithm
  y := Buildings.Utilities.Math.Functions.regStep(x1 - x2, x1, x2, deltaX);
  return;
 annotation(Inline = true,smoothOrder = 1);
 end Buildings.Utilities.Math.Functions.smoothMax;

 function Buildings.Media.Water.temperature_phX
  input Real p;
  input Real h;
  input Real[:] X;
  output Real T;
 algorithm
  assert(1 == size(X, 1), "Mismatching sizes in function 'Buildings.Media.Water.temperature_phX', component 'X', dimension '1'");
  T := 273.15 + h / 4184.0;
  return;
 end Buildings.Media.Water.temperature_phX;

 function Buildings.Media.Water.specificInternalEnergy
  input Buildings.Media.Water.ThermodynamicState state;
  output Real u;
 algorithm
  u := 4184.0 * (state.T - 273.15);
  return;
 end Buildings.Media.Water.specificInternalEnergy;

 function Buildings.Media.Water.setState_phX
  input Real p;
  input Real h;
  input Real[:] X;
  output Buildings.Media.Water.ThermodynamicState state;
 algorithm
  state := Buildings.Media.Water.ThermodynamicState(p, 273.15 + h / 4184.0);
  return;
 end Buildings.Media.Water.setState_phX;

 function Buildings.Media.Water.density_phX
  input Real p;
  input Real h;
  input Real[:] X;
  output Real d;
 algorithm
  assert(1 == size(X, 1), "Mismatching sizes in function 'Buildings.Media.Water.density_phX', component 'X', dimension '1'");
  d := Buildings.Media.Water.density(Buildings.Media.Water.setState_phX(p, h, X));
  return;
 end Buildings.Media.Water.density_phX;

 function Buildings.Utilities.Math.Functions.regNonZeroPower
  input Real x;
  input Real n;
  input Real delta;
  output Real y;
  Real a1;
  Real a3;
  Real a5;
  Real delta2;
  Real x2;
  Real y_d;
  Real yP_d;
  Real yPP_d;
 algorithm
  if abs(x) > delta then
   y := abs(x) ^ n;
  else
   delta2 := delta * delta;
   x2 := x * x;
   y_d := delta ^ n;
   yP_d := n * delta ^ (n - 1);
   yPP_d := n * (n - 1) * delta ^ (n - 2);
   a1 := (yPP_d - yP_d / delta) / delta2 / 8;
   a3 := (yPP_d - 12 * a1 * delta2) / 2;
   a5 := y_d - delta2 * (a3 + delta2 * a1);
   y := a5 + x2 * (a3 + x2 * a1);
   assert(a5 > 0, "Delta is too small for this exponent.");
  end if;
  return;
 annotation(derivative(zeroDerivative = n,zeroDerivative = delta) = Buildings.Utilities.Math.Functions.BaseClasses.der_regNonZeroPower,Inline = true,smoothOrder = 2);
 end Buildings.Utilities.Math.Functions.regNonZeroPower;

 function Buildings.Utilities.Math.Functions.BaseClasses.der_regNonZeroPower
  input Real x;
  input Real n;
  input Real delta;
  input Real der_x;
  output Real der_y;
  Real a1;
  Real a3;
  Real delta2;
  Real x2;
  Real y_d;
  Real yP_d;
  Real yPP_d;
 algorithm
  if abs(x) > delta then
   der_y := sign(x) * n * abs(x) ^ (n - 1) * der_x;
  else
   delta2 := delta * delta;
   x2 := x * x;
   y_d := delta ^ n;
   yP_d := n * delta ^ (n - 1);
   yPP_d := n * (n - 1) * delta ^ (n - 2);
   a1 := (yPP_d - yP_d / delta) / delta2 / 8;
   a3 := (yPP_d - 12 * a1 * delta2) / 2;
   der_y := x * (4 * a1 * x * x + 2 * a3) * der_x;
  end if;
  return;
 annotation(derivative(order = 2,zeroDerivative = n,zeroDerivative = delta) = Buildings.Utilities.Math.Functions.BaseClasses.der_2_regNonZeroPower);
 end Buildings.Utilities.Math.Functions.BaseClasses.der_regNonZeroPower;

 function Buildings.Utilities.Math.Functions.BaseClasses.der_2_regNonZeroPower
  input Real x;
  input Real n;
  input Real delta;
  input Real der_x;
  input Real der_2_x;
  output Real der_2_y;
  Real a1;
  Real a3;
  Real delta2;
  Real x2;
  Real y_d;
  Real yP_d;
  Real yPP_d;
 algorithm
  if abs(x) > delta then
   der_2_y := n * (abs(x) ^ (n - 1) * sign(x) * der_2_x + (n - 1) * abs(x) ^ (n - 2) * der_x ^ 2);
  else
   delta2 := delta * delta;
   x2 := x * x;
   y_d := delta ^ n;
   yP_d := n * delta ^ (n - 1);
   yPP_d := n * (n - 1) * delta ^ (n - 2);
   a1 := (yPP_d - yP_d / delta) / delta2 / 8;
   a3 := (yPP_d - 12 * a1 * delta2) / 2;
   der_2_y := (12 * a1 * x2 + 2 * a3) * der_x ^ 2 + x * (4 * a1 * x2 + 2 * a3) * der_2_x;
  end if;
  return;
 end Buildings.Utilities.Math.Functions.BaseClasses.der_2_regNonZeroPower;

 function Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ
  input Real eps;
  input Real Z;
  input Integer flowRegime;
  output Real NTU;
  Real a;
 algorithm
  if flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow) then
   a := Z + 1;
   assert(eps < 1 / a, "Invalid input data. eps > 1/(1+Z) is physically not possible for parallel flow.
  Received eps = " + String(eps) + "
             Z = " + String(Z) + "
       1/(Z+1) = " + String(1 / a));
   NTU := (- log(1 - eps * a)) / a;
  elseif flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow) then
   a := smooth(1, if Z < 0.97 then Z else Buildings.Utilities.Math.Functions.smoothMin(Z, 0.98, 0.01));
   NTU := log((1 - eps) / (1 - eps * a)) / (a - 1);
  elseif flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed) then
   a := 0;
   NTU := Modelica.Math.Nonlinear.solveOneNonlinearEquation(function Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ.epsilon_ntuZ_crossFlowUnmixed(eps, Z), 1.5 * 1.0E-10, 1000000.0, 100 * 1.0E-15);
  elseif flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed) then
   a := smooth(1, if Z > 0.03 then Z else Buildings.Utilities.Math.Functions.smoothMin(0.02, Z, 0.01));
   NTU := - log(1 + log(1 - eps * a) / a);
  elseif flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed) then
   a := smooth(1, if Z > 0.03 then Z else Buildings.Utilities.Math.Functions.smoothMin(0.02, Z, 0.01));
   NTU := (- log(1 + Z * log(1 - eps))) / Z;
  elseif flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.ConstantTemperaturePhaseChange) then
   a := 0;
   NTU := - log(1 - eps);
  else
   a := 0;
   NTU := 0;
   assert(Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow) <= flowRegime and flowRegime <= Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.ConstantTemperaturePhaseChange), "Flow regime is not implemented.");
  end if;
  return;
 annotation(smoothOrder = 1);
 end Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ;

 function Modelica.Math.Nonlinear.solveOneNonlinearEquation
  input ((Real y) = Modelica.Math.Nonlinear.Interfaces.partialScalarFunction(Real u)) f;
  input Real u_min;
  input Real u_max;
  input Real tolerance;
  output Real u;
  Real a;
  Real b;
  Real c;
  Real d;
  Real e;
  Real m;
  Real s;
  Real p;
  Real q;
  Real r;
  Real tol;
  Real fa;
  Real fb;
  Real fc;
  Boolean found;
 algorithm
  a := u_min;
  b := u_max;
  found := false;
  fa := f(u_min);
  fb := f(u_max);
  fc := fb;
  if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
   Modelica.Utilities.Streams.error("The arguments u_min and u_max provided in the function call\n" + "    solveOneNonlinearEquation(f,u_min,u_max)\n" + "do not bracket the root of the single non-linear equation 0=f(u):\n" + "  u_min  = " + String(u_min) + "\n" + "  u_max  = " + String(u_max) + "\n" + "  fa = f(u_min) = " + String(fa) + "\n" + "  fb = f(u_max) = " + String(fb) + "\n" + "fa and fb must have opposite sign which is not the case");
  end if;
  c := a;
  fc := fa;
  e := b - a;
  d := e;
  while not found loop
   if abs(fc) < abs(fb) then
    a := b;
    b := c;
    c := a;
    fa := fb;
    fb := fc;
    fc := fa;
   end if;
   tol := 2 * 1.0E-15 * abs(b) + tolerance;
   m := (c - b) / 2;
   if abs(m) <= tol or fb == 0.0 then
    found := true;
    u := b;
   else
    if abs(e) < tol or abs(fa) <= abs(fb) then
     e := m;
     d := e;
    else
     s := fb / fa;
     if a == c then
      p := 2 * m * s;
      q := 1 - s;
     else
      q := fa / fc;
      r := fb / fc;
      p := s * (2 * m * q * (q - r) - (b - a) * (r - 1));
      q := (q - 1) * (r - 1) * (s - 1);
     end if;
     if p > 0 then
      q := - q;
     else
      p := - p;
     end if;
     s := e;
     e := d;
     if 2 * p < 3 * m * q - abs(tol * q) and p < abs(0.5 * s * q) then
      d := p / q;
     else
      e := m;
      d := e;
     end if;
    end if;
    a := b;
    fa := fb;
    b := b + (if abs(d) > tol then d elseif m > 0 then tol else - tol);
    fb := f(b);
    if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
     c := a;
     fc := fa;
     e := b - a;
     d := e;
    end if;
   end if;
  end while;
  return;
 end Modelica.Math.Nonlinear.solveOneNonlinearEquation;

 function Modelica.Math.Nonlinear.Interfaces.partialScalarFunction
  input Real u;
  output Real y;
 algorithm
  return;
 end Modelica.Math.Nonlinear.Interfaces.partialScalarFunction;

 function Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ.epsilon_ntuZ_crossFlowUnmixed
  input Real u;
  output Real y;
  input Real eps;
  input Real Z;
  Real NTUExp;
 algorithm
  NTUExp := u ^ -0.22;
  y := 1 - exp((exp((- u) * Z * NTUExp) - 1) / (Z * NTUExp)) - eps;
  return;
 end Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ.epsilon_ntuZ_crossFlowUnmixed;

 function Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C
  input Real UA;
  input Real C1_flow;
  input Real C2_flow;
  input Integer flowRegime;
  input Real CMin_flow_nominal;
  input Real CMax_flow_nominal;
  input Real delta;
  output Real eps;
  Real deltaCMin;
  Real deltaCMax;
  Real CMin_flow;
  Real CMax_flow;
  Real CMinNZ_flow;
  Real CMaxNZ_flow;
  Real gaiEps;
  Real gaiNTU;
  Real NTU;
  Real Z;
 algorithm
  deltaCMin := delta * CMin_flow_nominal;
  deltaCMax := delta * CMax_flow_nominal;
  CMin_flow := Buildings.Utilities.Math.Functions.smoothMin(C1_flow, C2_flow, deltaCMin / 4);
  CMax_flow := Buildings.Utilities.Math.Functions.smoothMax(C1_flow, C2_flow, deltaCMax / 4);
  CMinNZ_flow := Buildings.Utilities.Math.Functions.smoothMax(CMin_flow, deltaCMin, deltaCMin / 4);
  CMaxNZ_flow := Buildings.Utilities.Math.Functions.smoothMax(CMax_flow, deltaCMax, deltaCMax / 4);
  Z := CMin_flow / CMaxNZ_flow + 1.0E-10 * deltaCMin;
  gaiEps := Buildings.Utilities.Math.Functions.spliceFunction(1, 0, CMin_flow - deltaCMin, deltaCMin / 2);
  gaiNTU := Buildings.Utilities.Math.Functions.spliceFunction(1, delta, CMin_flow - deltaCMin, deltaCMin / 2);
  NTU := gaiNTU * UA / CMinNZ_flow;
  eps := gaiEps * Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(NTU, Z, flowRegime);
  return;
 annotation(Inline = false,smoothOrder = 1);
 end Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C;

 function Buildings.Utilities.Math.Functions.spliceFunction
  input Real pos;
  input Real neg;
  input Real x;
  input Real deltax;
  output Real out;
  Real scaledX1;
  Real y;
 algorithm
  scaledX1 := x / deltax;
  if scaledX1 <= -0.999999999 then
   out := neg;
  elseif scaledX1 >= 0.999999999 then
   out := pos;
  else
   y := (tanh(tan(scaledX1 * 1.5707963267948966)) + 1) / 2;
   out := pos * y + (1 - y) * neg;
  end if;
  return;
 annotation(derivative = Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction,smoothOrder = 1);
 end Buildings.Utilities.Math.Functions.spliceFunction;

 function Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction
  input Real pos;
  input Real neg;
  input Real x;
  input Real deltax;
  input Real dpos;
  input Real dneg;
  input Real dx;
  input Real ddeltax;
  output Real out;
  Real scaledX;
  Real scaledX1;
  Real dscaledX1;
  Real y;
 algorithm
  scaledX1 := x / deltax;
  if scaledX1 <= -0.99999999999 then
   out := dneg;
  elseif scaledX1 >= 0.9999999999 then
   out := dpos;
  else
   scaledX := scaledX1 * 1.5707963267948966;
   dscaledX1 := (dx - scaledX1 * ddeltax) / deltax;
   y := (tanh(tan(scaledX)) + 1) / 2;
   out := dpos * y + (1 - y) * dneg;
   out := out + (pos - neg) * dscaledX1 * 1.5707963267948966 / 2 / (cosh(tan(scaledX)) * cos(scaledX)) ^ 2;
  end if;
  return;
 end Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction;

 function Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ
  input Real NTU;
  input Real Z;
  input Integer flowRegime;
  output Real eps;
  Real a;
 algorithm
  if flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow) then
   a := 0;
   eps := (1 - exp((- NTU) * (1 + Z))) / (1 + Z);
  elseif flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.CounterFlow) then
   a := smooth(1, if Z < 0.97 then Z else Buildings.Utilities.Math.Functions.smoothMin(Z, 0.98, 0.01));
   eps := (1 - exp((- NTU) * (1 - a))) / (1 - a * exp((- NTU) * (1 - a)));
  elseif flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed) then
   a := NTU ^ -0.22;
   eps := 1 - exp((exp((- NTU) * Z * a) - 1) / (Z * a));
  elseif flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinUnmixedCMaxMixed) then
   a := 0;
   eps := (1 - exp((- Z) * (1 - exp(- NTU)))) / Z;
  elseif flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowCMinMixedCMaxUnmixed) then
   a := 0;
   eps := 1 - exp((exp((- Z) * NTU) - 1) / Z);
  elseif flowRegime == Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.ConstantTemperaturePhaseChange) then
   a := 0;
   eps := 1 - exp(- NTU);
  else
   a := 0;
   eps := 0;
   assert(Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.ParallelFlow) <= flowRegime and flowRegime <= Integer(Buildings.Fluid.Types.HeatExchangerFlowRegime.ConstantTemperaturePhaseChange), "Flow regime is not implemented.");
  end if;
  return;
 annotation(smoothOrder = 1);
 end Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ;

 function Buildings.Utilities.Math.Functions.inverseXRegularized
  input Real x;
  input Real delta;
  input Real deltaInv;
  input Real a;
  input Real b;
  input Real c;
  input Real d;
  input Real e;
  input Real f;
  output Real y;
 algorithm
  y := if x > delta or x < - delta then 1 / x elseif x < delta / 2 and x > (- delta) / 2 then x / (delta * delta) else Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition(x, delta, deltaInv, a, b, c, d, e, f);
  return;
 annotation(derivative(order = 1,zeroDerivative = delta,zeroDerivative = deltaInv,zeroDerivative = a,zeroDerivative = b,zeroDerivative = c,zeroDerivative = d,zeroDerivative = e,zeroDerivative = f) = Buildings.Utilities.Math.Functions.BaseClasses.der_inverseXRegularized,Inline = true,smoothOrder = 2);
 end Buildings.Utilities.Math.Functions.inverseXRegularized;

 function Buildings.Utilities.Math.Functions.BaseClasses.der_inverseXRegularized
  input Real x;
  input Real delta;
  input Real deltaInv;
  input Real a;
  input Real b;
  input Real c;
  input Real d;
  input Real e;
  input Real f;
  input Real x_der;
  output Real y_der;
 algorithm
  y_der := if x > delta or x < - delta then (- x_der) / x / x elseif x < delta / 2 and x > (- delta) / 2 then x_der / (delta * delta) else Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition(x, delta, deltaInv, a, b, c, d, e, f, x_der);
  return;
 end Buildings.Utilities.Math.Functions.BaseClasses.der_inverseXRegularized;

 function Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition
  input Real x;
  input Real delta;
  input Real deltaInv;
  input Real a;
  input Real b;
  input Real c;
  input Real d;
  input Real e;
  input Real f;
  input Real x_der;
  output Real y_der;
  Real aX;
 algorithm
  aX := abs(x);
  y_der := (b + aX * (2 * c + aX * (3 * d + aX * (4 * e + aX * 5 * f)))) * x_der;
  return;
 annotation(derivative(order = 2,zeroDerivative = delta,zeroDerivative = deltaInv,zeroDerivative = a,zeroDerivative = b,zeroDerivative = c,zeroDerivative = d,zeroDerivative = e,zeroDerivative = f) = Buildings.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition,smoothOrder = 1);
 end Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition;

 function Buildings.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition
  input Real x;
  input Real delta;
  input Real deltaInv;
  input Real a;
  input Real b;
  input Real c;
  input Real d;
  input Real e;
  input Real f;
  input Real x_der;
  input Real x_der2;
  output Real y_der2;
  Real aX;
  Real ex;
 algorithm
  aX := abs(x);
  ex := 2 * c + aX * (6 * d + aX * (12 * e + aX * 20 * f));
  y_der2 := (b + aX * (2 * c + aX * (3 * d + aX * (4 * e + aX * 5 * f)))) * x_der2 + x_der * x_der * (if x > 0 then ex else - ex);
  return;
 end Buildings.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition;

 function Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition
  input Real x;
  input Real delta;
  input Real deltaInv;
  input Real a;
  input Real b;
  input Real c;
  input Real d;
  input Real e;
  input Real f;
  output Real y;
  Real aX;
 algorithm
  aX := abs(x);
  y := (if x >= 0 then 1 else -1) * (a + aX * (b + aX * (c + aX * (d + aX * (e + aX * f)))));
  return;
 annotation(derivative(order = 1,zeroDerivative = delta,zeroDerivative = deltaInv,zeroDerivative = a,zeroDerivative = b,zeroDerivative = c,zeroDerivative = d,zeroDerivative = e,zeroDerivative = f) = Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition,smoothOrder = 2);
 end Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition;

 function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp
  input Real dp;
  input Real k;
  input Real m_flow_turbulent;
  output Real m_flow;
  Real dp_turbulent;
  Real dpNorm;
  Real dpNormSq;
 algorithm
  dp_turbulent := (m_flow_turbulent / k) ^ 2;
  dpNorm := dp / dp_turbulent;
  dpNormSq := dpNorm ^ 2;
  m_flow := smooth(2, if noEvent(abs(dp) > dp_turbulent) then sign(dp) * k * sqrt(abs(dp)) else (1.40625 + (0.15625 * dpNormSq - 0.5625) * dpNormSq) * m_flow_turbulent * dpNorm);
  return;
 annotation(derivative(order = 1,zeroDerivative = k,zeroDerivative = m_flow_turbulent) = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der,Inline = false,smoothOrder = 2);
 end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp;

 function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der
  input Real dp;
  input Real k;
  input Real m_flow_turbulent;
  input Real dp_der;
  output Real m_flow_der;
  Real dp_turbulent;
  Real dpNormSq;
 algorithm
  dp_turbulent := (m_flow_turbulent / k) ^ 2;
  dpNormSq := (dp / dp_turbulent) ^ 2;
  m_flow_der := (if noEvent(abs(dp) > dp_turbulent) then 0.5 * k / sqrt(abs(dp)) else (1.40625 + (0.78125 * dpNormSq - 1.6875) * dpNormSq) * m_flow_turbulent / dp_turbulent) * dp_der;
  return;
 annotation(derivative(order = 2,zeroDerivative = k,zeroDerivative = m_flow_turbulent) = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2,Inline = false,smoothOrder = 1);
 end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der;

 function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2
  input Real dp;
  input Real k;
  input Real m_flow_turbulent;
  input Real dp_der;
  input Real dp_der2;
  output Real m_flow_der2;
  Real dp_turbulent;
  Real dpNorm;
  Real dpNormSq;
 algorithm
  dp_turbulent := (m_flow_turbulent / k) ^ 2;
  dpNorm := dp / dp_turbulent;
  dpNormSq := dpNorm ^ 2;
  m_flow_der2 := if noEvent(abs(dp) > dp_turbulent) then 0.5 * k / sqrt(abs(dp)) * (-0.5 / dp * dp_der ^ 2 + dp_der2) else m_flow_turbulent / dp_turbulent * ((1.40625 + (0.78125 * dpNormSq - 1.6875) * dpNormSq) * dp_der2 + (-3.375 + 3.125 * dpNormSq) * dpNorm / dp_turbulent * dp_der ^ 2);
  return;
 annotation(Inline = false,smoothOrder = 0);
 end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2;

 function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow
  input Real m_flow;
  input Real k;
  input Real m_flow_turbulent;
  output Real dp;
  Real dp_turbulent;
  Real m_flowNorm;
  Real m_flowNormSq;
 algorithm
  dp_turbulent := (m_flow_turbulent / k) ^ 2;
  m_flowNorm := m_flow / m_flow_turbulent;
  m_flowNormSq := m_flowNorm ^ 2;
  dp := smooth(2, if noEvent(abs(m_flow) > m_flow_turbulent) then sign(m_flow) * (m_flow / k) ^ 2 else (0.375 + (0.75 - 0.125 * m_flowNormSq) * m_flowNormSq) * dp_turbulent * m_flowNorm);
  return;
 annotation(derivative(order = 1,zeroDerivative = k,zeroDerivative = m_flow_turbulent) = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der,Inline = false,smoothOrder = 2);
 end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow;

 function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der
  input Real m_flow;
  input Real k;
  input Real m_flow_turbulent;
  input Real m_flow_der;
  output Real dp_der;
  Real dp_turbulent;
  Real m_flowNormSq;
 algorithm
  dp_turbulent := (m_flow_turbulent / k) ^ 2;
  m_flowNormSq := (m_flow / m_flow_turbulent) ^ 2;
  dp_der := (if noEvent(abs(m_flow) > m_flow_turbulent) then sign(m_flow) * 2 * m_flow / k ^ 2 else (0.375 + (2.25 - 0.625 * m_flowNormSq) * m_flowNormSq) * dp_turbulent / m_flow_turbulent) * m_flow_der;
  return;
 annotation(derivative(order = 2,zeroDerivative = k,zeroDerivative = m_flow_turbulent) = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2,Inline = false,smoothOrder = 1);
 end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der;

 function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2
  input Real m_flow;
  input Real k;
  input Real m_flow_turbulent;
  input Real m_flow_der;
  input Real m_flow_der2;
  output Real dp_der2;
  Real dp_turbulent;
  Real m_flowNorm;
  Real m_flowNormSq;
 algorithm
  dp_turbulent := (m_flow_turbulent / k) ^ 2;
  m_flowNorm := m_flow / m_flow_turbulent;
  m_flowNormSq := m_flowNorm ^ 2;
  dp_der2 := if noEvent(abs(m_flow) > m_flow_turbulent) then sign(m_flow) * 2 / k ^ 2 * (m_flow_der ^ 2 + m_flow * m_flow_der2) else dp_turbulent / m_flow_turbulent * ((0.375 + (2.25 - 0.625 * m_flowNormSq) * m_flowNormSq) * m_flow_der2 + (4.5 - 2.5 * m_flowNormSq) * m_flowNorm / m_flow_turbulent * m_flow_der ^ 2);
  return;
 annotation(Inline = false,smoothOrder = 0);
 end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2;

 function Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getNextTimeEvent
  input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
  input Real timeIn;
  input Real tableAvailable;
  output Real nextTimeEvent;
 algorithm
  external "C" nextTimeEvent = ModelicaStandardTables_CombiTimeTable_nextTimeEvent(tableID, timeIn);
  return;
 end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getNextTimeEvent;

 function Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableValueNoDer
  input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
  input Integer icol;
  input Real timeIn;
  input Real nextTimeEvent;
  input Real pre_nextTimeEvent;
  input Real tableAvailable;
  output Real y;
 algorithm
  external "C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent);
  return;
 end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableValueNoDer;

 function Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableValue
  input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
  input Integer icol;
  input Real timeIn;
  input Real nextTimeEvent;
  input Real pre_nextTimeEvent;
  input Real tableAvailable;
  output Real y;
 algorithm
  external "C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent);
  return;
 annotation(derivative(noDerivative = nextTimeEvent,noDerivative = pre_nextTimeEvent,noDerivative = tableAvailable) = Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getDerTableValue);
 end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableValue;

 function Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getDerTableValue
  input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
  input Integer icol;
  input Real timeIn;
  input Real nextTimeEvent;
  input Real pre_nextTimeEvent;
  input Real tableAvailable;
  input Real der_timeIn;
  output Real der_y;
 algorithm
  external "C" der_y = ModelicaStandardTables_CombiTimeTable_getDerValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent, der_timeIn);
  return;
 end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getDerTableValue;

 function Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.readTableData
  input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
  input Boolean forceRead;
  output Real readSuccess;
  input Boolean verboseRead;
 algorithm
  external "C" readSuccess = ModelicaStandardTables_CombiTimeTable_read(tableID, forceRead, verboseRead);
  return;
 end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.readTableData;

 function Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableTimeTmin
  input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
  input Real tableAvailable;
  output Real timeMin;
 algorithm
  external "C" timeMin = ModelicaStandardTables_CombiTimeTable_minimumTime(tableID);
  return;
 end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableTimeTmin;

 function Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableTimeTmax
  input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
  input Real tableAvailable;
  output Real timeMax;
 algorithm
  external "C" timeMax = ModelicaStandardTables_CombiTimeTable_maximumTime(tableID);
  return;
 end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.loa.getTableTimeTmax;

 function Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping
  input Integer order;
  input Boolean normalized;
  output Real[:] cr;
  Real alpha;
  Real alpha2;
  Real[:] den1;
  Real[:,:] den2;
  Real[:] c0;
  Real[:] c1;
 algorithm
  init cr as Real[order];
  alpha := 1.0;
  init den1 as Real[order];
  init den2 as Real[0, 2];
  init c0 as Real[0];
  init c1 as Real[0];
  if normalized then
   alpha := sqrt(10 ^ (3 / 10 / order) - 1);
  else
   alpha := 1.0;
  end if;
  for i in 1:order loop
   den1[i] := alpha;
  end for;
  (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping;

 function Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne
  input Real[:] den1;
  input Real[:,:] den2;
  output Real[:] cr;
  output Real[:] c0;
  output Real[:] c1;
 algorithm
  assert(2 == size(den2, 2), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne', component 'den2', dimension '2'");
  init cr as Real[size(den1, 1)];
  init c0 as Real[size(den2, 1)];
  init c1 as Real[size(den2, 1)];
  for i in 1:size(den1, 1) loop
   cr[i] := 1 / den1[i];
  end for;
  for i in 1:size(den2, 1) loop
   c1[i] := den2[i,2] / den2[i,1];
   c0[i] := 1 / den2[i,1];
  end for;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne;

 function Modelica.Blocks.Continuous.Internal.Filter.base.Bessel
  input Integer order;
  input Boolean normalized;
  output Real[:] cr;
  output Real[:] c0;
  output Real[:] c1;
  Real alpha;
  Real alpha2;
  Real[:] den1;
  Real[:,:] den2;
 algorithm
  init cr as Real[order - integer(order / 2) * 2];
  init c0 as Real[integer(order / 2)];
  init c1 as Real[integer(order / 2)];
  alpha := 1.0;
  init den1 as Real[size(cr, 1)];
  init den2 as Real[size(c0, 1), 2];
  (den1, den2, alpha) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.BesselBaseCoefficients(order);
  if not normalized then
   alpha2 := alpha * alpha;
   for i in 1:size(c0, 1) loop
    den2[i,1] := den2[i,1] * alpha2;
    den2[i,2] := den2[i,2] * alpha;
   end for;
   if size(cr, 1) == 1 then
    den1[1] := den1[1] * alpha;
   end if;
  end if;
  (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.base.Bessel;

 function Modelica.Blocks.Continuous.Internal.Filter.Utilities.BesselBaseCoefficients
  input Integer order;
  output Real[:] c1;
  output Real[:,:] c2;
  output Real alpha;
 algorithm
  init c1 as Real[order - integer(order / 2) * 2];
  init c2 as Real[integer(order / 2), 2];
  if order == 1 then
   alpha := 1.002377293007601;
   c1[1] := 0.9976283451109835;
  elseif order == 2 then
   alpha := 0.7356641785819585;
   c2[1,1] := 0.6159132201783791;
   c2[1,2] := 1.359315879600889;
  elseif order == 3 then
   alpha := 0.5704770156982641;
   c1[1] := 0.7548574865985344;
   c2[1,1] := 0.4756958028827457;
   c2[1,2] := 0.9980615136104388;
  elseif order == 4 then
   alpha := 0.4737978580281427;
   c2[1,1] := 0.4873729247240677;
   c2[1,2] := 1.337564170455762;
   c2[2,1] := 0.3877724315741958;
   c2[2,2] := 0.7730405590839861;
  elseif order == 5 then
   alpha := 0.4126226974763408;
   c1[1] := 0.6645723262620757;
   c2[1,1] := 0.4115231900614016;
   c2[1,2] := 1.138349926728708;
   c2[2,1] := 0.3234938702877912;
   c2[2,2] := 0.6205992985771313;
  elseif order == 6 then
   alpha := 0.3705098000736233;
   c2[1,1] := 0.387450864909896;
   c2[1,2] := 1.219740879520741;
   c2[2,1] := 0.3493298843155746;
   c2[2,2] := 0.9670265529381366;
   c2[3,1] := 0.2747419229514599;
   c2[3,2] := 0.51221650751057;
  elseif order == 7 then
   alpha := 0.339345262358635;
   c1[1] := 0.5927147125821411;
   c2[1,1] := 0.3383379423919174;
   c2[1,2] := 1.09263081643803;
   c2[2,1] := 0.3001025788696046;
   c2[2,2] := 0.8289928256598657;
   c2[3,1] := 0.2372867471539579;
   c2[3,2] := 0.4325128641920154;
  elseif order == 8 then
   alpha := 0.3150267393795002;
   c2[1,1] := 0.3151115975207653;
   c2[1,2] := 1.10940301546019;
   c2[2,1] := 0.2969344839572762;
   c2[2,2] := 0.97374558122227;
   c2[3,1] := 0.2612545921889538;
   c2[3,2] := 0.7190394712068573;
   c2[4,1] := 0.2080523342974281;
   c2[4,2] := 0.3721456473047434;
  elseif order == 9 then
   alpha := 0.2953310177184124;
   c1[1] := 0.5377196679501423;
   c2[1,1] := 0.2824689124281034;
   c2[1,2] := 1.022646191567475;
   c2[2,1] := 0.2626824161383468;
   c2[2,2] := 0.8695626454762596;
   c2[3,1] := 0.2302781917677917;
   c2[3,2] := 0.630904755344852;
   c2[4,1] := 0.1847991729757028;
   c2[4,2] := 0.3251978031287202;
  elseif order == 10 then
   alpha := 0.2789426890619463;
   c2[1,1] := 0.2640769908255582;
   c2[1,2] := 1.019788132875305;
   c2[2,1] := 0.2540802639216947;
   c2[2,2] := 0.9377020417760623;
   c2[3,1] := 0.2343577229427963;
   c2[3,2] := 0.7802229808216112;
   c2[4,1] := 0.2052193139338624;
   c2[4,2] := 0.5594176813008133;
   c2[5,1] := 0.1659546953748916;
   c2[5,2] := 0.2878349616233292;
  elseif order == 11 then
   alpha := 0.2650227766037203;
   c1[1] := 0.4950265498954191;
   c2[1,1] := 0.2411858478546218;
   c2[1,2] := 0.9567800996387417;
   c2[2,1] := 0.2296849355380925;
   c2[2,2] := 0.8592523717113126;
   c2[3,1] := 0.2107851705677406;
   c2[3,2] := 0.7040216048898129;
   c2[4,1] := 0.1846461385164021;
   c2[4,2] := 0.5006729207276717;
   c2[5,1] := 0.1504217970817433;
   c2[5,2] := 0.2575070491320295;
  elseif order == 12 then
   alpha := 0.2530051198547209;
   c2[1,1] := 0.2268294941204543;
   c2[1,2] := 0.9473116570034052;
   c2[2,1] := 0.2207657387793729;
   c2[2,2] := 0.8933728946287606;
   c2[3,1] := 0.2087600700376653;
   c2[3,2] := 0.7886236252756229;
   c2[4,1] := 0.190995910149276;
   c2[4,2] := 0.6389263649257017;
   c2[5,1] := 0.1675208146048472;
   c2[5,2] := 0.4517847275162215;
   c2[6,1] := 0.1374257286372761;
   c2[6,2] := 0.232469915747468;
  elseif order == 13 then
   alpha := 0.2424910397561007;
   c1[1] := 0.460884836992804;
   c2[1,1] := 0.209981305027478;
   c2[1,2] := 0.899247882379066;
   c2[2,1] := 0.2027250423101359;
   c2[2,2] := 0.8328117484224146;
   c2[3,1] := 0.1907635894058731;
   c2[3,2] := 0.7257379204691213;
   c2[4,1] := 0.1742280397887686;
   c2[4,2] := 0.5830640944868014;
   c2[5,1] := 0.1530858190490478;
   c2[5,2] := 0.4106192089751885;
   c2[6,1] := 0.1264090712880446;
   c2[6,2] := 0.2114980230156001;
  elseif order == 14 then
   alpha := 0.2331902368695848;
   c2[1,1] := 0.1986162311411235;
   c2[1,2] := 0.8876961808055535;
   c2[2,1] := 0.1946683341271615;
   c2[2,2] := 0.8500754229171967;
   c2[3,1] := 0.1868331332895056;
   c2[3,2] := 0.7764629313723603;
   c2[4,1] := 0.1752118757862992;
   c2[4,2] := 0.6699720402924552;
   c2[5,1] := 0.1598906457908402;
   c2[5,2] := 0.5348446712848934;
   c2[6,1] := 0.1407810153019944;
   c2[6,2] := 0.3755841316563539;
   c2[7,1] := 0.1169627966707339;
   c2[7,2] := 0.1937088226304455;
  elseif order == 15 then
   alpha := 0.2248854870552422;
   c1[1] := 0.4328492272335646;
   c2[1,1] := 0.1857292591004588;
   c2[1,2] := 0.8496337061962563;
   c2[2,1] := 0.1808644178280136;
   c2[2,2] := 0.8020517898136011;
   c2[3,1] := 0.1728264404199081;
   c2[3,2] := 0.7247449729331105;
   c2[4,1] := 0.1616970125901954;
   c2[4,2] := 0.6205369315943097;
   c2[5,1] := 0.1475257264578426;
   c2[5,2] := 0.4929612162355906;
   c2[6,1] := 0.1301861023357119;
   c2[6,2] := 0.3454770708040735;
   c2[7,1] := 0.1087810777120188;
   c2[7,2] := 0.1784526655428406;
  elseif order == 16 then
   alpha := 0.2174105053474761;
   c2[1,1] := 0.1765637967473151;
   c2[1,2] := 0.8377453068635511;
   c2[2,1] := 0.1738525357503125;
   c2[2,2] := 0.8102988957433199;
   c2[3,1] := 0.1684627004613343;
   c2[3,2] := 0.7563265923413258;
   c2[4,1] := 0.1604519074815815;
   c2[4,2] := 0.6776082294687619;
   c2[5,1] := 0.1498828607802206;
   c2[5,2] := 0.576641703402768;
   c2[6,1] := 0.1367764717792823;
   c2[6,2] := 0.4563528264410489;
   c2[7,1] := 0.1209810465419295;
   c2[7,2] := 0.3193782657322374;
   c2[8,1] := 0.1016312648007554;
   c2[8,2] := 0.1652419227369036;
  elseif order == 17 then
   alpha := 0.2106355148193306;
   c1[1] := 0.4093223608497299;
   c2[1,1] := 0.1664014345826274;
   c2[1,2] := 0.8067173752345952;
   c2[2,1] := 0.1629839591538256;
   c2[2,2] := 0.7712924931447541;
   c2[3,1] := 0.1573277802512491;
   c2[3,2] := 0.7134213666303411;
   c2[4,1] := 0.1494828185148637;
   c2[4,2] := 0.6347841731714884;
   c2[5,1] := 0.1394948812681826;
   c2[5,2] := 0.5375594414619047;
   c2[6,1] := 0.1273627583380806;
   c2[6,2] := 0.4241608926375478;
   c2[7,1] := 0.112918725846129;
   c2[7,2] := 0.2965752009703245;
   c2[8,1] := 0.09533357359908858;
   c2[8,2] := 0.1537041700889585;
  elseif order == 18 then
   alpha := 0.2044575288651841;
   c2[1,1] := 0.1588768571976356;
   c2[1,2] := 0.7951914263212913;
   c2[2,1] := 0.1569357024981854;
   c2[2,2] := 0.7744529690772538;
   c2[3,1] := 0.153072220635881;
   c2[3,2] := 0.733530442599208;
   c2[4,1] := 0.1473206710524167;
   c2[4,2] := 0.6735038935387268;
   c2[5,1] := 0.139722542033152;
   c2[5,2] := 0.595915154262159;
   c2[6,1] := 0.1303092459809849;
   c2[6,2] := 0.5026483447894845;
   c2[7,1] := 0.1190627367060072;
   c2[7,2] := 0.395689382458715;
   c2[8,1] := 0.1058058030798994;
   c2[8,2] := 0.276509183073065;
   c2[9,1] := 0.08974708108800873;
   c2[9,2] := 0.1435505288284833;
  elseif order == 19 then
   alpha := 0.1987936248083529;
   c1[1] := 0.3892259966869526;
   c2[1,1] := 0.1506640012172225;
   c2[1,2] := 0.769312173377426;
   c2[2,1] := 0.1481728062796673;
   c2[2,2] := 0.742113358674155;
   c2[3,1] := 0.1440444668388838;
   c2[3,2] := 0.69750753862148;
   c2[4,1] := 0.1383101628540374;
   c2[4,2] := 0.6365464378910025;
   c2[5,1] := 0.1310032283190998;
   c2[5,2] := 0.5606211948462122;
   c2[6,1] := 0.122143116640533;
   c2[6,2] := 0.4713530424221445;
   c2[7,1] := 0.1116991161103884;
   c2[7,2] := 0.3703717538617073;
   c2[8,1] := 0.09948917351196349;
   c2[8,2] := 0.2587371155559744;
   c2[9,1] := 0.08475989238107368;
   c2[9,2] := 0.1345537894555993;
  elseif order == 20 then
   alpha := 0.1935761760416219;
   c2[1,1] := 0.1443871348337404;
   c2[1,2] := 0.7584165598446141;
   c2[2,1] := 0.1429501891353184;
   c2[2,2] := 0.7423000962318863;
   c2[3,1] := 0.1400877384920004;
   c2[3,2] := 0.7104185332215555;
   c2[4,1] := 0.1358210369491446;
   c2[4,2] := 0.663459978327263;
   c2[5,1] := 0.130177370303429;
   c2[5,2] := 0.6024175491895959;
   c2[6,1] := 0.1231826501439148;
   c2[6,2] := 0.5285332736326852;
   c2[7,1] := 0.1148465498575254;
   c2[7,2] := 0.4431977385498628;
   c2[8,1] := 0.1051289462376788;
   c2[8,2] := 0.3477444062821162;
   c2[9,1] := 0.0938462279748512;
   c2[9,2] := 0.2429038300327729;
   c2[10,1] := 0.08028211612831444;
   c2[10,2] := 0.1265329974009533;
  elseif order == 21 then
   alpha := 0.1887494014766075;
   c1[1] := 0.3718070668941645;
   c2[1,1] := 0.1376151928386445;
   c2[1,2] := 0.7364290859445481;
   c2[2,1] := 0.1357438914390695;
   c2[2,2] := 0.7150167318935022;
   c2[3,1] := 0.1326398453462415;
   c2[3,2] := 0.6798001808470175;
   c2[4,1] := 0.1283231214897678;
   c2[4,2] := 0.6314663440439816;
   c2[5,1] := 0.1228169159777534;
   c2[5,2] := 0.5709353626166905;
   c2[6,1] := 0.1161406100773184;
   c2[6,2] := 0.4993087153571335;
   c2[7,1] := 0.1082959649233524;
   c2[7,2] := 0.4177766148584385;
   c2[8,1] := 0.09923596957485722;
   c2[8,2] := 0.3274257287232124;
   c2[9,1] := 0.08877776108724852;
   c2[9,2] := 0.2287218166767916;
   c2[10,1] := 0.07624076527736326;
   c2[10,2] := 0.1193423971506988;
  elseif order == 22 then
   alpha := 0.1842668221199706;
   c2[1,1] := 0.1323053462701543;
   c2[1,2] := 0.7262446126765204;
   c2[2,1] := 0.1312121721769772;
   c2[2,2] := 0.7134286088450948;
   c2[3,1] := 0.1290330911166814;
   c2[3,2] := 0.6880287870435514;
   c2[4,1] := 0.1257817990372067;
   c2[4,2] := 0.6505015800059301;
   c2[5,1] := 0.1214765261983008;
   c2[5,2] := 0.6015107185211451;
   c2[6,1] := 0.1161365140967959;
   c2[6,2] := 0.5418983553698413;
   c2[7,1] := 0.10977551715331;
   c2[7,2] := 0.4726370779831614;
   c2[8,1] := 0.1023889478519956;
   c2[8,2] := 0.3947439506537486;
   c2[9,1] := 0.093924858612538;
   c2[9,2] := 0.3090996703083202;
   c2[10,1] := 0.08420273775456455;
   c2[10,2] := 0.2159561978556017;
   c2[11,1] := 0.07257600023938263;
   c2[11,2] := 0.1128633732721116;
  elseif order == 23 then
   alpha := 0.1800893554453722;
   c1[1] := 0.356523267392928;
   c2[1,1] := 0.1266275171652706;
   c2[1,2] := 0.7072778066734162;
   c2[2,1] := 0.1251865227648538;
   c2[2,2] := 0.6900676345785905;
   c2[3,1] := 0.1227944815236645;
   c2[3,2] := 0.6617011100576023;
   c2[4,1] := 0.1194647013077667;
   c2[4,2] := 0.6226432315773119;
   c2[5,1] := 0.1152132989252356;
   c2[5,2] := 0.5735222810625359;
   c2[6,1] := 0.1100558598478487;
   c2[6,2] := 0.5151027978024605;
   c2[7,1] := 0.1040013558214886;
   c2[7,2] := 0.4482410942032739;
   c2[8,1] := 0.09704014176512626;
   c2[8,2] := 0.3738049984631116;
   c2[9,1] := 0.08911683905758054;
   c2[9,2] := 0.292502869258841;
   c2[10,1] := 0.08005438265072296;
   c2[10,2] := 0.2044134600278901;
   c2[11,1] := 0.06923832296800832;
   c2[11,2] := 0.1069984887283394;
  elseif order == 24 then
   alpha := 0.1761838665838427;
   c2[1,1] := 0.1220804912720132;
   c2[1,2] := 0.6978026874156062;
   c2[2,1] := 0.1212296762358897;
   c2[2,2] := 0.6874139794926736;
   c2[3,1] := 0.1195328372961027;
   c2[3,2] := 0.6667954259551859;
   c2[4,1] := 0.1169990987333593;
   c2[4,2] := 0.6362602049901176;
   c2[5,1] := 0.113640904048013;
   c2[5,2] := 0.5962662188435554;
   c2[6,1] := 0.1094722001757955;
   c2[6,2] := 0.5474001634109253;
   c2[7,1] := 0.1045052832229087;
   c2[7,2] := 0.4903523180249535;
   c2[8,1] := 0.09874509806025906;
   c2[8,2] := 0.4258751523524645;
   c2[9,1] := 0.09217799943472177;
   c2[9,2] := 0.3547079765396403;
   c2[10,1] := 0.08474633796250476;
   c2[10,2] := 0.2774145482392767;
   c2[11,1] := 0.07627722381240495;
   c2[11,2] := 0.1939329108084139;
   c2[12,1] := 0.06618645465422746;
   c2[12,2] := 0.1016670147947242;
  elseif order == 25 then
   alpha := 0.1725220521949266;
   c1[1] := 0.3429735385896;
   c2[1,1] := 0.1172525033170618;
   c2[1,2] := 0.6812327932576614;
   c2[2,1] := 0.1161194585333535;
   c2[2,2] := 0.6671566071153211;
   c2[3,1] := 0.1142375145794466;
   c2[3,2] := 0.6439167855053158;
   c2[4,1] := 0.1116157454252308;
   c2[4,2] := 0.6118378416180135;
   c2[5,1] := 0.1082654809459177;
   c2[5,2] := 0.5713609763370088;
   c2[6,1] := 0.1041985674230918;
   c2[6,2] := 0.5230289949762722;
   c2[7,1] := 0.09942439308123559;
   c2[7,2] := 0.4674627926041906;
   c2[8,1] := 0.09394453593830893;
   c2[8,2] := 0.4053226688298811;
   c2[9,1] := 0.08774221237222533;
   c2[9,2] := 0.3372372276379071;
   c2[10,1] := 0.08075839512216483;
   c2[10,2] := 0.2636485508005428;
   c2[11,1] := 0.07282483286646764;
   c2[11,2] := 0.1843801345273085;
   c2[12,1] := 0.06338571166846652;
   c2[12,2] := 0.09680153764737714;
  elseif order == 26 then
   alpha := 0.1690795702796737;
   c2[1,1] := 0.113316869579603;
   c2[1,2] := 0.6724297955493932;
   c2[2,1] := 0.1126417845769961;
   c2[2,2] := 0.663870951979054;
   c2[3,1] := 0.1112948749545606;
   c2[3,2] := 0.6468652038763624;
   c2[4,1] := 0.1092823986944244;
   c2[4,2] := 0.6216337070799265;
   c2[5,1] := 0.1066130386697976;
   c2[5,2] := 0.588501141399219;
   c2[6,1] := 0.1032969057045413;
   c2[6,2] := 0.5478864278297548;
   c2[7,1] := 0.09934388184210716;
   c2[7,2] := 0.5002885306054287;
   c2[8,1] := 0.09476081523436283;
   c2[8,2] := 0.4462644847551711;
   c2[9,1] := 0.08954648464575576;
   c2[9,2] := 0.3863930785049522;
   c2[10,1] := 0.08368166847159916;
   c2[10,2] := 0.3212074592527143;
   c2[11,1] := 0.07710664731701103;
   c2[11,2] := 0.2510470347119383;
   c2[12,1] := 0.06965807988411425;
   c2[12,2] := 0.1756419294111342;
   c2[13,1] := 0.06080674930548766;
   c2[13,2] := 0.09234535279274277;
  elseif order == 27 then
   alpha := 0.1658353543067995;
   c1[1] := 0.3308543720638957;
   c2[1,1] := 0.1091618578712746;
   c2[1,2] := 0.6577977071169651;
   c2[2,1] := 0.1082549561495043;
   c2[2,2] := 0.6461121666520275;
   c2[3,1] := 0.1067479247890451;
   c2[3,2] := 0.6267937760991321;
   c2[4,1] := 0.1046471079537577;
   c2[4,2] := 0.6000750116745808;
   c2[5,1] := 0.1019605976654259;
   c2[5,2] := 0.566273418304932;
   c2[6,1] := 0.0986972695443371;
   c2[6,2] := 0.5257827234948534;
   c2[7,1] := 0.09486520934132484;
   c2[7,2] := 0.4790595019077763;
   c2[8,1] := 0.09046906518775348;
   c2[8,2] := 0.4266025862147336;
   c2[9,1] := 0.08550529998276152;
   c2[9,2] := 0.3689188223512328;
   c2[10,1] := 0.0799528223930602;
   c2[10,2] := 0.3064589322702932;
   c2[11,1] := 0.07375174596252881;
   c2[11,2] := 0.239475450466731;
   c2[12,1] := 0.06674377263329041;
   c2[12,2] := 0.1676223546666024;
   c2[13,1] := 0.05842458027529246;
   c2[13,2] := 0.08825044329219431;
  elseif order == 28 then
   alpha := 0.1627710671942929;
   c2[1,1] := 0.1057232656113488;
   c2[1,2] := 0.6496161226860832;
   c2[2,1] := 0.1051786825724864;
   c2[2,2] := 0.6424661279909941;
   c2[3,1] := 0.1040917964935006;
   c2[3,2] := 0.6282470268918791;
   c2[4,1] := 0.1024670101953951;
   c2[4,2] := 0.6071189030701136;
   c2[5,1] := 0.1003105109519892;
   c2[5,2] := 0.5793175191747016;
   c2[6,1] := 0.09762969425430802;
   c2[6,2] := 0.5451486608855443;
   c2[7,1] := 0.094432238030584;
   c2[7,2] := 0.5049796971628137;
   c2[8,1] := 0.09072460982036488;
   c2[8,2] := 0.4592270546572523;
   c2[9,1] := 0.0865095642325328;
   c2[9,2] := 0.4083368605952977;
   c2[10,1] := 0.08178165740374893;
   c2[10,2] := 0.3527525188880655;
   c2[11,1] := 0.0765183888586802;
   c2[11,2] := 0.2928534570013572;
   c2[12,1] := 0.0706601053244749;
   c2[12,2] := 0.2288185204390681;
   c2[13,1] := 0.0640535859614579;
   c2[13,2] := 0.160239617258819;
   c2[14,1] := 0.05621780070227172;
   c2[14,2] := 0.08447589564915071;
  elseif order == 29 then
   alpha := 0.1598706626277596;
   c1[1] := 0.3199314513011623;
   c2[1,1] := 0.1021101032532951;
   c2[1,2] := 0.6365758882240111;
   c2[2,1] := 0.1013729819392774;
   c2[2,2] := 0.6267495975736321;
   c2[3,1] := 0.1001476175660628;
   c2[3,2] := 0.6104876178266819;
   c2[4,1] := 0.09843854640428316;
   c2[4,2] := 0.5879603139195113;
   c2[5,1] := 0.09625164534591696;
   c2[5,2] := 0.559401229105021;
   c2[6,1] := 0.09359356960417668;
   c2[6,2] := 0.5251016150410664;
   c2[7,1] := 0.09047086748649986;
   c2[7,2] := 0.4854024475590397;
   c2[8,1] := 0.08688856407189167;
   c2[8,2] := 0.4406826457109709;
   c2[9,1] := 0.08284779224069856;
   c2[9,2] := 0.3913408089298914;
   c2[10,1] := 0.07834154620997182;
   c2[10,2] := 0.3377643999400627;
   c2[11,1] := 0.07334628941928766;
   c2[11,2] := 0.2802710651919946;
   c2[12,1] := 0.06780290487362146;
   c2[12,2] := 0.2189770008083379;
   c2[13,1] := 0.06156321231528423;
   c2[13,2] := 0.153423599930607;
   c2[14,1] := 0.05416797446761512;
   c2[14,2] := 0.08098664736760292;
  elseif order == 30 then
   alpha := 0.157120029625245;
   c2[1,1] := 0.09908074847842124;
   c2[1,2] := 0.6289618807831557;
   c2[2,1] := 0.09863509708328196;
   c2[2,2] := 0.6229164525571278;
   c2[3,1] := 0.09774542692037148;
   c2[3,2] := 0.6108853364240036;
   c2[4,1] := 0.09641490581986484;
   c2[4,2] := 0.5929869253412513;
   c2[5,1] := 0.09464802912225441;
   c2[5,2] := 0.569396017554755;
   c2[6,1] := 0.09245027206218041;
   c2[6,2] := 0.5403402396359503;
   c2[7,1] := 0.08982754584112941;
   c2[7,2] := 0.5060948065875106;
   c2[8,1] := 0.08678535291732599;
   c2[8,2] := 0.4669749797983789;
   c2[9,1] := 0.083327442420522;
   c2[9,2] := 0.4233249626334694;
   c2[10,1] := 0.07945356393775309;
   c2[10,2] := 0.3755006094498054;
   c2[11,1] := 0.07515543969833788;
   c2[11,2] := 0.32384003392927;
   c2[12,1] := 0.07040879901685639;
   c2[12,2] := 0.2686072427439079;
   c2[13,1] := 0.0651552885401054;
   c2[13,2] := 0.2098650589782619;
   c2[14,1] := 0.05925168237177876;
   c2[14,2] := 0.1471138832654873;
   c2[15,1] := 0.05225913954211672;
   c2[15,2] := 0.07775248839507864;
  elseif order == 31 then
   alpha := 0.1545067022920929;
   c1[1] := 0.3100206996451866;
   c2[1,1] := 0.09591020358831669;
   c2[1,2] := 0.6172474793293397;
   c2[2,1] := 0.09530301275601202;
   c2[2,2] := 0.6088916323460413;
   c2[3,1] := 0.09429332655402368;
   c2[3,2] := 0.5950511595503025;
   c2[4,1] := 0.09288445429894548;
   c2[4,2] := 0.5758534119053522;
   c2[5,1] := 0.09108073420087422;
   c2[5,2] := 0.5514734636081183;
   c2[6,1] := 0.0888871913753687;
   c2[6,2] := 0.5221306199481831;
   c2[7,1] := 0.0863090144023965;
   c2[7,2] := 0.4880834248148061;
   c2[8,1] := 0.08335074993373294;
   c2[8,2] := 0.449622535849677;
   c2[9,1] := 0.08001502494376102;
   c2[9,2] := 0.4070602306679052;
   c2[10,1] := 0.07630041338037624;
   c2[10,2] := 0.3607139804818122;
   c2[11,1] := 0.0721976088574492;
   c2[11,2] := 0.310878330122955;
   c2[12,1] := 0.06768185077153345;
   c2[12,2] := 0.2577706252514497;
   c2[13,1] := 0.06269571766328638;
   c2[13,2] := 0.2014081375889921;
   c2[14,1] := 0.05710081766945065;
   c2[14,2] := 0.1412581515841926;
   c2[15,1] := 0.05047740914807019;
   c2[15,2] := 0.07474725873250158;
  elseif order == 32 then
   alpha := 0.152019621084821;
   c2[1,1] := 0.09322163554339406;
   c2[1,2] := 0.610148869050605;
   c2[2,1] := 0.09285233997694042;
   c2[2,2] := 0.6049832320721265;
   c2[3,1] := 0.09211494244473163;
   c2[3,2] := 0.5946969295569035;
   c2[4,1] := 0.09101176786042449;
   c2[4,2] := 0.5793791854364477;
   c2[5,1] := 0.08954614071360517;
   c2[5,2] := 0.5591619969234026;
   c2[6,1] := 0.08772216763680164;
   c2[6,2] := 0.5342177994699602;
   c2[7,1] := 0.08554440426912734;
   c2[7,2] := 0.5047560942986598;
   c2[8,1] := 0.08301735302045588;
   c2[8,2] := 0.4710187048140929;
   c2[9,1] := 0.08014469519188161;
   c2[9,2] := 0.4332730387207936;
   c2[10,1] := 0.07692807528893225;
   c2[10,2] := 0.3918021436411035;
   c2[11,1] := 0.07336507157284898;
   c2[11,2] := 0.346889052147125;
   c2[12,1] := 0.06944555312763458;
   c2[12,2] := 0.298789802905046;
   c2[13,1] := 0.0651444666942057;
   c2[13,2] := 0.2476810747407199;
   c2[14,1] := 0.06040544477732702;
   c2[14,2] := 0.1935412053397663;
   c2[15,1] := 0.05509478650672775;
   c2[15,2] := 0.1358108994174911;
   c2[16,1] := 0.04881064725720192;
   c2[16,2] := 0.07194819894416506;
  elseif order == 33 then
   alpha := 0.1496489351138032;
   c1[1] := 0.3009752799176432;
   c2[1,1] := 0.09041725460994506;
   c2[1,2] := 0.5995521047364046;
   c2[2,1] := 0.08991117804113002;
   c2[2,2] := 0.5923764112099495;
   c2[3,1] := 0.08906941547422532;
   c2[3,2] := 0.5804822013853129;
   c2[4,1] := 0.08789442491445575;
   c2[4,2] := 0.5639663528946501;
   c2[5,1] := 0.08638945831033774;
   c2[5,2] := 0.5429623519607796;
   c2[6,1] := 0.08455834602616358;
   c2[6,2] := 0.5176379938389326;
   c2[7,1] := 0.08240517431382334;
   c2[7,2] := 0.4881921474066189;
   c2[8,1] := 0.07993380417355075;
   c2[8,2] := 0.4548502528082586;
   c2[9,1] := 0.07714713890732801;
   c2[9,2] := 0.4178579388038483;
   c2[10,1] := 0.07404596598181128;
   c2[10,2] := 0.3774715722484659;
   c2[11,1] := 0.07062702339160462;
   c2[11,2] := 0.3339432938810453;
   c2[12,1] := 0.06687952672391508;
   c2[12,2] := 0.2874950693388235;
   c2[13,1] := 0.06277828912909766;
   c2[13,2] := 0.2382680702894708;
   c2[14,1] := 0.05826808305383988;
   c2[14,2] := 0.1862073169968455;
   c2[15,1] := 0.05321974125363517;
   c2[15,2] := 0.1307323751236313;
   c2[16,1] := 0.0472482028203278;
   c2[16,2] := 0.06933542082177094;
  elseif order == 34 then
   alpha := 0.1473858373968463;
   c2[1,1] := 0.08801537152275983;
   c2[1,2] := 0.5929204288972172;
   c2[2,1] := 0.08770594341007476;
   c2[2,2] := 0.5884653382247518;
   c2[3,1] := 0.08708797598072095;
   c2[3,2] := 0.5795895850253119;
   c2[4,1] := 0.08616320590689187;
   c2[4,2] := 0.566361538364717;
   c2[5,1] := 0.08493413175570858;
   c2[5,2] := 0.5488825092350877;
   c2[6,1] := 0.08340387368687513;
   c2[6,2] := 0.5272851839324592;
   c2[7,1] := 0.08157596213131521;
   c2[7,2] := 0.5017313864372913;
   c2[8,1] := 0.0794540267083427;
   c2[8,2] := 0.4724089864574216;
   c2[9,1] := 0.0770413355955643;
   c2[9,2] := 0.4395276256463053;
   c2[10,1] := 0.07434009635219704;
   c2[10,2] := 0.4033126590648964;
   c2[11,1] := 0.07135035113853376;
   c2[11,2] := 0.3639961488919042;
   c2[12,1] := 0.06806813160738834;
   c2[12,2] := 0.3218025212900124;
   c2[13,1] := 0.06448214312000863;
   c2[13,2] := 0.2769235521088158;
   c2[14,1] := 0.0605671931843053;
   c2[14,2] := 0.2294693573271038;
   c2[15,1] := 0.0562692519692504;
   c2[15,2] := 0.1793564218840015;
   c2[16,1] := 0.05146352031547277;
   c2[16,2] := 0.1259877129326412;
   c2[17,1] := 0.04578069074410591;
   c2[17,2] := 0.06689147319568768;
  elseif order == 35 then
   alpha := 0.1452224267615486;
   c1[1] := 0.2926764667564367;
   c2[1,1] := 0.0855173129926728;
   c2[1,2] := 0.5832758214629523;
   c2[2,1] := 0.0850910973285306;
   c2[2,2] := 0.5770596582643844;
   c2[3,1] := 0.08438201446671953;
   c2[3,2] := 0.5667497616665494;
   c2[4,1] := 0.08339191981579831;
   c2[4,2] := 0.5524209816238369;
   c2[5,1] := 0.08212328610083384;
   c2[5,2] := 0.5341766459916322;
   c2[6,1] := 0.08057906332198853;
   c2[6,2] := 0.512147005351275;
   c2[7,1] := 0.07876247299954955;
   c2[7,2] := 0.4864870722254752;
   c2[8,1] := 0.07667670879950268;
   c2[8,2] := 0.4573736721705665;
   c2[9,1] := 0.07432449556218945;
   c2[9,2] := 0.4250013835198991;
   c2[10,1] := 0.07170742126011576;
   c2[10,2] := 0.3895767735915445;
   c2[11,1] := 0.06882488171701313;
   c2[11,2] := 0.3513097926737368;
   c2[12,1] := 0.06567231746957568;
   c2[12,2] := 0.3103999917596611;
   c2[13,1] := 0.06223804362223595;
   c2[13,2] := 0.2670123611280899;
   c2[14,1] := 0.0584969646078291;
   c2[14,2] := 0.2212298104867592;
   c2[15,1] := 0.05439628409499822;
   c2[15,2] := 0.1729443731341637;
   c2[16,1] := 0.0498154017913692;
   c2[16,2] := 0.121546215713493;
   c2[17,1] := 0.04439981033536435;
   c2[17,2] := 0.06460098363520966;
  elseif order == 36 then
   alpha := 0.143151591445858;
   c2[1,1] := 0.08335881847130301;
   c2[1,2] := 0.5770670512160201;
   c2[2,1] := 0.08309698922852211;
   c2[2,2] := 0.5731929100172432;
   c2[3,1] := 0.08257400347039723;
   c2[3,2] := 0.5654713811993058;
   c2[4,1] := 0.08179117911600137;
   c2[4,2] := 0.553955634360302;
   c2[5,1] := 0.08075042173126963;
   c2[5,2] := 0.5387245649546684;
   c2[6,1] := 0.07945413151258206;
   c2[6,2] := 0.5198817177723069;
   c2[7,1] := 0.07790506514288865;
   c2[7,2] := 0.4975537629595409;
   c2[8,1] := 0.0761061363533948;
   c2[8,2] := 0.4718884193866789;
   c2[9,1] := 0.07406012816626426;
   c2[9,2] := 0.4430516443136726;
   c2[10,1] := 0.0717692706020563;
   c2[10,2] := 0.4112237708115829;
   c2[11,1] := 0.0692346017250425;
   c2[11,2] := 0.376594011638973;
   c2[12,1] := 0.06645495833489556;
   c2[12,2] := 0.3393522147815403;
   c2[13,1] := 0.06342528888937093;
   c2[13,2] := 0.2996755899575573;
   c2[14,1] := 0.06013361864949449;
   c2[14,2] := 0.257705329405383;
   c2[15,1] := 0.05655503081322404;
   c2[15,2] := 0.2135004731531631;
   c2[16,1] := 0.05263798119559069;
   c2[16,2] := 0.1669320999865636;
   c2[17,1] := 0.04826589873626196;
   c2[17,2] := 0.1173807590715484;
   c2[18,1] := 0.04309819397289806;
   c2[18,2] := 0.06245036108880222;
  elseif order == 37 then
   alpha := 0.1411669104782917;
   c1[1] := 0.2850271036215707;
   c2[1,1] := 0.08111958235023328;
   c2[1,2] := 0.568241261056397;
   c2[2,1] := 0.08075727567979578;
   c2[2,2] := 0.5628142923227016;
   c2[3,1] := 0.08015440554413301;
   c2[3,2] := 0.553808769687993;
   c2[4,1] := 0.07931239302677386;
   c2[4,2] := 0.541283332330446;
   c2[5,1] := 0.07823314328639347;
   c2[5,2] := 0.5253190555393968;
   c2[6,1] := 0.07691895211595101;
   c2[6,2] := 0.5060183741977191;
   c2[7,1] := 0.07537237072011853;
   c2[7,2] := 0.4835036020049034;
   c2[8,1] := 0.07359601294804538;
   c2[8,2] := 0.4579149413954837;
   c2[9,1] := 0.071592278848493;
   c2[9,2] := 0.4294078049978829;
   c2[10,1] := 0.06936295002846032;
   c2[10,2] := 0.3981491350382047;
   c2[11,1] := 0.06690857785828917;
   c2[11,2] := 0.3643121502867948;
   c2[12,1] := 0.06422751692085542;
   c2[12,2] := 0.3280684291406284;
   c2[13,1] := 0.06131430866206096;
   c2[13,2] := 0.2895750997170303;
   c2[14,1] := 0.0581567724957092;
   c2[14,2] := 0.248952181480572;
   c2[15,1] := 0.0547302352794798;
   c2[15,2] := 0.2062377435955363;
   c2[16,1] := 0.05098441033167034;
   c2[16,2] := 0.1612849131645336;
   c2[17,1] := 0.04680658811093562;
   c2[17,2] := 0.1134672937045305;
   c2[18,1] := 0.04186928031694695;
   c2[18,2] := 0.06042754777339966;
  elseif order == 38 then
   alpha := 0.139262569714003;
   c2[1,1] := 0.07916943373658329;
   c2[1,2] := 0.5624158631591745;
   c2[2,1] := 0.0789459225025784;
   c2[2,2] := 0.5590219398777304;
   c2[3,1] := 0.0784994167238493;
   c2[3,2] := 0.5522551628416841;
   c2[4,1] := 0.07783093084875645;
   c2[4,2] := 0.542157432580838;
   c2[5,1] := 0.0769419377048269;
   c2[5,2] := 0.5287909941093643;
   c2[6,1] := 0.07583430534712884;
   c2[6,2] := 0.512237681402988;
   c2[7,1] := 0.07451020436122947;
   c2[7,2] := 0.4925978555548549;
   c2[8,1] := 0.07297197617673508;
   c2[8,2] := 0.4699889739625235;
   c2[9,1] := 0.07122194706992953;
   c2[9,2] := 0.4445436860615774;
   c2[10,1] := 0.06926216260386817;
   c2[10,2] := 0.4164072786327193;
   c2[11,1] := 0.06709399961255504;
   c2[11,2] := 0.3857341621868851;
   c2[12,1] := 0.06471757977022456;
   c2[12,2] := 0.3526828388476838;
   c2[13,1] := 0.06213084287116965;
   c2[13,2] := 0.3174082831364342;
   c2[14,1] := 0.05932799638550641;
   c2[14,2] := 0.2800495563550299;
   c2[15,1] := 0.05629672408524944;
   c2[15,2] := 0.2407078154782509;
   c2[16,1] := 0.05301264751544952;
   c2[16,2] := 0.1994026830553859;
   c2[17,1] := 0.04942673259817896;
   c2[17,2] := 0.1559719194038917;
   c2[18,1] := 0.04542996716979947;
   c2[18,2] := 0.109784427787847;
   c2[19,1] := 0.04070720755433961;
   c2[19,2] := 0.05852181110523043;
  elseif order == 39 then
   alpha := 0.1374332900196804;
   c1[1] := 0.2779468246419593;
   c2[1,1] := 0.07715084161825772;
   c2[1,2] := 0.5543001331300056;
   c2[2,1] := 0.07684028301163326;
   c2[2,2] := 0.5495289890712267;
   c2[3,1] := 0.07632343924866024;
   c2[3,2] := 0.5416083298429741;
   c2[4,1] := 0.07560141319808483;
   c2[4,2] := 0.5305846713929198;
   c2[5,1] := 0.07467569064745969;
   c2[5,2] := 0.5165224112570647;
   c2[6,1] := 0.07354807648551347;
   c2[6,2] := 0.4995030679271456;
   c2[7,1] := 0.07222060351121388;
   c2[7,2] := 0.4796242430956156;
   c2[8,1] := 0.07069540462458584;
   c2[8,2] := 0.4569982440368368;
   c2[9,1] := 0.0689745335349238;
   c2[9,2] := 0.4317502624832354;
   c2[10,1] := 0.06705970959388781;
   c2[10,2] := 0.4040159353969854;
   c2[11,1] := 0.06495194541066725;
   c2[11,2] := 0.3739379843169939;
   c2[12,1] := 0.0626509841241761;
   c2[12,2] := 0.3416613843816217;
   c2[13,1] := 0.0601544098495593;
   c2[13,2] := 0.3073260166338746;
   c2[14,1] := 0.05745615876877304;
   c2[14,2] := 0.2710546723961181;
   c2[15,1] := 0.05454383762391338;
   c2[15,2] := 0.232931682406117;
   c2[16,1] := 0.05139340231935751;
   c2[16,2] := 0.1929604256043231;
   c2[17,1] := 0.04795705862458131;
   c2[17,2] := 0.1509655259246037;
   c2[18,1] := 0.04412933231935506;
   c2[18,2] := 0.1063130748962878;
   c2[19,1] := 0.03960672309405603;
   c2[19,2] := 0.05672356837211527;
  elseif order == 40 then
   alpha := 0.1356742655825434;
   c2[1,1] := 0.07538038374294594;
   c2[1,2] := 0.5488228264329617;
   c2[2,1] := 0.07518806529402738;
   c2[2,2] := 0.5458297722483311;
   c2[3,1] := 0.07480383050347118;
   c2[3,2] := 0.539860457673054;
   c2[4,1] := 0.07422847031965465;
   c2[4,2] := 0.5309482987446206;
   c2[5,1] := 0.07346313704205006;
   c2[5,2] := 0.5191429845322307;
   c2[6,1] := 0.07250930053201401;
   c2[6,2] := 0.5045099368431007;
   c2[7,1] := 0.0713686845687962;
   c2[7,2] := 0.4871295553902607;
   c2[8,1] := 0.07004317764946634;
   c2[8,2] := 0.4670962098860498;
   c2[9,1] := 0.06853470921527828;
   c2[9,2] := 0.4445169164956202;
   c2[10,1] := 0.06684507689945471;
   c2[10,2] := 0.4195095960479698;
   c2[11,1] := 0.0649757012341263;
   c2[11,2] := 0.3922007419030645;
   c2[12,1] := 0.06292726794917847;
   c2[12,2] := 0.3627221993494397;
   c2[13,1] := 0.06069918741663154;
   c2[13,2] := 0.3312065181294388;
   c2[14,1] := 0.0582887398376941;
   c2[14,2] := 0.2977798532686911;
   c2[15,1] := 0.05568964389813015;
   c2[15,2] := 0.2625503293999835;
   c2[16,1] := 0.05288947816690705;
   c2[16,2] := 0.2255872486520188;
   c2[17,1] := 0.04986456327645859;
   c2[17,2] := 0.1868796731919594;
   c2[18,1] := 0.04656832613054458;
   c2[18,2] := 0.1462410193532463;
   c2[19,1] := 0.04289867647614935;
   c2[19,2] := 0.1030361558710747;
   c2[20,1] := 0.03856310684054106;
   c2[20,2] := 0.05502423832293889;
  elseif order == 41 then
   alpha := 0.1339811106984253;
   c1[1] := 0.2713685065531391;
   c2[1,1] := 0.07355140275160985;
   c2[1,2] := 0.541327477828286;
   c2[2,1] := 0.07328319082267173;
   c2[2,2] := 0.537106408829427;
   c2[3,1] := 0.07283676160772547;
   c2[3,2] := 0.530096343727077;
   c2[4,1] := 0.07221298133014344;
   c2[4,2] := 0.520334599837149;
   c2[5,1] := 0.07141302173623396;
   c2[5,2] := 0.5078728971879841;
   c2[6,1] := 0.07043831559982149;
   c2[6,2] := 0.4927768111819803;
   c2[7,1] := 0.06929049381827268;
   c2[7,2] := 0.4751250308594139;
   c2[8,1] := 0.06797129849758392;
   c2[8,2] := 0.4550083840638406;
   c2[9,1] := 0.06648246325101609;
   c2[9,2] := 0.4325285673076087;
   c2[10,1] := 0.06482554675958525;
   c2[10,2] := 0.4077964789091151;
   c2[11,1] := 0.06300169683004558;
   c2[11,2] := 0.3809299858742483;
   c2[12,1] := 0.06101130648543355;
   c2[12,2] := 0.3520508315700898;
   c2[13,1] := 0.05885349417435808;
   c2[13,2] := 0.3212801560701271;
   c2[14,1] := 0.05652528148656809;
   c2[14,2] := 0.2887316252774887;
   c2[15,1] := 0.05402021575818373;
   c2[15,2] := 0.2545001287790888;
   c2[16,1] := 0.05132588802608274;
   c2[16,2] := 0.2186415296842951;
   c2[17,1] := 0.04841900639702602;
   c2[17,2] := 0.181132262229606;
   c2[18,1] := 0.04525419574485134;
   c2[18,2] := 0.1417762065404688;
   c2[19,1] := 0.04173260173087802;
   c2[19,2] := 0.0999383453096651;
   c2[20,1] := 0.03757210572966463;
   c2[20,2] := 0.05341611499960143;
  else
   Modelica.Utilities.Streams.error("Input argument order (= " + String(order) + ") of Bessel filter is not in the range 1..41");
  end if;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.Utilities.BesselBaseCoefficients;

 function Modelica.Blocks.Continuous.Internal.Filter.base.Butterworth
  input Integer order;
  input Boolean normalized;
  output Real[:] cr;
  output Real[:] c0;
  output Real[:] c1;
  Real alpha;
  Real alpha2;
  Real[:] den1;
  Real[:,:] den2;
 algorithm
  init cr as Real[order - integer(order / 2) * 2];
  init c0 as Real[integer(order / 2)];
  init c1 as Real[integer(order / 2)];
  alpha := 1.0;
  init den1 as Real[size(cr, 1)];
  init den2 as Real[size(c0, 1), 2];
  for i in 1:size(c0, 1) loop
   den2[i,1] := 1.0;
   den2[i,2] := -2 * cos(3.141592653589793 * (0.5 + (i - 0.5) / order));
  end for;
  if size(cr, 1) == 1 then
   den1[1] := 1.0;
  end if;
  (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.base.Butterworth;

 function Modelica.Blocks.Continuous.Internal.Filter.base.ChebyshevI
  input Integer order;
  input Real A_ripple;
  input Boolean normalized;
  output Real[:] cr;
  output Real[:] c0;
  output Real[:] c1;
  Real epsilon;
  Real fac;
  Real alpha;
  Real alpha2;
  Real[:] den1;
  Real[:,:] den2;
 algorithm
  init cr as Real[order - integer(order / 2) * 2];
  init c0 as Real[integer(order / 2)];
  init c1 as Real[integer(order / 2)];
  alpha := 1.0;
  init den1 as Real[size(cr, 1)];
  init den2 as Real[size(c0, 1), 2];
  epsilon := sqrt(10 ^ (A_ripple / 10) - 1);
  fac := Modelica.Math.asinh(1 / epsilon) / order;
  den1[:] := fill(1 / sinh(fac), size(den1, 1));
  if size(cr, 1) == 0 then
   for i in 1:size(c0, 1) loop
    den2[i,1] := 1 / (cosh(fac) ^ 2 - cos((2 * i - 1) * 3.141592653589793 / (2 * order)) ^ 2);
    den2[i,2] := 2 * den2[i,1] * sinh(fac) * cos((2 * i - 1) * 3.141592653589793 / (2 * order));
   end for;
  else
   for i in 1:size(c0, 1) loop
    den2[i,1] := 1 / (cosh(fac) ^ 2 - cos(i * 3.141592653589793 / order) ^ 2);
    den2[i,2] := 2 * den2[i,1] * sinh(fac) * cos(i * 3.141592653589793 / order);
   end for;
  end if;
  if normalized then
   alpha := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor(den1, den2);
   alpha2 := alpha * alpha;
   for i in 1:size(c0, 1) loop
    den2[i,1] := den2[i,1] * alpha2;
    den2[i,2] := den2[i,2] * alpha;
   end for;
   den1[:] := den1[:] * alpha;
  end if;
  (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.base.ChebyshevI;

 function Modelica.Math.asinh
  input Real u;
  output Real y;
 algorithm
  y := log(u + sqrt(u * u + 1));
  return;
 end Modelica.Math.asinh;

 function Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor
  input Real[:] c1;
  input Real[:,:] c2;
  output Real alpha;
  Real alpha_min;
  Real alpha_max;
 algorithm
  assert(2 == size(c2, 2), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor', component 'c2', dimension '2'");
  (alpha_min, alpha_max) := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.findInterval(c1, c2);
  alpha := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.solveOneNonlinearEquation(c1, c2, alpha_min, alpha_max, 100 * 1.0E-15);
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor;

 function Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.findInterval
  input Real[:] c1;
  input Real[:,:] c2;
  output Real alpha_min;
  output Real alpha_max;
  Real alpha;
  Real residue;
 algorithm
  assert(2 == size(c2, 2), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.findInterval', component 'c2', dimension '2'");
  alpha := 1.0;
  alpha_min := 0;
  residue := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue(c1, c2, alpha);
  if residue < 0 then
   alpha_max := alpha;
  else
   while residue >= 0 loop
    alpha := 1.1 * alpha;
    residue := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue(c1, c2, alpha);
   end while;
   alpha_max := alpha;
  end if;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.findInterval;

 function Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue
  input Real[:] c1;
  input Real[:,:] c2;
  input Real alpha;
  output Real residue;
  Real cc1;
  Real cc2;
  Real p;
  Real alpha2;
  Real alpha4;
  Real A2;
 algorithm
  assert(2 == size(c2, 2), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue', component 'c2', dimension '2'");
  alpha2 := alpha * alpha;
  alpha4 := alpha2 * alpha2;
  A2 := 1.0;
  assert(size(c1, 1) <= 1, "Internal error 2 (should not occur)");
  if size(c1, 1) == 1 then
   cc1 := c1[1] * c1[1];
   p := 1 + cc1 * alpha2;
   A2 := A2 * p;
  end if;
  for i in 1:size(c2, 1) loop
   cc1 := c2[i,2] * c2[i,2] - 2 * c2[i,1];
   cc2 := c2[i,1] * c2[i,1];
   p := 1 + cc1 * alpha2 + cc2 * alpha4;
   A2 := A2 * p;
  end for;
  residue := 1 / sqrt(A2) - 0.7079457843841379;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue;

 function Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.solveOneNonlinearEquation
  input Real[:] c1;
  input Real[:,:] c2;
  input Real u_min;
  input Real u_max;
  input Real tolerance;
  output Real u;
  Real a;
  Real b;
  Real c;
  Real d;
  Real e;
  Real m;
  Real s;
  Real p;
  Real q;
  Real r;
  Real tol;
  Real fa;
  Real fb;
  Real fc;
  Boolean found;
 algorithm
  assert(2 == size(c2, 2), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.solveOneNonlinearEquation', component 'c2', dimension '2'");
  a := u_min;
  b := u_max;
  found := false;
  fa := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue(c1, c2, u_min);
  fb := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue(c1, c2, u_max);
  fc := fb;
  if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
   Modelica.Utilities.Streams.error("The arguments u_min and u_max to solveOneNonlinearEquation(..)\n" + "do not bracket the root of the single non-linear equation:\n" + "  u_min  = " + String(u_min) + "\n" + "  u_max  = " + String(u_max) + "\n" + "  fa = f(u_min) = " + String(fa) + "\n" + "  fb = f(u_max) = " + String(fb) + "\n" + "fa and fb must have opposite sign which is not the case");
  end if;
  c := a;
  fc := fa;
  e := b - a;
  d := e;
  while not found loop
   if abs(fc) < abs(fb) then
    a := b;
    b := c;
    c := a;
    fa := fb;
    fb := fc;
    fc := fa;
   end if;
   tol := 2 * 1.0E-15 * abs(b) + tolerance;
   m := (c - b) / 2;
   if abs(m) <= tol or fb == 0.0 then
    found := true;
    u := b;
   else
    if abs(e) < tol or abs(fa) <= abs(fb) then
     e := m;
     d := e;
    else
     s := fb / fa;
     if a == c then
      p := 2 * m * s;
      q := 1 - s;
     else
      q := fa / fc;
      r := fb / fc;
      p := s * (2 * m * q * (q - r) - (b - a) * (r - 1));
      q := (q - 1) * (r - 1) * (s - 1);
     end if;
     if p > 0 then
      q := - q;
     else
      p := - p;
     end if;
     s := e;
     e := d;
     if 2 * p < 3 * m * q - abs(tol * q) and p < abs(0.5 * s * q) then
      d := p / q;
     else
      e := m;
      d := e;
     end if;
    end if;
    a := b;
    fa := fb;
    b := b + (if abs(d) > tol then d elseif m > 0 then tol else - tol);
    fb := Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.normalizationResidue(c1, c2, b);
    if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
     c := a;
     fc := fa;
     e := b - a;
     d := e;
    end if;
   end if;
  end while;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor.solveOneNonlinearEquation;

 function Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass
  input Real[:] cr_in;
  input Real[:] c0_in;
  input Real[:] c1_in;
  input Real f_cut;
  output Real[:] r;
  output Real[:] a;
  output Real[:] b;
  output Real[:] ku;
  Real[:] c0;
  Real[:] c1;
  Real[:] cr;
 algorithm
  assert(size(c0_in, 1) == size(c1_in, 1), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass', component 'c1_in', dimension '1'");
  init r as Real[size(cr_in, 1)];
  init a as Real[size(c0_in, 1)];
  init b as Real[size(c0_in, 1)];
  init ku as Real[size(c0_in, 1)];
  init c0 as Real[size(c0_in, 1)];
  init c1 as Real[size(c0_in, 1)];
  init cr as Real[size(cr_in, 1)];
  (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass(cr_in, c0_in, c1_in, f_cut);
  for i in 1:size(cr_in, 1) loop
   r[i] := - cr[i];
  end for;
  for i in 1:size(c0_in, 1) loop
   a[i] := (- c1[i]) / 2;
   b[i] := sqrt(c0[i] - a[i] * a[i]);
   ku[i] := c0[i] / b[i];
  end for;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass;

 function Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass
  input Real[:] cr_in;
  input Real[:] c0_in;
  input Real[:] c1_in;
  input Real f_cut;
  output Real[:] cr;
  output Real[:] c0;
  output Real[:] c1;
  Real w_cut;
  Real w_cut2;
 algorithm
  assert(size(c0_in, 1) == size(c1_in, 1), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass', component 'c1_in', dimension '1'");
  init cr as Real[size(cr_in, 1)];
  init c0 as Real[size(c0_in, 1)];
  init c1 as Real[size(c0_in, 1)];
  w_cut := 2 * 3.141592653589793 * f_cut;
  w_cut2 := w_cut * w_cut;
  assert(f_cut > 0, "Cut-off frequency f_cut must be positive");
  cr[:] := w_cut * cr_in[:];
  c1[:] := w_cut * c1_in[:];
  c0[:] := w_cut2 * c0_in[:];
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass;

 function Modelica.Blocks.Continuous.Internal.Filter.roots.highPass
  input Real[:] cr_in;
  input Real[:] c0_in;
  input Real[:] c1_in;
  input Real f_cut;
  output Real[:] r;
  output Real[:] a;
  output Real[:] b;
  output Real[:] ku;
  output Real[:] k1;
  output Real[:] k2;
  Real[:] c0;
  Real[:] c1;
  Real[:] cr;
  Real ba2;
 algorithm
  assert(size(c0_in, 1) == size(c1_in, 1), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.roots.highPass', component 'c1_in', dimension '1'");
  init r as Real[size(cr_in, 1)];
  init a as Real[size(c0_in, 1)];
  init b as Real[size(c0_in, 1)];
  init ku as Real[size(c0_in, 1)];
  init k1 as Real[size(c0_in, 1)];
  init k2 as Real[size(c0_in, 1)];
  init c0 as Real[size(c0_in, 1)];
  init c1 as Real[size(c0_in, 1)];
  init cr as Real[size(cr_in, 1)];
  (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.coefficients.highPass(cr_in, c0_in, c1_in, f_cut);
  for i in 1:size(cr_in, 1) loop
   r[i] := - cr[i];
  end for;
  for i in 1:size(c0_in, 1) loop
   a[i] := (- c1[i]) / 2;
   b[i] := sqrt(c0[i] - a[i] * a[i]);
   ku[i] := c0[i] / b[i];
   k1[i] := 2 * a[i] / ku[i];
   ba2 := (b[i] / a[i]) ^ 2;
   k2[i] := (1 - ba2) / (1 + ba2);
  end for;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.roots.highPass;

 function Modelica.Blocks.Continuous.Internal.Filter.coefficients.highPass
  input Real[:] cr_in;
  input Real[:] c0_in;
  input Real[:] c1_in;
  input Real f_cut;
  output Real[:] cr;
  output Real[:] c0;
  output Real[:] c1;
  Real w_cut;
  Real w_cut2;
 algorithm
  assert(size(c0_in, 1) == size(c1_in, 1), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.coefficients.highPass', component 'c1_in', dimension '1'");
  init cr as Real[size(cr_in, 1)];
  init c0 as Real[size(c0_in, 1)];
  init c1 as Real[size(c0_in, 1)];
  w_cut := 2 * 3.141592653589793 * f_cut;
  w_cut2 := w_cut * w_cut;
  assert(f_cut > 0, "Cut-off frequency f_cut must be positive");
  for i in 1:size(cr_in, 1) loop
   cr[i] := w_cut / cr_in[i];
  end for;
  for i in 1:size(c0_in, 1) loop
   c0[i] := w_cut2 / c0_in[i];
   c1[i] := w_cut * c1_in[i] / c0_in[i];
  end for;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.coefficients.highPass;

 function Modelica.Blocks.Continuous.Internal.Filter.roots.bandPass
  input Real[:] cr_in;
  input Real[:] c0_in;
  input Real[:] c1_in;
  input Real f_min;
  input Real f_max;
  output Real[:] a;
  output Real[:] b;
  output Real[:] ku;
  output Real[:] k1;
  output Real[:] k2;
  Real[:] cr;
  Real[:] c0;
  Real[:] c1;
  Real cn;
  Real bb;
 algorithm
  assert(size(c0_in, 1) == size(c1_in, 1), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.roots.bandPass', component 'c1_in', dimension '1'");
  init a as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init b as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init ku as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init k1 as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init k2 as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init cr as Real[0];
  init c0 as Real[size(a, 1)];
  init c1 as Real[size(a, 1)];
  (cr, c0, c1, cn) := Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandPass(cr_in, c0_in, c1_in, f_min, f_max);
  for i in 1:size(a, 1) loop
   a[i] := (- c1[i]) / 2;
   bb := c0[i] - a[i] * a[i];
   assert(bb >= 0, "\nNot possible to use band pass filter, since transformation results in\n" + "system that does not have conjugate complex poles.\n" + "Try to use another analog filter for the band pass.\n");
   b[i] := sqrt(bb);
   ku[i] := c0[i] / b[i];
   k1[i] := cn / ku[i];
   k2[i] := cn * a[i] / (b[i] * ku[i]);
  end for;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.roots.bandPass;

 function Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandPass
  input Real[:] cr_in;
  input Real[:] c0_in;
  input Real[:] c1_in;
  input Real f_min;
  input Real f_max;
  output Real[:] cr;
  output Real[:] c0;
  output Real[:] c1;
  output Real cn;
  Real f0;
  Real w_cut;
  Real w_band;
  Real w_cut2;
  Real c;
  Real alpha;
  Integer j;
 algorithm
  assert(size(c0_in, 1) == size(c1_in, 1), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandPass', component 'c1_in', dimension '1'");
  init cr as Real[0];
  init c0 as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init c1 as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  f0 := sqrt(f_min * f_max);
  w_cut := 2 * 3.141592653589793 * f0;
  w_band := (f_max - f_min) / f0;
  w_cut2 := w_cut * w_cut;
  assert(f_min > 0 and f_min < f_max, "Band frequencies f_min and f_max are wrong");
  for i in 1:size(cr_in, 1) loop
   c1[i] := w_cut * cr_in[i] * w_band;
   c0[i] := w_cut2;
  end for;
  for i in 1:size(c1_in, 1) loop
   alpha := Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha(c1_in[i], c0_in[i], w_band);
   c := c1_in[i] * w_band / (alpha + 1 / alpha);
   j := size(cr_in, 1) + 2 * i - 1;
   c1[j] := w_cut * c / alpha;
   c1[j + 1] := w_cut * c * alpha;
   c0[j] := w_cut2 / alpha ^ 2;
   c0[j + 1] := w_cut2 * alpha ^ 2;
  end for;
  cn := w_band * w_cut;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandPass;

 function Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha
  input Real a;
  input Real b;
  input Real w;
  output Real alpha;
  Real alpha_min;
  Real alpha_max;
  Real z_min;
  Real z_max;
  Real z;
 algorithm
  assert(a ^ 2 / 4 - b <= 0, "Band pass transformation cannot be computed");
  z := Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha.solveOneNonlinearEquation(a, b, w, 0, 1, 100 * 1.0E-15);
  alpha := sqrt(z);
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha;

 function Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha.solveOneNonlinearEquation
  input Real aa;
  input Real bb;
  input Real ww;
  input Real u_min;
  input Real u_max;
  input Real tolerance;
  output Real u;
  Real a;
  Real b;
  Real c;
  Real d;
  Real e;
  Real m;
  Real s;
  Real p;
  Real q;
  Real r;
  Real tol;
  Real fa;
  Real fb;
  Real fc;
  Boolean found;
 algorithm
  a := u_min;
  b := u_max;
  found := false;
  fa := Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha.residue(aa, bb, ww, u_min);
  fb := Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha.residue(aa, bb, ww, u_max);
  fc := fb;
  if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
   Modelica.Utilities.Streams.error("The arguments u_min and u_max to solveOneNonlinearEquation(..)\n" + "do not bracket the root of the single non-linear equation:\n" + "  u_min  = " + String(u_min) + "\n" + "  u_max  = " + String(u_max) + "\n" + "  fa = f(u_min) = " + String(fa) + "\n" + "  fb = f(u_max) = " + String(fb) + "\n" + "fa and fb must have opposite sign which is not the case");
  end if;
  c := a;
  fc := fa;
  e := b - a;
  d := e;
  while not found loop
   if abs(fc) < abs(fb) then
    a := b;
    b := c;
    c := a;
    fa := fb;
    fb := fc;
    fc := fa;
   end if;
   tol := 2 * 1.0E-15 * abs(b) + tolerance;
   m := (c - b) / 2;
   if abs(m) <= tol or fb == 0.0 then
    found := true;
    u := b;
   else
    if abs(e) < tol or abs(fa) <= abs(fb) then
     e := m;
     d := e;
    else
     s := fb / fa;
     if a == c then
      p := 2 * m * s;
      q := 1 - s;
     else
      q := fa / fc;
      r := fb / fc;
      p := s * (2 * m * q * (q - r) - (b - a) * (r - 1));
      q := (q - 1) * (r - 1) * (s - 1);
     end if;
     if p > 0 then
      q := - q;
     else
      p := - p;
     end if;
     s := e;
     e := d;
     if 2 * p < 3 * m * q - abs(tol * q) and p < abs(0.5 * s * q) then
      d := p / q;
     else
      e := m;
      d := e;
     end if;
    end if;
    a := b;
    fa := fb;
    b := b + (if abs(d) > tol then d elseif m > 0 then tol else - tol);
    fb := Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha.residue(aa, bb, ww, b);
    if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
     c := a;
     fc := fa;
     e := b - a;
     d := e;
    end if;
   end if;
  end while;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha.solveOneNonlinearEquation;

 function Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha.residue
  input Real a;
  input Real b;
  input Real w;
  input Real z;
  output Real res;
 algorithm
  res := z ^ 2 + (a * w * z / (1 + z)) ^ 2 - (2 + b * w ^ 2) * z + 1;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha.residue;

 function Modelica.Blocks.Continuous.Internal.Filter.roots.bandStop
  input Real[:] cr_in;
  input Real[:] c0_in;
  input Real[:] c1_in;
  input Real f_min;
  input Real f_max;
  output Real[:] a;
  output Real[:] b;
  output Real[:] ku;
  output Real[:] k1;
  output Real[:] k2;
  Real[:] cr;
  Real[:] c0;
  Real[:] c1;
  Real cn;
  Real bb;
 algorithm
  assert(size(c0_in, 1) == size(c1_in, 1), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.roots.bandStop', component 'c1_in', dimension '1'");
  init a as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init b as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init ku as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init k1 as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init k2 as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init cr as Real[0];
  init c0 as Real[size(a, 1)];
  init c1 as Real[size(a, 1)];
  (cr, c0, c1) := Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandStop(cr_in, c0_in, c1_in, f_min, f_max);
  for i in 1:size(a, 1) loop
   a[i] := (- c1[i]) / 2;
   bb := c0[i] - a[i] * a[i];
   assert(bb >= 0, "\nNot possible to use band stop filter, since transformation results in\n" + "system that does not have conjugate complex poles.\n" + "Try to use another analog filter for the band stop filter.\n");
   b[i] := sqrt(bb);
   ku[i] := c0[i] / b[i];
   k1[i] := 2 * a[i] / ku[i];
   k2[i] := (c0[i] + a[i] ^ 2 - b[i] ^ 2) / (b[i] * ku[i]);
  end for;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.roots.bandStop;

 function Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandStop
  input Real[:] cr_in;
  input Real[:] c0_in;
  input Real[:] c1_in;
  input Real f_min;
  input Real f_max;
  output Real[:] cr;
  output Real[:] c0;
  output Real[:] c1;
  Real f0;
  Real w_cut;
  Real w_band;
  Real w_cut2;
  Real c;
  Real ww;
  Real alpha;
  Integer j;
 algorithm
  assert(size(c0_in, 1) == size(c1_in, 1), "Mismatching sizes in function 'Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandStop', component 'c1_in', dimension '1'");
  init cr as Real[0];
  init c0 as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  init c1 as Real[size(cr_in, 1) + 2 * size(c0_in, 1)];
  f0 := sqrt(f_min * f_max);
  w_cut := 2 * 3.141592653589793 * f0;
  w_band := (f_max - f_min) / f0;
  w_cut2 := w_cut * w_cut;
  assert(f_min > 0 and f_min < f_max, "Band frequencies f_min and f_max are wrong");
  for i in 1:size(cr_in, 1) loop
   c1[i] := w_cut * w_band / cr_in[i];
   c0[i] := w_cut2;
  end for;
  for i in 1:size(c1_in, 1) loop
   ww := w_band / c0_in[i];
   alpha := Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha(c1_in[i], c0_in[i], ww);
   c := c1_in[i] * ww / (alpha + 1 / alpha);
   j := size(cr_in, 1) + 2 * i - 1;
   c1[j] := w_cut * c / alpha;
   c1[j + 1] := w_cut * c * alpha;
   c0[j] := w_cut2 / alpha ^ 2;
   c0[j + 1] := w_cut2 * alpha ^ 2;
  end for;
  return;
 end Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandStop;

 function Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.eff.getArrayAsString
  input Real[:] array;
  input String varName;
  input Integer minimumLength;
  input Integer significantDigits;
  output String str;
 algorithm
  str := "";
  for i in 1:size(array, 1) loop
   str := str + "  " + varName + "[" + String(i) + "]=" + String(array[i], minimumLength, significantDigits) + "\n";
  end for;
  return;
 end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.eff.getArrayAsString;

 function Modelica.Utilities.Streams.print
  input String string;
  input String fileName;
 algorithm
  external "C" ModelicaInternal_print(string, fileName);
  return;
 end Modelica.Utilities.Streams.print;

 function Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure
  input Real V_flow;
  input Real r_N;
  input Real[:] d;
  input Real dpMax;
  input Real V_flow_max;
  input Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal per;
  output Real dp;
  Real r_R;
  Integer i;
  Real rat;
 algorithm
  assert(per.n == size(per.V_flow, 1), "Mismatching sizes in function 'Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure', component 'per.V_flow', dimension '1'");
  assert(per.n == size(per.dp, 1), "Mismatching sizes in function 'Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure', component 'per.dp', dimension '1'");
  if r_N > 0.05 then
   r_R := r_N;
  elseif r_N < 0 then
   r_R := 0.025;
  else
   r_R := Modelica.Fluid.Utilities.cubicHermite(r_N, 0, 0.05, 0.025, 0.05, 0, 1);
  end if;
  i := 1;
  rat := V_flow / r_R;
  for j in 1:size(d, 1) - 1 loop
   if rat > per.V_flow[j] then
    i := j;
   end if;
  end for;
  if r_N >= 0 then
   dp := r_N ^ 2 * Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(rat, per.V_flow[i], per.V_flow[i + 1], per.dp[i], per.dp[i + 1], d[i], d[i + 1]);
  else
   dp := (- r_N ^ 2) * (dpMax - dpMax / V_flow_max * V_flow);
  end if;
  return;
 annotation(smoothOrder = 1);
 end Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure;

 function Modelica.Fluid.Utilities.cubicHermite
  input Real x;
  input Real x1;
  input Real x2;
  input Real y1;
  input Real y2;
  input Real y1d;
  input Real y2d;
  output Real y;
  Real h;
  Real t;
  Real h00;
  Real h10;
  Real h01;
  Real h11;
  Real aux3;
  Real aux2;
 algorithm
  h := x2 - x1;
  if abs(h) > 0 then
   t := (x - x1) / h;
   aux3 := t ^ 3;
   aux2 := t ^ 2;
   h00 := 2 * aux3 - 3 * aux2 + 1;
   h10 := aux3 - 2 * aux2 + t;
   h01 := -2 * aux3 + 3 * aux2;
   h11 := aux3 - aux2;
   y := y1 * h00 + h * y1d * h10 + y2 * h01 + h * y2d * h11;
  else
   y := (y1 + y2) / 2;
  end if;
  return;
 annotation(smoothOrder = 3);
 end Modelica.Fluid.Utilities.cubicHermite;

 function Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation
  input Real x;
  input Real x1;
  input Real x2;
  input Real y1;
  input Real y2;
  input Real y1d;
  input Real y2d;
  output Real y;
 algorithm
  if x > x1 and x < x2 then
   y := Modelica.Fluid.Utilities.cubicHermite(x, x1, x2, y1, y2, y1d, y2d);
  elseif x <= x1 then
   y := y1 + (x - x1) * y1d;
  else
   y := y2 + (x - x2) * y2d;
  end if;
  return;
 annotation(smoothOrder = 1);
 end Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation;

 function Buildings.Fluid.Movers.BaseClasses.Characteristics.power
  input Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters per;
  input Real V_flow;
  input Real r_N;
  input Real[:] d;
  input Real delta;
  output Real P;
  Integer n;
  Real rat;
  Integer i;
 algorithm
  assert(size(per.V_flow, 1) == size(per.P, 1), "Mismatching sizes in function 'Buildings.Fluid.Movers.BaseClasses.Characteristics.power', component 'per.P', dimension '1'");
  n := size(per.V_flow, 1);
  if n == 1 then
   P := r_N ^ 3 * per.P[1];
  else
   i := 1;
   rat := V_flow / Buildings.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta);
   for j in 1:n - 1 loop
    if rat > per.V_flow[j] then
     i := j;
    end if;
   end for;
   P := r_N ^ 3 * Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(rat, per.V_flow[i], per.V_flow[i + 1], per.P[i], per.P[i + 1], d[i], d[i + 1]);
  end if;
  return;
 annotation(smoothOrder = 1);
 end Buildings.Fluid.Movers.BaseClasses.Characteristics.power;

 function Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency
  input Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per;
  input Real V_flow;
  input Real[:] d;
  input Real r_N;
  input Real delta;
  output Real eta;
  Integer n;
  Real rat;
  Integer i;
 algorithm
  assert(size(per.V_flow, 1) == size(per.eta, 1), "Mismatching sizes in function 'Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency', component 'per.eta', dimension '1'");
  n := size(per.V_flow, 1);
  if n == 1 then
   eta := per.eta[1];
  else
   rat := V_flow / Buildings.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta);
   i := 1;
   for j in 1:n - 1 loop
    if rat > per.V_flow[j] then
     i := j;
    end if;
   end for;
   eta := Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(rat, per.V_flow[i], per.V_flow[i + 1], per.eta[i], per.eta[i + 1], d[i], d[i + 1]);
  end if;
  return;
 annotation(smoothOrder = 1);
 end Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency;

 function Modelica.Fluid.Utilities.checkBoundary
  input String mediumName;
  input String[:] substanceNames;
  input Boolean singleState;
  input Boolean define_p;
  input Real[:] X_boundary;
  input String modelName;
  Integer nX;
  String X_str;
 algorithm
  nX := size(X_boundary, 1);
  assert(not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \"" + modelName + "\":
The selected medium \"" + mediumName + "\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
  for i in 1:nX loop
   assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \"" + mediumName + "\" in model \"" + modelName + "\":
The boundary value X_boundary(" + String(i) + ") = " + String(X_boundary[i]) + "
is negative. It must be positive.
");
  end for;
  if nX > 0 and abs(sum(X_boundary[:]) - 1.0) > 1.0E-10 then
   X_str := "";
   for i in 1:nX loop
    X_str := X_str + "   X_boundary[" + String(i) + "] = " + String(X_boundary[i]) + " \"" + substanceNames[i] + "\"\n";
   end for;
   Modelica.Utilities.Streams.error("The boundary mass fractions in medium \"" + mediumName + "\" in model \"" + modelName + "\"\n" + "do not sum up to 1. Instead, sum(X_boundary) = " + String(sum(X_boundary[:])) + ":\n" + X_str);
  end if;
  return;
 end Modelica.Fluid.Utilities.checkBoundary;

 function Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.eff.getArrayAsString
  input Real[:] array;
  input String varName;
  input Integer minimumLength;
  input Integer significantDigits;
  output String str;
 algorithm
  str := "";
  for i in 1:size(array, 1) loop
   str := str + "  " + varName + "[" + String(i) + "]=" + String(array[i], minimumLength, significantDigits) + "\n";
  end for;
  return;
 end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.eff.getArrayAsString;

 function Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.eff.getArrayAsString
  input Real[:] array;
  input String varName;
  input Integer minimumLength;
  input Integer significantDigits;
  output String str;
 algorithm
  str := "";
  for i in 1:size(array, 1) loop
   str := str + "  " + varName + "[" + String(i) + "]=" + String(array[i], minimumLength, significantDigits) + "\n";
  end for;
  return;
 end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.eff.getArrayAsString;

 function Buildings.Media.Water.pressure
  input Buildings.Media.Water.ThermodynamicState state;
  output Real p;
 algorithm
  p := state.p;
  return;
 end Buildings.Media.Water.pressure;

 function Buildings.Media.Water.setState_dTX
  input Real d;
  input Real T;
  input Real[:] X;
  output Buildings.Media.Water.ThermodynamicState state;
 algorithm
  assert(false, "Pressure can not be computed from temperature and density for an incompressible fluid!");
  return;
 end Buildings.Media.Water.setState_dTX;

 record Buildings.Media.Water.ThermodynamicState
  Buildings.Media.Water.AbsolutePressure p "Absolute pressure of medium";
  Buildings.Media.Water.Temperature T "Temperature of medium";
 end Buildings.Media.Water.ThermodynamicState;

 record Buildings.Media.Air.ThermodynamicState
  Buildings.Media.Air.AbsolutePressure p "Absolute pressure of medium";
  Buildings.Media.Air.Temperature T "Temperature of medium";
  Buildings.Media.Air.MassFraction X[2] "Mass fractions (= (component mass)/total mass  m_i/m)";
 end Buildings.Media.Air.ThermodynamicState;

 record Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters
  parameter Modelica.SIunits.VolumeFlowRate V_flow[:] "Volume flow rate at user-selected operating points";
  parameter Modelica.SIunits.Pressure dp[size(V_flow[:], 1)] "Fan or pump total pressure at these flow rates";
 end Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters;

 record Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
  parameter Modelica.SIunits.VolumeFlowRate V_flow[:] "Volumetric flow rate at user-selected operating points";
  parameter Modelica.SIunits.Efficiency eta[size(V_flow[:], 1)] "Fan or pump efficiency at these flow rates";
 end Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters;

 record Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters
  parameter Modelica.SIunits.VolumeFlowRate V_flow[:] "Volume flow rate at user-selected operating points";
  parameter Modelica.SIunits.Power P[size(V_flow[:], 1)] "Fan or pump electrical power at these flow rates";
 end Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters;

 record Buildings.Fluid.Movers.Data.Generic
  parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters pressure "Volume flow rate vs. total pressure rise";
  parameter Boolean use_powerCharacteristic "Use power data instead of motor efficiency";
  parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters hydraulicEfficiency "Hydraulic efficiency (used if use_powerCharacteristic=false)";
  parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters motorEfficiency "Electric motor efficiency (used if use_powerCharacteristic=false)";
  parameter Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters power "Volume flow rate vs. electrical power consumption (used if use_powerCharacteristic=true)";
  parameter Boolean motorCooledByFluid "If true, then motor heat is added to fluid stream";
  parameter Real speed_nominal "Nominal rotational speed for flow characteristic";
  parameter Real constantSpeed "Normalized speed set point, used if inputType = Buildings.Fluid.Types.InputType.Constant";
  parameter Real speeds[:] "Vector of normalized speed set points, used if inputType = Buildings.Fluid.Types.InputType.Stages";
  parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm speed_rpm_nominal "Nominal rotational speed for flow characteristic";
  parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm constantSpeed_rpm "Speed set point, used if inputType = Buildings.Fluid.Types.InputType.Constant";
  parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm speeds_rpm[:] "Vector of speed set points, used if inputType = Buildings.Fluid.Types.InputType.Stages";
  parameter Boolean havePressureCurve "= true, if default record values are being used";
 end Buildings.Fluid.Movers.Data.Generic;

 record Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal
  parameter Integer n "Number of elements in each array";
  parameter Modelica.SIunits.VolumeFlowRate V_flow[n] "Volume flow rate at user-selected operating points";
  parameter Modelica.SIunits.Pressure dp[n] "Fan or pump total pressure at these flow rates";
 end Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal;

 type Modelica.Blocks.Types.SimpleController = enumeration(P "P controller", PI "PI controller", PD "PD controller", PID "PID controller");

 type Modelica.Blocks.Types.InitPID = enumeration(NoInit "No initialization (start values are used as guess values with fixed=false)", SteadyState "Steady state initialization (derivatives of states are zero)", InitialState "Initialization with initial states", InitialOutput "Initialization with initial outputs (and steady state of the states if possible)", DoNotUse_InitialIntegratorState "Do not use, only for backward compatibility (initialize only integrator state)");

 type Buildings.Fluid.Types.HeatExchangerConfiguration = enumeration(ParallelFlow "Parallel flow", CounterFlow "Counter flow", CrossFlowUnmixed "Cross flow, both streams unmixed", CrossFlowStream1MixedStream2Unmixed "Cross flow, stream 1 mixed, stream 2 unmixed", CrossFlowStream1UnmixedStream2Mixed "Cross flow, stream 1 unmixed, stream 2 mixed", ConstantTemperaturePhaseChange "Constant temperature phase change in one stream");

 type Buildings.Fluid.Types.HeatExchangerFlowRegime = enumeration(ParallelFlow "Parallel flow", CounterFlow "Counter flow", CrossFlowUnmixed "Cross flow, both streams unmixed", CrossFlowCMinMixedCMaxUnmixed "Cross flow, CMin mixed,   CMax unmixed", CrossFlowCMinUnmixedCMaxMixed "Cross flow, CMin unmixed, CMax mixed", ConstantTemperaturePhaseChange "Constant temperature phase change in one stream");

 type Modelica.Utilities.Types.Compare = enumeration(Less "String 1 is lexicographically less than string 2", Equal "String 1 is identical to string 2", Greater "String 1 is lexicographically greater than string 2");

 type Buildings.Types.Reset = enumeration(Disabled "Disabled", Parameter "Use parameter value", Input "Use input signal");

 type Modelica.Blocks.Types.Init = enumeration(NoInit "No initialization (start values are used as guess values with fixed=false)", SteadyState "Steady state initialization (derivatives of states are zero)", InitialState "Initialization with initial states", InitialOutput "Initialization with initial outputs (and steady state of the states if possible)");

 type Buildings.Fluid.Types.CvTypes = enumeration(OpPoint "flow coefficient defined by m_flow_nominal/sqrt(dp_nominal)", Kv "Kv (metric) flow coefficient", Cv "Cv (US) flow coefficient", Av "Av (metric) flow coefficient");

 type Modelica.Blocks.Types.Smoothness = enumeration(LinearSegments "Table points are linearly interpolated", ContinuousDerivative "Table points are interpolated (by Akima splines) such that the first derivative is continuous", ConstantSegments "Table points are not interpolated, but the value from the previous abscissa point is returned", MonotoneContinuousDerivative1 "Table points are interpolated (by Fritsch-Butland splines) such that the monotonicity is preserved and the first derivative is continuous", MonotoneContinuousDerivative2 "Table points are interpolated (by Steffen splines) such that the monotonicity is preserved and the first derivative is continuous");

 type Modelica.Blocks.Types.Extrapolation = enumeration(HoldLastPoint "Hold the first/last table point outside of the table scope", LastTwoPoints "Extrapolate by using the derivative at the first/last table points outside of the table scope", Periodic "Repeat the table scope periodically", NoExtrapolation "Extrapolation triggers an error");

 type Buildings.Fluid.Types.InputType = enumeration(Constant "Use parameter to set stage", Stages "Use integer input to select stage", Continuous "Use continuous, real input");

 type Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable = enumeration(Speed "Speed is prescribed", FlowRate "Flow rate is prescribed", PressureDifference "Pressure difference is prescribed");

 type StateSelect = enumeration(never "Do not use as state at all.", avoid "Use as state, if it cannot be avoided (but only if variable appears differentiated and no other potential state with attribute default, prefer, or always can be selected).", default "Use as state if appropriate, but only if variable appears differentiated.", prefer "Prefer it as state over those having the default value (also variables can be selected, which do not appear differentiated).", always "Do use it as a state.");

 type Modelica.Fluid.Types.Dynamics = enumeration(DynamicFreeInitial "DynamicFreeInitial -- Dynamic balance, Initial guess value", FixedInitial "FixedInitial -- Dynamic balance, Initial value fixed", SteadyStateInitial "SteadyStateInitial -- Dynamic balance, Steady state initial with guess value", SteadyState "SteadyState -- Steady state balance, Initial guess value");

 type Modelica.Blocks.Types.AnalogFilter = enumeration(CriticalDamping "Filter with critical damping", Bessel "Bessel filter", Butterworth "Butterworth filter", ChebyshevI "Chebyshev I filter");

 type Modelica.Blocks.Types.FilterType = enumeration(LowPass "Low pass filter", HighPass "High pass filter", BandPass "Band pass filter", BandStop "Band stop / notch filter");

 type Buildings.Controls.OBC.CDL.Types.SimpleController = enumeration(P "P controller", PI "PI controller", PD "PD controller", PID "PID controller");

 type Buildings.Controls.OBC.CDL.Types.Reset = enumeration(Disabled "Disabled", Parameter "Use parameter value", Input "Use input signal");

 type Modelica.Fluid.Types.PortFlowDirection = enumeration(Entering "Fluid flow is only entering", Leaving "Fluid flow is only leaving", Bidirectional "No restrictions on fluid flow (flow reversal possible)");

 type Buildings.Applications.DHC.Loads.Types.DistributionType = enumeration(HeatingWater "Heating water distribution system", ChilledWater "Chilled water distribution system", ChangeOver "Change-over distribution system");

 type Buildings.Applications.DHC.Loads.Types.PumpControlType = enumeration(ConstantSpeed "Constant speed", ConstantFlow "Constant flow rate (three-way valves)", ConstantHead "Constant pump head", LinearHead "Linear relationship between pump head and mass flow rate", ConstantDp "Constant pressure difference at given location");

 type AssertionLevel = enumeration(error, warning);

 type Modelica.Media.Interfaces.Choices.IndependentVariables = enumeration(T "Temperature", pT "Pressure, Temperature", ph "Pressure, Specific Enthalpy", phX "Pressure, Specific Enthalpy, Mass Fraction", pTX "Pressure, Temperature, Mass Fractions", dTX "Density, Temperature, Mass Fractions");

 type Modelica.SIunits.MassFlowRate = Real(quantity = "MassFlowRate",final unit = "kg/s");
 type Modelica.SIunits.TemperatureDifference = Real(final quantity = "ThermodynamicTemperature",final unit = "K");
 type Modelica.SIunits.Pressure = Real(final quantity = "Pressure",final unit = "Pa",displayUnit = "bar");
 type Modelica.SIunits.HeatFlowRate = Real(final quantity = "Power",final unit = "W");
 type Modelica.SIunits.ThermodynamicTemperature = Real(final quantity = "ThermodynamicTemperature",final unit = "K",min = 0.0,start = 288.15,nominal = 300,displayUnit = "degC");
 type Modelica.SIunits.Efficiency = Real(final quantity = "Efficiency",final unit = "1",min = 0);
 type Modelica.SIunits.Time = Real(final quantity = "Time",final unit = "s");
 type Modelica.Blocks.Interfaces.RealInput = Real;
 type Modelica.Blocks.Interfaces.RealOutput = Real;
 type Modelica.SIunits.ThermalConductance = Real(final quantity = "ThermalConductance",final unit = "W/K");
 type Buildings.Media.Water.AbsolutePressure = Real(start = 300000.0,min = 0,max = 1.0E8,nominal = 100000.0,final quantity = "Pressure",final unit = "Pa",displayUnit = "bar");
 type Buildings.Media.Water.Temperature = Real(start = 293.15,min = 1,max = 10000.0,nominal = 300,final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC");
 type Modelica.SIunits.SpecificHeatCapacity = Real(final quantity = "SpecificHeatCapacity",final unit = "J/(kg.K)");
 type Buildings.Media.Water.MassFlowRate = Real(quantity = "MassFlowRate." + "SimpleLiquidWater",min = -100000.0,max = 100000.0,final unit = "kg/s");
 type Buildings.Media.Water.SpecificEnthalpy = Real(min = -1.0E10,max = 1.0E10,nominal = 1000000.0,final quantity = "SpecificEnergy",final unit = "J/kg");
 type Buildings.Media.Water.MassFraction = Real(quantity = "MassFraction",final unit = "kg/kg",min = 0,max = 1,nominal = 0.1);
 type Buildings.Media.Water.ExtraProperty = Real(min = 0.0,start = 1.0);
 type Modelica.SIunits.DynamicViscosity = Real(final quantity = "DynamicViscosity",final unit = "Pa.s",min = 0);
 type Modelica.Blocks.Interfaces.BooleanInput = Boolean;
 type Modelica.SIunits.Area = Real(final quantity = "Area",final unit = "m2");
 type Modelica.SIunits.Density = Real(final quantity = "Density",final unit = "kg/m3",displayUnit = "g/cm3",min = 0.0);
 type Buildings.Media.Air.AbsolutePressure = Real(start = 101325.0,min = 0,max = 1.0E8,nominal = 100000.0,final quantity = "Pressure",final unit = "Pa",displayUnit = "bar");
 type Buildings.Media.Air.Temperature = Real(start = 293.15,min = 1,max = 10000.0,nominal = 300,final quantity = "ThermodynamicTemperature",final unit = "K",displayUnit = "degC");
 type Buildings.Media.Air.MassFraction = Real(quantity = "MassFraction",final unit = "kg/kg",min = 0,max = 1,nominal = 0.1);
 type Modelica.Blocks.Types.ExternalCombiTimeTable = ExternalObject;
 type Modelica.SIunits.VolumeFlowRate = Real(final quantity = "VolumeFlowRate",final unit = "m3/s");
 type Modelica.SIunits.Power = Real(final quantity = "Power",final unit = "W");
 type Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm = Real(final quantity = "AngularVelocity",final unit = "rev/min");
 type Modelica.SIunits.SpecificEnergy = Real(final quantity = "SpecificEnergy",final unit = "J/kg");
 type Modelica.SIunits.Volume = Real(final quantity = "Volume",final unit = "m3");
 type Buildings.Media.Air.MassFlowRate = Real(quantity = "MassFlowRate." + "Air",min = -100000.0,max = 100000.0,final unit = "kg/s");
 type Buildings.Media.Air.SpecificEnthalpy = Real(min = -1.0E10,max = 1.0E10,nominal = 1000000.0,final quantity = "SpecificEnergy",final unit = "J/kg");
 type Buildings.Media.Air.ExtraProperty = Real(min = 0.0,start = 1.0);
 type Modelica.SIunits.MassFraction = Real(final quantity = "MassFraction",final unit = "1",min = 0,max = 1);
 type Modelica.SIunits.MolarMass = Real(final quantity = "MolarMass",final unit = "kg/mol",min = 0);
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol.dynBal.medium.InputAbsolutePressure = Real(min = 0.0,nominal = 100000.0,final quantity = "Pressure",final unit = "Pa",displayUnit = "bar");
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol.dynBal.medium.InputMassFraction = Real(final quantity = "MassFraction",final unit = "1",min = 0,max = 1);
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniHea.fan.vol.dynBal.medium.InputSpecificEnthalpy = Real(final quantity = "SpecificEnergy",final unit = "J/kg");
 type Buildings.Media.Air.Density = Real(min = 0,max = 100000.0,nominal = 1,start = 1,final quantity = "Density",final unit = "kg/m3",displayUnit = "g/cm3");
 type Buildings.Media.Air.SpecificEnergy = Real(min = -1.0E8,max = 1.0E8,nominal = 1000000.0,final quantity = "SpecificEnergy",final unit = "J/kg");
 type Buildings.Media.Air.SpecificHeatCapacity = Real(min = 0,max = 1.0E7,nominal = 1000.0,start = 1000.0,final quantity = "SpecificHeatCapacity",final unit = "J/(kg.K)");
 type Buildings.Media.Air.MolarMass = Real(min = 0.001,max = 0.25,nominal = 0.032,final quantity = "MolarMass",final unit = "kg/mol");
 type Modelica.SIunits.Conversions.NonSIunits.Temperature_degC = Real(final quantity = "ThermodynamicTemperature",final unit = "degC");
 type Modelica.SIunits.Conversions.NonSIunits.Pressure_bar = Real(final quantity = "Pressure",final unit = "bar");
 type Modelica.SIunits.Energy = Real(final quantity = "Energy",final unit = "J");
 type Modelica.SIunits.Mass = Real(quantity = "Mass",final unit = "kg",min = 0);
 type Buildings.Media.Air.ExtraPropertyFlowRate = Real(unit = "kg/s");
 type Modelica.SIunits.EnthalpyFlowRate = Real(final quantity = "EnthalpyFlowRate",final unit = "W");
 type Modelica.SIunits.HeatCapacity = Real(final quantity = "HeatCapacity",final unit = "J/K");
 type Buildings.Media.Air.EnthalpyFlowRate = Real(nominal = 1000.0,min = -1.0E8,max = 1.0E8,final quantity = "EnthalpyFlowRate",final unit = "W");
 type Modelica.SIunits.Frequency = Real(final quantity = "Frequency",final unit = "Hz");
 type Modelica.SIunits.LinearTemperatureCoefficient = Real(final quantity = "LinearTemperatureCoefficient",final unit = "1/K");
 type Buildings.Controls.OBC.CDL.Interfaces.RealInput = Real;
 type Buildings.Controls.OBC.CDL.Interfaces.RealOutput = Real;
 type Buildings.Controls.OBC.CDL.Interfaces.BooleanInput = Boolean;
 type Buildings.Controls.OBC.CDL.Interfaces.BooleanOutput = Boolean;
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol.dynBal.medium.InputAbsolutePressure = Real(min = 0.0,nominal = 100000.0,final quantity = "Pressure",final unit = "Pa",displayUnit = "bar");
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol.dynBal.medium.InputMassFraction = Real(final quantity = "MassFraction",final unit = "1",min = 0,max = 1);
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloHea.heaCoo.vol.dynBal.medium.InputSpecificEnthalpy = Real(final quantity = "SpecificEnergy",final unit = "J/kg");
 type Buildings.Media.Water.ExtraPropertyFlowRate = Real(unit = "kg/s");
 type Buildings.Media.Water.EnthalpyFlowRate = Real(nominal = 1000.0,min = -1.0E8,max = 1.0E8,final quantity = "EnthalpyFlowRate",final unit = "W");
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol.dynBal.medium.InputAbsolutePressure = Real(min = 0.0,nominal = 100000.0,final quantity = "Pressure",final unit = "Pa",displayUnit = "bar");
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol.dynBal.medium.InputMassFraction = Real(final quantity = "MassFraction",final unit = "1",min = 0,max = 1);
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.disFloCoo.heaCoo.vol.dynBal.medium.InputSpecificEnthalpy = Real(final quantity = "SpecificEnergy",final unit = "J/kg");
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol.dynBal.medium.InputAbsolutePressure = Real(min = 0.0,nominal = 100000.0,final quantity = "Pressure",final unit = "Pa",displayUnit = "bar");
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol.dynBal.medium.InputMassFraction = Real(final quantity = "MassFraction",final unit = "1",min = 0,max = 1);
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.bui.terUniCoo.fan.vol.dynBal.medium.InputSpecificEnthalpy = Real(final quantity = "SpecificEnergy",final unit = "J/kg");
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.vol.dynBal.medium.InputAbsolutePressure = Real(min = 0.0,nominal = 100000.0,final quantity = "Pressure",final unit = "Pa",displayUnit = "bar");
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.vol.dynBal.medium.InputMassFraction = Real(final quantity = "MassFraction",final unit = "1",min = 0,max = 1);
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pumBui.vol.dynBal.medium.InputSpecificEnthalpy = Real(final quantity = "SpecificEnergy",final unit = "J/kg");
 type Buildings.Media.Water.Density = Real(start = 995.586,min = 0,max = 100000.0,nominal = 1,final quantity = "Density",final unit = "kg/m3",displayUnit = "g/cm3");
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pre.medium.InputAbsolutePressure = Real(min = 0.0,nominal = 100000.0,final quantity = "Pressure",final unit = "Pa",displayUnit = "bar");
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pre.medium.InputMassFraction = Real(final quantity = "MassFraction",final unit = "1",min = 0,max = 1);
 type Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding.pre.medium.InputSpecificEnthalpy = Real(final quantity = "SpecificEnergy",final unit = "J/kg");
end Buildings.Applications.DHC.EnergyTransferStations.CouplingETS_TimeSeriesBuilding;
</pre>
</body>
</html>
